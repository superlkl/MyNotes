# 为什么要用类集框架

**认识：**

在开发过程中，常常需要集中存放多个数据。我们知道，数组可以实现这个功能。但是，数组的长度是固定的，如果我们存放的数据数量是动态变化的该怎么办？这个时候，就要用到Java的集合类了。 

所有的集合都位于`java.util`包下。Java集合类有两个主要的接口：Collection和Map。他们是集合的根接口。在集合中，Map结尾的类实现了Map接口，而其他的集合类实现了Collection接口。

-  Collection是一个接口，它包含了集合的基本操作和属性。分为了List和Set两大分支。其中，List是一个有序的队列，其中的元素不唯一。而Set是一个无序的集合，其中的元素是唯一的 
-  List的实现类有`ArrayList`、`LinkedList`、`Vector`及`Stack`。 

-  Set的实现类有`HashSet`、`TreeSet`、`LinkedHashSet`及`EnumSet`。 

- Map也是一个接口，而且是一个映射接口，值以键值对(key-value)的形式存储。实现类有`EnumMap`、`HashMap`、`TreeMap`、`WeakHaskMap`、`ConcurrentHashMap`及`IdentityHashMap`。
-  `Iteator`(迭代器)是一个用来遍历集合的工具，我们可以看到Collection接口就依赖于`Iterabe`接口，所以，在Collection的实现类中可以使用Iterator来遍历元素。 

# 一、List接口

## `ArrayList`

**测试1**

```java
public class Test {
    public static void main(String[] args) {
        List<String>list=null;
        list=new ArrayList<>();
        list.add("Hello");
        list.add(0,"World");
        list.add(0,"come on");
        System.out.println(list);
        System.out.println(list.get(2));
        //返回的是删除的数据,也可以指定删除的对象
        //list.remove("Hello");
        System.out.println(list.remove(2));
        System.out.println(list);
        //判断World是否存在
        System.out.println(list.contains("World"));
        //返回大小
        System.out.println(list.size());
    }
}
```

**add方法:**`void add(int index, E element);`

从输出可以看出add在指定位置添加`come on`时即使是添加到同一个位置也不会覆盖之前的`world`，而是将之前的`world`向后移动一个位置

- `ArrayList`是一个**动态数组**，也是我们最常用的集合。它**允许任何符合规则的元素插入甚至包括null**。每一个`ArrayList`都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以**如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。** 

> **`ArrayList`擅长于随机访问。同时`ArrayList`是非同步的。** 

```java
List<String>list=null;
list=new ArrayList<>(5);
```

在小括号里面指定数组的初始大小

## `LinkedList`

表示的是一个链表的操作类, 与`ArrayList`相比，`LinkedList`的增删操作效率更高，而查改操作效率较低。 

### 常用方法

### 增

```java
public boolean add(E e)  //链表末尾添加元素，返回是否成功；
public void add(int index, E element)  //向指定位置插入元素；
public boolean addAll(Collection<? extends E> c)  //将一个集合的所有元素添加到链表后面，返回是否成功；
public boolean addAll(int index, Collection<? extends E> c)  //将一个集合的所有元素添加到链表的指定位置后面，返回是否成功；
public void addFirst(E e)  //添加到第一个元素；
public void addLast(E e)  //添加到最后一个元素；
public boolean offer(E e)  //向链表末尾添加元素，返回是否成功；
public boolean offerFirst(E e)  //头部插入元素，返回是否成功；
public boolean offerLast(E e)  //尾部插入元素，返回是否成功；
```

`addFirst(E e)`和`offerFirst(E e)`都可以向链表中插入数据，只是返回值不同，一个返回值为空，一个是布尔类型

```java
LinkedList<String> list=new LinkedList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        list.addFirst("D");
        System.out.println(list);
        Boolean insert=list.offerFirst("E");
        System.out.println(list);
        System.out.println(insert);
```

### 删

```java
public void clear()  //清空链表；
public E removeFirst()  //删除并返回第一个元素；
public E removeLast()  //删除并返回最后一个元素；
public boolean remove(Object o)  //删除某一元素，返回是否成功；
public E remove(int index)  //删除指定位置的元素；
public E poll()  //删除并返回第一个元素；
public E remove()  //删除并返回第一个元素；
```

### 改

```java
public E set(int index, E element)  //设置指定位置的元素；
```

### 查

```java
public boolean contains(Object o) //判断是否含有某一元素；
public E get(int index) //返回指定位置的元素；
public E getFirst() //返回第一个元素；
public E getLast() //返回最后一个元素；
public int indexOf(Object o) //查找指定元素从前往后第一次出现的索引；
public int lastIndexOf(Object o) //查找指定元素最后一次出现的索引；
public E peek() //返回第一个元素；
public E element() //返回第一个元素；
public E peekFirst() //返回头部元素；
public E peekLast() //返回尾部元素；
```

### 其他

```java
public Object clone() //克隆该列表；
public Iterator<E> descendingIterator() //返回倒序迭代器；
public int size() //返回链表元素个数；
public ListIterator<E> listIterator(int index) //返回从指定位置开始到末尾的迭代器；
public Object[] toArray() //返回一个由链表元素组成的数组；
public <T> T[] toArray(T[] a) //返回一个由链表元素转换类型而成的数组；
```

### 测试

```java
package my;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        LinkedList<String> list=new LinkedList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        list.add("D");
        System.out.println("生成链表输出：");
        System.out.println(list);
        //在链表的表头和表尾增加数据
        list.addFirst("X");
        list.addLast("Y");
        System.out.println("增加表头和表尾:"+list);
        System.out.println("找到表头:"+list.element());
        System.out.println(list);
        System.out.println("找不到删除表头:"+list.peek());
        System.out.println(list);
        System.out.println("找到并删除表头:"+list.poll());
        System.out.println(list);
    }
}

```

 **peek()和element()有什么区别 ？**

 peek()，如果链表为空，则返回null。element()，如果链表为空，则抛异常。 

**介绍：**

同样实现List接口的`LinkedList`与`ArrayList`不同，`LinkedList`是一个双向链表。所以它除了有`ArrayList`的基本操作方法外还额外提供了get，remove，insert方法在`LinkedList`的首部或尾部。

由于实现的方式不同，**`LinkedList`不能随机访问，它所有的操作都是要按照双重链表的需要执行**。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。

与`ArrayList`一样，`LinkedList`也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。

### 队列操作

**测试1：实现队列操作（先进先出FIFO）**

```java
LinkedList<String> list=new LinkedList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        System.out.println(list.size());
        int i=0;
        while (!list.isEmpty()){
            System.out.println(list.poll());
            i++;
        }
        System.out.println(i);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128182754515.png)

**测试2：用for循环再测试**

```java
 LinkedList<String> list=new LinkedList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        int j=0;
        System.out.println(list.size());
        for (int i=0;i<list.size();i++){
            System.out.println(list.poll());
            j++;
        }
        System.out.println(j);
```

从输出看到链表的长度本来是3的，却只循环了两次就退出了，即使改为`i<list.size()+1`也是只循环了两次，很奇怪，一定要改为`i<list.size()+2`才会完整输出！

**测试3：**

```java
        LinkedList<String> link = new LinkedList<>();
        link.add("A");
        link.add("B");
        link.add("B");
        link.add("C");
        link.add("C");
        System.out.println("初始化：" + link);
        link.addFirst("X");
        link.addLast("Y");
        System.out.println("初始化之后：" + link);
        System.out.println("找表头并删除：" + link.poll());
        System.out.println("按顺序输出：");
        for (int i = 0; i <= link.size() + 1; i++) {
            System.out.print(link.poll() + "、");
        }
    }
```

再多添加一个C，输出为A、B 、B、C、C、C

**问题解决：**

**用for遍历的方法总是不能完全输出来，因为每次在使用poll()方法后size的长度都会减少**

```java
 LinkedList<String> list=new LinkedList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        int j=0;
        System.out.println(list.size());
        for (int i=0;i<list.size();i++){
           System.out.println("poll()使用前list的长度："+list.size()+" "+"i="+i);
            System.out.println(list.poll());
            System.out.println("使用后list的长度："+list.size()+" "+"i="+i);
            j++;
        }
        System.out.println(j);
```

所以在循环两次之后循环就结束了，最好使用while循环并判断链表是否为空的方法输出对列，通过这种方式达到先进先出的的目的(First Input First Output)

## Set接口

- Set接口也是Collection接口的子接口，Set接口中不能加入重复的元素，Set接口与List接口的定义没有太大差别，Set接口的主要方法和Collection是一致的，也就是说Set接口并没有对Collection接口进行扩充，只是比Collection接口的要求更加严格了，**不能增加重复元素**
- Set接口的实例不能像List接口那样可以进行双向输出，因为此接口没有提供像List接口定义的get(int index)方法

- Set接口中有`HashSet`(散列存放)和`TreeSet`(有序存放)两个常用的子类

## `HashSet`

**散列的存放**

可以看出，在add的时候出现了相同元素都会警告，在输出之后也确实不存在相同元素，而且可以添加空元素，但在输出的时候和加入的顺序不一样

```java
public HashSet() {
        map = new HashMap<>();
    }
//add方法的返回值是布尔类型
boolean add(E e);
```

**小结：**

- 它存储唯一元素并允许空值
- 它由`HashMap`支持
- 它不保持插入顺序
- 它不是线程安全的 **（效率高）** 

## `TreeSet`

**有序的存放**

```java
 public static void main(String[] args) {
        Set<String> set=new TreeSet<>();
        set.add("C");
        set.add("C");
        set.add("D");
        set.add("A");
        set.add("B");
        System.out.println(set);
    }
```

**输出：[A, B, C, D]**

可以看出`TreeSet`也不允许存放相同的元素，而且元素在插入的时候是无序的，在输出之后就有序了，所以`TreeSet`具有排列功能

### 类排序

先定义一个person类

```java
public class People {
    private String name;
    private int age;

    People(String name,int age){
        this.name=name;
        this.age=age;
    }

    @Override
    public String toString() {
        return "People{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

测试用`TreeSet`来排序

```java
public class Test {
    public static void main(String[] args) {
        Set<People> set=new TreeSet<>();
        set.add(new People("张三",18));
        set.add(new People("李四",19));
        set.add(new People("王五",20));
        System.out.println(set);
    }
}
```

结果运行就报错了类转换异常

因为`TreeSet`中的元素是有序排放的，所以对于一个对象必须指定好其排序规则，且`TreeSet`中的每个对象所在的类都必须实现`Comparable`接口才可以正常使用

**重写：根据年龄来排序**

```java
public class People implements Comparable<People> {
    private String name;
    private int age;

    People(String name,int age){
        this.name=name;
        this.age=age;
    }

    @Override
    public String toString() {
        return "People{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public int compareTo(People per) {
        return Integer.compare(this.age, per.age);
    }
}
```

**输出：**

**[People{name='张三', age=18}, People{name='李四', age=19}, People{name='王五', age=20}]**



**修改主函数:**

```java
 Set<People> set=new TreeSet<>();
        set.add(new People("张三",18));
        set.add(new People("李四",19));
        set.add(new People("王五",20));
        set.add(new People("王五",20));
        set.add(new People("王五",21));
        set.add(new People("赵六",20));
        set.add(new People("孙七",20));
        System.out.println(set);
```

**输出：**

**[People{name='张三', age=18}, People{name='李四', age=19}, People{name='王五', age=20}, People{name='王五', age=21}]**

从输出可以看到王五的对象只有一个，而赵六和孙七只是因为年龄相同就没有被加到集合中。这是因为采用了比较器造成的，**比较器操作的时候如果某个属性没有进行比较指定的话，也会被认为是同一个对象，所以在比较方法中应该增加按姓名比较**

**修改比较方法：**

```java
  @Override
    public int compareTo(People per) {
        if (this.age>per.age){
            return 1;
        }
        else if (this.age<per.age){
            return -1;
        }
        else {
            //增加按姓名比较
            return this.name.compareTo(per.name);
        }
    }
```

**输出：**

**[People{name='张三', age=18}, People{name='李四', age=19}, People{name='孙七', age=20}, People{name='王五', age=20}, People{name='赵六', age=20}, People{name='王五', age=21}]**



从输出可以看到除了名字和年龄完全相同的一个王五没有被添加到集合中，其他人都被添加到了集合中并进行了排序

**注：虽然去掉了重复的内容，但是这种情况重复内容的去掉并不是真正意义上的去掉，因为此时是靠`Comparabale`接口完成的**



**测试：使用`HashSet`**

```java
 Set<People> set=new HashSet<>();
        set.add(new People("张三",18));
        set.add(new People("李四",19));
        set.add(new People("王五",20));
        set.add(new People("王五",20));
        set.add(new People("王五",21));
        set.add(new People("赵六",20));
        set.add(new People("孙七",20));
        System.out.println(set);
```

结果全都输出来了，也就是说，此时程序并没有像Set接口规定的那样不允许有重复元素出现。

如果此时想要除去重复元素，则必须先进行对象是否重复的判断，要想进行这样的判断就必须重写`Object`类中的`equal()`方法才能完成对象是否相等的判断，但是只是覆写这一个方法是不够的，还要覆写`hashCode()`方法，此方法表示一个哈希编码，可以简单理解为一个对象的编码，**一般的哈希码是通过公式进行计算的，可以将类中的全部属性进行适当的计算，以求出一个不会重复的哈希码**



继续修改：在使用`HashSet`的情况下修改Person类

```java
public class People  {
    private String name;
    private int age;

    People(String name,int age){
        this.name=name;
        this.age=age;
    }

    @Override
    public String toString() {
        return "People{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public boolean equals(Object object){
        if (this==object){
            return true;
        }
        if (!(object instanceof People)){
            return false;
        }
        People people= (People) object;

        if (this.name.equals(people.name)&&this.age==people.age){
            return true;
        }
        else {
            return false;
        }
    }
    public int hashCode(){
        return this.name.hashCode()*this.age;
    }
}
```

从输出情况看到没有完全重复的对象了



### `hashCode()`

- 总的来说，Java中的集合（Collection）有两类，**一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。**这里就引出一个问题：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？
  
- 这就是`Object.equals`方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。   
  
- 于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上，**初学者可以简单理解，`hashCode`方法实际上返回的就是对象存储的物理地址（实际可能并不是）**。  
  
- 这样一来，当集合要添加新的元素时，先调用这个元素的`hashCode`方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。
-  简而言之，在集合查找时，**`hashcode`能大大降低对象比较次数，提高查找效率！** 这里有可能会发生hash冲突，`hashcode`相同时，会比较两个对象是否相同，也就是说，会调用`A.equals(B)`，如果不等于，新元素会放在hash桶中，旧元素则是新元素链表的next元素



## `SortedSet`

此接口主要是用于排序的，`TreeSet`类流实现了这个接口，这个接口也继承了Set接口

```java
    public static void main(String[] args) {
       TreeSet<String> set=new TreeSet<>();
       set.add("B");
       set.add("A");
       set.add("D");
       set.add("C");
       set.add("E");
        System.out.println(set);
        //返回第一个元素
        System.out.println("第一个元素："+set.first());
        
        //返回最后一个元素
        System.out.println("最后一个元素："+set.last());
        
        //返回C之前的元素，不包括C
        System.out.println("headSet->C："+set.headSet("C"));
        
        //返回C之后的元素，包括C
        System.out.println("tailSet->C："+set.tailSet("C"));
        
        //C和E之间的元素，包括C,不包括E
        System.out.println("subSet->C-E："+ set.subSet("C","E"));
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191129193628281.png)

# 集合的输出

在之前进行集合输出的时候都利用了`toString()`，或者利用了List接口中的get()方法。这些都不是集合的标准输出。如果从标准上来讲，集合输出一共有四种手段：`Iterator`、`ListIterator`、`Enumeration`、`foreach`。 

最常用的还是`Iterator`迭代输出

```java
public interface Iterator<E> {
    //方法一
boolean hasNext();
    //方法二
next();
    //方法三
default void remove() {
        throw new UnsupportedOperationException("remove");
   }
}
```

## 迭代输出

Iterator接口也是Java集合框架的成员，但它与Collection系列、Map系列的集合不一样：Collection系列集合、Map系列集合主要用于盛装其他对象，而**Iterator则主要用于遍历（即迭代访问）Collection集合中的元素，Iterator对象也被称为迭代器。**

**迭代器的用途 : 迭代器一般会用在遍历集合上面。** 

对于Iterator接口里面实际有三个抽象方法：

- 判断是否有下一个元素：`public boolean hasNext()`

- 取得当前元素：`public E next()`
- 删除元素：`public default void remove()`

>
>
>1. **`hasNext`:没有指针下移操作，只是判断是否存在下一个元素**
>2. **`next`：指针下移，返回该指针所指向的元素**
>3. **`remove`：删除当前指针所指向的元素，一般和next方法一起用，这时候的作用就是删除next方法返回的元素**

**测试：**

 标准的Iterator使用 

```java
 public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");
        list.add("hello");
        list.add("Java");
        //通过list里的方法:Iterator<E> iterator()实例化迭代器接口
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String str = iterator.next();
            System.out.println(str);
        }
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191129194851836.png)

 删除元素 

```java
 public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("world");
        list.add("Hi");
        list.add("Man");
        Iterator<String> iterator = list.iterator();
     //如果下一个元素存在
        while (iterator.hasNext()){
            //指针下移并取出元素
            String str = iterator.next();
            if (str.equals("Hi")){
                //使用Iterator的remove（）方法不会产生异常
                iterator.remove();
                continue;
            }
            System.out.println(str);
        }
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191129195930943.png)

错误的删除方式

```java
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");
        list.add("hello");
        list.add("Java");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String str = iterator.next();
            if(str.equals("Hello")) {
                 //使用集合提供的remove()方法，则会产生ConcurrentModificationException
                 list.remove("Hello");
                // 使用Iterator的remove()方法则不会产生异常
                //iterator.remove();
                continue;
            }
            System.out.println(str);
        }
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191129201229882.png)

报错原因：在`ArrayList`的源码中有一个参数`modCount`表示集合的修改次数，每一次修改集合`modCount`的值就会+1；遍历集合时会将`modCount`的值传给Iterator，在遍历时修改元素，则`modCount`的值就会发生变化，那么`modCoun`t的值就会与原本在Iterator中的值不一致，就会出现异常。其存在的目的是：多线程下保证数据的安全性。**因此，在今后的使用中无论如何也不要在集合输出时修改集合元素。**

**修改：改为删除hello**

```
 if(str.equals("hello")) {
                 //使用集合提供的remove()方法，则会产生ConcurrentModificationException
                 list.remove("hello");
                // 使用Iterator的remove()方法则不会产生异常
                //iterator.remove();
                continue;
            }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191129202021622.png)

从程序的运行来看，内容确实被删了，但是迭代输出在内容删除之后就终止了，还是一样的原因，因为集合本身的内容被破坏了，所以迭代将出现错误停止输出

##  迭代器原理 

1. 当创建完成指向某个集合或者容器的Iterator对象是，这的指针其实指向的是第一个元素的上方，即指向一个 空
2. 当调用`hasNext`方法的时候，只是判断下一个元素的有无，并不移动指针
3. 当调用`next`方法的时候，向下移动指针，并且返回指针指向的元素，如果指针指向的内存中没有元素，会报异常。
4. `remove`方法删除的元素是指针指向的元素。如果当前指针指向的内存中没有元素，那么会抛出异常。

## 双向迭代输出

 Iterator接口的主要功能是由前向后进行内容的迭代处理，而如果要想进行双向迭代，那么就必须依靠Iterator的子接口：`ListIterator`来实现。 

` ListIterator`接口的使用 

```java
    public static void main(String[] args) {
    List<String> list = new ArrayList<>();
    list.add("Hello");
    list.add("World");
    list.add("hello");
    list.add("Java");
    ListIterator<String> listIterator = list.listIterator();
    System.out.print("从前往后输出: ");
    while (listIterator.hasNext()) {
        System.out.print(listIterator.next()+"、 ");
    }
    System.out.print("\n从后往前输出: ");
    while (listIterator.hasPrevious()) {
        System.out.print(listIterator.previous()+"、 ");
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112920290998.png)

**弊端：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191129203105301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

**如果要想实现由后向前的输出，那么应该首先进行从前向后的输出，否则无法实现双向。** 

##  **`foreach`输出** 

```java
public class Test {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");
        list.add("hello");
        list.add("Java");
        for (String string : list) {
            System.out.println(string);
        }
    }
}
输出：
Hello
World
hello
Java
```

##  Enumeration输出 

```java
public class Test {
    public static void main(String[] args) {
        //只能使用Vector(向量)
        Vector<String> vector = new Vector<>();
        vector.add("Hello");
        vector.add("World");
        vector.add("hello");
        vector.add("Java");
        Enumeration<String> enumeration = vector.elements();
        //判断是否有下一个值
        while (enumeration.hasMoreElements()) {
            //取出当前元素
            System.out.println(enumeration.nextElement());
        }
    }
}
输出：
Hello
World
hello
Java
```

