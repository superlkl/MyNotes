# 基础问题

## 主方法中`args`是什么意思 

`String[] args `：是保存运行main函数时输入的参数的字符串数组，当在`cmd`运行 时，输入：` java 主函数类名 a b c`，数组就会将`abc`保存起来： `args[0] = a; args[1] = b; args[2] = c`;这些变量在程序中是可以调用的 

## &和&&的区别 

1. &和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式 的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。   

2. &&还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式， 例如，对于`if(str != null && !str.equals(“”))`表达式，当`str`为null时，后面的表达式不 会执行，所 以不会出现 `NullPointerException` 如果 将 && 改为&，则会抛 出 `NullPointerException`异常。If(x==33 & ++y>0) y会增长，If(x==33 && ++y>0)不会 增长。 

3. &还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位 与操作，我们通常使用` 0x0f `来与一个整数进行&运算，来获取该整数的最低 4 个 bit 位， 例如，`0x01 & 0x0f`的结果为`0x01`

## ==运算符 

==的用法，它属于比较运算符，结果是boolean类型的，如果是基本数据类型，比 较的是==两边的值，如果是引用数据类型，比较的是引用变量指向的那个地址值。另外对 于字符串要用双引号引起来，如果是比较字符串的内容是否相同就用equals方法 

## switch问题 

switch 语句在` JDK1.5 `之前只支持四种数值的判断，分别为：byte，short，int 和 char，`JDK1.5 `开始支持对枚举类型变量的判断，`JDK1.7 `开始支持对 String 类型变量的判 断。switch中case的常量表达式要和switch后面的表达式类型一致 

## 实例变量和类变量 

1. 类变量也叫静态变量，也就是在变量前加了 static 的变量，类变量在创建对象前 就已经在内存中存在，随类的创建而创建；实例变量也叫对象变量，即没加static 的变量。 
2. 类变量是所有对象共有，其中一个对象将它值改变，其他对象得到的就是改变后的结果；
    而实例变量则属对象私有，某一个对象将其值改变，不影响其他对象。 
3. 所有的实例对象都共用一个类变量，内存中只有一处空间是放这个类变量值的。因此， 如果一个对象把类变量值改了，另外一个对象再取类变量值就是改过之后的了。在创建实例 对象的时候，内存中会为每一个实例对象的每一个非静态成员变量开辟一段内存空间，用来 存储这个对象所有的非静态成员变量值，即使两个不同的实例对象是属于同一个 class 类， 但是它们的同名非静态成员变量在内存中占用的空间是不同的

## 三元运算 

- `int x=8,y; y=(x>5)?100：200`; 代码y参与运算，而没有初始化变量y的值，会报错。只需要在初始化y=0即可。 
- `int x=8,y; (x>5)?y=100：y=200`; 代码  (x>5)，先进行比较运算，然后给y赋值。 
- 要点：变量初始化的时候需要赋值才能参与运算

## 两种创建数组的内存情况 

```java
class Practise  {        
public static void main(String[] args)  {            
int [] arr = new int[]{3,1,6,8,2,5};             
int [] arr1 ={3,1,6,8,2,5};             
System.out.println(arr.equals(arr1));//结果false

String[] aa=new String[]{"aa","bb","cc"}; 
String[] bb={"aa","bb","cc"};           
    System.out.println(aa.equals(bb));//结果 false 
    
String a="abc";            
String b=new String("abc");             
String c=new String("abc");           
System.out.println(a==b);//结果false           
System.out.println(a.equals(b));//结果 true            System.out.println(b.equals(c));//结果 true            System.out.println(a.equals(c));//结果 true 
    }    
} 
```

实验证明，String类是一个特殊的类，`String b=new String("abc")`;在堆内存中重新开辟 一块空间；虚拟机先查找有没有"`abc`"这个实体，有，则a直接指向实体，没有，则重新创 建实体。而其他类即使是字符类型的数组也没有区别，仅仅是写法上的不同。 

## String创建对象的内存问题 

```java
class StringDemo {           
public static void main(String[] args)  {              
String s1="abc";               
String s2=new String("abc");
//比较的是s1 和s2的内存地址值，它们两个分别在内存里面各自对应一个内存地址， 所以它们相比的结果是False
System.out.println(s1==s2);
//个比较的是两个对象的字符串是否相同，因为 String 类对象覆写了 Object 类中的 equals方法。所以它们相比的结果是true
System.out.println(s1.equals(s2)); 
```

## For和while的区别 

while的执行体和跌代体在一起，如果执行体后面加上continue 后面的跌代体执行 不到；for的执行体和跌代替分离，执行体后面加continue  跌代体还是是会执行。for里 面除了两个分号不能省略之外其余都可以省略！ 

## 垃圾回收机制 

Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收 可以有效的防止内存泄露，有效的使用可以使用的内存。

垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进 行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回 收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。 某个对象不在使用Demo d = new Demo（） 

当d不用的时就让d = null；如此一 来就会让垃圾回收器来主动回收。 

## ==与equals的区别 

==和equals都是比较的,而前者是运算符,后者则是一个方法,基本数据类型和引用数据类型都可以使用运算符==,而只有引用类型数据才可以使用 equals

## 堆内存与栈内存的区别 

- `heep` （堆）是一个可动态申请的内存空间，一般所有创建的对象都放在这里。 stack （栈）是一个先进后出的数据结构，通常用于保存方法(函数)中的参数,局部变量。 stack （栈）的空间小，但速度比较快， 存放对象的引用，通过栈中的地址索引可以找到 堆中的对象。 
- 栈（`java stacks`）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是` java` 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈用于存储局部变量表、操 作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个 栈帧在虚拟机栈中从入栈到出栈的过程。              
- 堆（`java Heap`）是 `java`虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的 一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有 的对象实例都在这里分配内存。

## 变量不赋值与赋null的区别 

在内存中只有赋值了才初始化变量，**全局变量自动赋予初始值，局部变量必须手动赋 值** ，最好全部都手动赋值，自动赋值赋的也是0或者 null。内存空间如果赋值null ，就是 进行了初始化。 

## 可变参数为什么要定义在参数列表的后面 

```java
void  add(int a )       
void  add(int a, int b)       
void  add (int a,int b,int c) 
```

比如这里的 add 方法就是向集合中添加元素的方法，我们发现这样的重载会使得代码 很臃肿，而且复用性也不是很高。     

在之前的 `java `版本中是这样设计的：void  add（int[]  a） ，就是将接受到的参数类型 变成一个数组，在方法中对数组进行遍历，这样数组中有几个元素，就添加几个元素，从而 就简化了程序。后来出现了可变参数了，就可以将上边的代码写为：public void add(int ...is){}，虽然形式上发生了改变，但其内部的调用方式是没有变化的，也就是将接 受来个数不确定的参数，装在一个数组中，而且从 int...开始后所有的参数，就会作为数组 中的元素装进数组中。

当然有的时候，参数中包含其他参数和可变参数，比如：public void add(String a,int ...is){}：那么从int...开始之后的参数就是可变参数，而a这个参数就不装 入到数组中了。那么，如果写成public void add（int ...is，String a){} ：根据调用的规则， a也会作为一个参数添加到数组中去，这当然与我们的程序设计初衷是不相符的。所以，在 使用可变参数的时候，要将可变参数定义在参数列表的最后面。

## 绝对路径和相对路径的区别 

- 相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关 系。使用相对路径可以为带来非常多的便利，为什么要安装`JDK`时候定义环境变量？就是 因为要简化书写。可以指定默认的路径，这就跟导入import包是一样的，new对象时候要 把包名也写上，但是你import导入之后可以不用书写包名，相对路径也是一样的。     
- 绝对路径就是指在平时使用计算机时要找到需要的文件就必须知道文件的位置，而表示 文件的位置的方式就是路径。例如，只要看到这个路径："`D：\图片\XXX.jpg`"我们就知道 "`XXX.jpg`"文件是在D盘的"图片"目录中。类似于这样完整的描述文件位置的路径就是绝对路径

## 创建对象时，内存问题 

```java
class test{}       
main{            
test t = new test();       
} 
```

- 开辟了栈内存空间，有一个变量t，存放堆内存地址new test(); 
- class test{}; 中包含一个空的构造方法，以及其从Object类中继承的所有东西，会分配内存。如果对new出来的东西一直没有释放掉对它的引用，`java`的垃圾收集机制无法对其 进行回收的，当创建的对象足够多时，会内存溢出

## Null属于什么类型 

- Java中4个系统定义的常量：`NaN`非数值、`lnf`无穷大、`-lnf`负无穷大、`null`空。 
- null用来标识一个不确定的对象，可以赋给引用型变量，不可以赋给基本类型变量 
- Object是已知的存在所有类的超类,但不包含不存在的类,也不包含null。基本数据类型不是类不包含在Object中

## 多态到底是什么 

多态是一种运行期的行为，不是编译期的行为

多态：父类型的引用可以指向子类型的对象。     

比如 Parent p = new Child();当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的该同名方法。如果想要调用子类中 有而父类中没有的方法，需要进行强制类型转换，如上面的例子中，将p转换为子类Child 类型的引用。因为当用父类的引用指向子类的对象，用父类引用调用方法时，找不到父类中存在的方法。这时候需要进行向下的类型转换，将父类引用转换为子类引用。

## 构造代码块和构造函数的区别 

- 作用：  构造函数是给特定的对象进行初始化的； 构造代码块是对所有对象 初始化。     
- 格式： 构造函数是：  类名{}。构造代码块：  {}     
- 执行顺序：   静态代码块------构造代码块--------->构造函数 

## 匿名内部类中对接口的方法为什么要加public 

对于接口当中常见的成员：而且这些成员都有固定的修饰符。①全局常量。public static final ②抽象方法。public abstract。由此得出结论，接口中的成员都是公共的权限，,都是public

## 静态内部类的作用 

- 静态内部类，就是定义在外部类的成员位置上，之所以用静态修饰，就是因为内部类中都是共享数据，没有特有数据，定义成静态的，就可以直接用类名访问，不用在堆内存中创建对象。比较节省空间。 
- 在进行代码程序测试的时候，如果在每一个Java源文件中都设置一个主方法(主方法 是某个应用程序的入口，必须具有)，会出现很多额外的代码。而且最主要的是这段主程序 的代码对于Java文件来说，只是一个形式，其本身并不需要这种主方法。但是该主方法又 必不可少。在这种情况下，就可以将主方法写入到静态内部类中，从而不用为每个Java源 文件都设置一个类似的主方法。这对于代码测试是非常有用，在一些中大型的应用程序开发 中，是一个常用的技术手段。 

## 匿名内部类 

匿名内部类：没有名字的内部类是一个匿名子类对象。

定义前提：内部类必须继承一 个类或者实现接口。

定义的格式：new 父类名&接口名(){ 定义子类成员或者覆盖父类方 法 }.方法。

使用场景：当函数的参数是接口类型引用时，如果接口中的方法不超过3个。 可以通过匿名内部类来完成参数的传递。在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内

## 两种单例模式的区别 

- 饿汉式：先初始化对象；类一加载就存在；Single类一进内存，就已经创建好对象。     
- 懒汉式：对象是方法被调用时才初始化，也叫做对象的延时加载；类一加载就为null （调用方法的时候才在内存中建立对象）；Single类进内存，对象还没有存在，只有调用方 法时才建立对象。 

## 继承中的构造方法 

在继承中，子类的构造函数都会默认访问父类的构造函数的。在子类的每一个构造函数中的第一行，都有一个隐士的语句super()，来调用父类与之参数相同的构造函数。如果 类的构造函数被手动指定，就必须在子类的构造函数的第一行中声明，去找设置的父类构造函数，否则编译无法通过

## 普通代码块、静态代码块、构造代码块区别  

- **普通代码块：**在方法或语句中出现的{}就称为普通代码块。普通代码块和一般的 语句执行顺序由他们在代码中出现的次序决定--“先出现先执行” 
- **构造代码块:**直接在类中定义且没有加static关键字的代码块称为{}构造代码块。构 造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先 于类构造函数
- **静态代码块：**在`java`中使用static关键字声明的代码块。静态块用于初始化类，为 类的属性初始化。每个静态代码块只会执行一次。由于`JVM`在加载类时会执行静态代码块， 所以静态代码块先于主方法执行。 

> 如果类中包含多个静态代码块，那么将按照"先定义的代码先执行，后定义的代码后执行"。
>
> 注意：
>
> 1 静态代码块不能存在于任何方法体内。
>
> 2 静态代码块不能直接访问静态实例变量 和实例方法，需要通过类的实例对象来访问

# 异常

## Throw和throws的区别 

- throws使用在**函数上**，后面跟的是**异常类**。可以跟多个，用逗号隔开。      

- throw使用在**函数内**，后面跟的是**异常对象**。 

## Java异常几种处理方式 

1. 捕获异常,自己处理

```java
public class A{      
try{         异常语句...   } 
catch(Exception e)
{      e.getMessage();//自己处理     } 
} 
```

2. throw出去,让别人处理

```java
public class A throws Exception{      异常语句... }
//throw出去,让他人处理 
```

## 为什么父类不抛异常，子类就不能抛异常 

将父类引用传入给方法A（没有抛异常），方法A使用父类引用。使用多态将子类对 象传递给A，如果子类抛出异常B，因为A方法没有过处理异常B，将会导致程序错误。 

