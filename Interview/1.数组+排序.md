# 数组

## 88.合并两个有序数组

- 给你两个有序整数数组 nums1和 nums2，请你将 nums2合并到 nums1 中*，*使 nums1成为一个有序数组
- 说明:

>- 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 
>- 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素

- 示例:


```java
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]
```

- 思路：

![image-20200525180858752](图片.assets/image-20200525180858752.png)

>- 指针从后往前指，若i1>i2则i1指针所指位置元素移动到cur指针位置，之后cur指针向前移动，反之i2指针移动到cur指针位置，之后cur指针向前移动
>- 会出现两种情况：第一种是i1指针已经指向索引为-1处但i2指针还在合法范围，这时将i2指针所指元素全都往上逐一移动结束即可；第二种是i2指针已经指向索引为-1处但i1指针还在合法范围，这时无需再做任何操作，数组已经有序，直接结束方法
>- 综合以上分析：只有在i2指针处于合法范围才需要继续移动元素和指针

- 解答：

```java
public class Solution88 {
    /**
     * 归并排序的思想
     * nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素
     * @param nums1 数组1
     * @param m 数组1的元素个数
     * @param nums2 数组2
     * @param n 数组2的元素个数
     */
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i1 = m-1; //指向num1数组中的最后一个元素
        int i2 = n-1; //指向num2数组中的最后一个元素
        int cur = nums1.length - 1; //指向num1数组中的最后一个可用位置

        while (i2 >= 0){ //将num2数组中的元素都移动到num1中
            if (i1 >= 0 && nums1[i1] > nums2[i2]){ //确保i1指针不越界的情况下所指元素大于i2指针所指
                nums1[cur--] = nums1[i1--]; //移动到cur指针所指位置
            }else { // i1 < 0 || nums1[i1] < nums2[i2] 的情况
                nums1[cur--] = nums2[i2--];
            }
        }
    }
}
```

## 75.颜色分类

- 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列
- 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色
- 注意:不能使用代码库中的排序函数来解决这道题
- 示例:

```java
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

- 思路

![image-20200525190022590](图片.assets/image-20200525190022590.png)

>- 遇到0就要往最左边移动，遇到2就要往最右边移动。遇到1则不一移动，那么当0和2都归为后1自然就在中间了
>- 红色指针遇到2就和最右边黄色指针指向的元素交换位置，之后黄色指针向前移动，注意，此时由于黄色指针交换过来元素可能还是2，所以红色指针不能立即往后移动
>- 红色指针遇到0就往和最左边的蓝色指针指向元素交换位置，之后蓝色指针和红色指针都往后移动
>- 红色指针遇到1时则只往前移动即可

- 边界条件的判断

![image-20200525191014022](图片.assets/image-20200525191014022.png)

>- 由图可以看出，当红色指针和黄色指针指向相同的时候并不能说明排序已经完成，必须要红色指针代表的索引大于黄色指针代表的索引才能让排序真正的结束

- 解答

```java
public class Solution75 {

    /**
     * 要求：仅使用常数空间的一趟扫描算法
     * 时间复杂度O(n),空间复杂度O(1)
     * @param nums 只有0,1,2的数组,对这些数进行原地排序
     */
    public void sortColors(int[] nums) {
        int i = 0; //用于扫描的指针
        int l = 0; //指向最左边未曾交换过的元素
        int r = nums.length - 1; //指向最右边未曾交换过的元素
        while (i <= r){
            int cur = nums[i]; //被i指针扫描到的元素
            if (cur == 0){
                swap(nums, i++,l++ ); //把0放到数组最左边并往下继续扫描
            }else if (cur == 1){
                i++; //1的位置不变
            }else {
                swap(nums,i,r--); //把2放在最右边并继续扫描交换过来的元素
            }
        }
    }

    //交换数组nums[i]和num[j]的值
    public void swap(int[] nums, int i ,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

# 排序

## 16.部分排序

- 给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。
- 示例：

```java
输入： [1,2,4,7,10,11,7,12,6,7,16,18,19]
输出： [3,9] //即将数组索引的3和9之间的元素排序就可使整个数组有序
```

- 提示：

```java
0 <= len(array) <= 1000000
```

- 思路

![image-20200526093841034](图片.assets/image-20200526093841034.png)

>- 初始化array[0]为最大值，从第二个数开始扫描，若大于最大值则更新max，若小于最大值则记录该元素的位置。直到整个数组扫描结束，得到最右边的逆序位置：r
>- 同理，初始化array[array.length-1]为最小值，从倒数第二个数开始扫描，若小于最小值则更新min，若大于最小值则记录该元素的位置。直到整个数组扫描结束，得到最左边的逆序位置：l
>- 【l,r】则是需要排序的区间
>- 实质：上图从左到右的逆序对有(5,4),(5,3),(5,2),(4,3),(4,2),(3,2)===>要找到其中和最大值匹配的最后一个逆序对，即(5,2)
>- 从右到左的逆序对有(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)===>要找到其中和最小值的最后一个逆序对，即(2,5)
>- 最终取2和5所在的位置索引即使是需要排序的区间范围

- 解答

```java
public int[] subSort(int[] array) {
       if(array.length == 0) return new int[]{-1,-1};
       int max = array[0]; //从左扫描到右寻找逆序对(正序：逐渐变大)
       int r = -1; //用来记录最右边的那个逆序对位置
        for (int i = 1; i < array.length; i++) {
            int scanned = array[i];
            if (scanned >= max){
                max = scanned;
            }else {
                r = i;
            }
        }
        if (r == -1) return new int[]{-1,-1}; //遍历一轮后无逆序对则提前结束

        int min = array[array.length - 1]; //从右扫描到左寻找逆序对(正序：逐渐变小)
        int l = -1; //用来记录最左边的那个逆序对位置
        for (int j = array.length - 2; j >= 0; j--) {
            int scanned = array[j];
            if (scanned <= min){
                min = scanned;
            }else {
                l = j;
            }
        }
        return new int[]{l,r};
    }
```

# 练习

## 1.两数之和

- 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
- 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
- 示例:

```java
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

- 思路

![image-20200527175439673](图片.assets/image-20200527175439673.png)

>- 遍历到2时需要找到目标值7的索引，那么就遍历剩下的数组中是否存在7

- 题解

```java
public class Solution1 {
    public int[] twoSum(int[] nums, int target) {
        if (nums == null) return null;
        for (int i = 0; i < nums.length; i++) {
            int aim = target - nums[i]; //需要找目标值aim的索引
            for (int j = i+1; j < nums.length; j++) {
                if (aim == nums[j]) return new int[]{i,j};
            }
        }
        return null;
    }
}
```

- 思路2

![image-20200527184907419](图片.assets/image-20200527184907419.png)

>- 遍历到2，目标值是7；遍历到7，目标值是2
>- map的key存放遍历到的值，value存放key对应的索引值
>- 遍历到2时，若map中有对应的索引则返回；若无对应的索引则将2存入；那么当遍历到7时一定能够在map中找到2

- 题解2

```java
public class Solution1 {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int aim = target - nums[i]; //需要找目标值aim的索引
            if (map.containsKey(aim)) {
                return new int[] { map.get(aim), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

## 977.有序数组的平方

- 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。

```java
示例 1：

输入：[-4,-1,0,3,10]
输出：[0,1,9,16,100]
示例 2：

输入：[-7,-3,2,3,11]
输出：[4,9,9,49,121]


提示：

1 <= A.length <= 10000
-10000 <= A[i] <= 10000
A 已按非递减顺序排序。
```

- 思路一：先给数组平方再排序
- 题解一：

```java
public class Solution977 {
    public int[] sortedSquares(int[] A) {
        if (A == null || A.length == 0) return null;
        int[] newA = new int[A.length];
        for (int i = 0; i < A.length; i++) {
            newA[i] = A[i] * A[i];
        }
        Arrays.sort(newA);
        return newA;
    }
}
```

- 思路二：

![image-20200528090500901](图片.assets/image-20200528090500901.png)

>- 情况一：全为正数，从前往后逐一平方即可
>- 情况二：全为负数，从后往前逐一平方即可
>- 情况二：有正有负数，找到第一非负数，用right指针指向，用left指向离right指针最近的负数
>- 在负数中，最大的负数平方后最小，依次比较left指向的负数的绝对值和right指向的绝对值的大小，把较小数平方后放到新数组里
>- 注意：考虑数组越界问题

- 题解二：

```java
public class Solution977 {
    public int[] sortedSquares(int[] A) {
        int[] sqrtA = new int[A.length];
        if (A[A.length - 1] < 0) { //全是单调递增的负数
            int right = A.length - 1;
            for (int i = 0; i < A.length; i++) {
                sqrtA[i] = A[right] * A[right];
                right--;
            }
        }else if (A[0] > 0) { //全是单调递增的正数
            for (int i = 0; i < A.length; i++) {
                sqrtA[i] = A[i] * A[i];
            }
        }else { //单调递增的正负数结合
            int right = 0;
            while (A[right] < 0){
                right++; //指向第一个非负数
            }
            int left = right - 1; 
         
            for (int i = 0; i < A.length; i++) {
                if (left < 0){ //左指针越界
                    sqrtA[i] = A[right] * A[right];
                    right++;
                }else if (right >= A.length){ //右指针越界
                    sqrtA[i] = A[left] * A[left];
                    left--;
                }else if (-A[left] <= A[right]){ //负数的绝对值和正数比较大小
                    sqrtA[i] = A[left] * A[left];
                    left--;
                }else { 
                    sqrtA[i] = A[right] * A[right];
                    right++;
                }
            }
        }
        return sqrtA;
    }
}
```

## 495.提莫攻击

- 在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长
- 你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态
- 示例1:

```java
输入: [1,4], 2
输出: 4
原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。
第 4 秒初，提莫再次攻击艾希，使得艾希获得另外 2 秒中毒时间。
所以最终输出 4 秒。
```

- 示例2:

```java
输入: [1,2], 2
输出: 3
原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。
但是第 2 秒初，提莫再次攻击了已经处于中毒状态的艾希。
由于中毒状态不可叠加，提莫在第 2 秒初的这次攻击会在第 3 秒末结束。
所以最终输出 3 。
```

- 提示：

>- 你可以假定时间序列数组的总长度不超过 10000
>- 你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过 10,000,000

- 思路

![image-20200602174617761](图片.assets/image-20200602174617761.png)

>- 当攻击的间隔时间大于或等于中毒的时间，那么在下一次攻击的时候就直接叠加中毒时间
>- 当攻击的间隔时间小于中毒时间，如11s,12s,13s，在12s攻击会刷新中毒时间，在13s攻击又会刷新中毒时间；在11s攻击必中毒1s，刷新时间，在12s攻击必中毒1s，刷新时间，在13s攻击必中毒2s，攻击结束

- 题解

```java
public class Solution495 {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        if (timeSeries == null || timeSeries.length == 0) return 0;
        if (timeSeries.length == 1) return duration;
        int totalPoisoned = 0;
        int interval = 0;
        for (int i = 1; i < timeSeries.length; i++) {
            interval = timeSeries[i] - timeSeries[i - 1];
            if (interval >= duration) { //每次攻击的间隔时间大于中毒时间
                totalPoisoned += duration;
            } else { //攻击的间隔时间小于中毒时间
                totalPoisoned = interval + totalPoisoned;
            }
        }
        totalPoisoned += duration; //最后一次攻击
        return totalPoisoned;
    }
}
```

