# 1.两数之和（简单）

- 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

- 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

```java
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

## 自己思路

```java
class Solution {
     public int[] twoSum(int[] nums, int target) {
        //用来存放返回的数组索引
        int[] index=new int[2];
         //target是减第一个数和第二个数比较判断，所以只用减到倒数第二个数再和最后一个数判断
        for (int begin = 0; begin < nums.length-1; begin++) {
            //target减第一个数和第二个数比较，最差需要比较到最后一个数
            for (int after = begin+1; after < nums.length; after++) {
                //相减判等:1,2 / 1,3 ...
                if (target-nums[begin]==nums[after]){
                    index[0]=begin;
                    index[1]=after;
                    return index;
                }
            }
        }
        return null;
    }
}
```

# 2.两数相加（中等）

- 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

- 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

- 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```java
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

# 7.整数反转（简单）

- 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

```java
输入: 123
输出: 321

输入: -123
输出: -321

输入: 120
输出: 21
```

## 官方题解

- 最大的值与最小的值为：[−2^31, 2^31 − 1]， 即：[-2147483648, 2147483647]

- 如果y = y * 10 + x % 10溢出，则 y>=214748364 ，

- 当y=214748364时，输入的值只能为：1463847412，此时不溢出

- 即：y > 214748364 || y < -214748364 必定溢出

```java
//难点：数据反转之后可能会超过最大整数的取值范围导致溢出
public int reverse(int x) {
    //最后反转的整数
    int y = 0;
    while (x != 0) {
        //超过整数范围少一位直接返回0
        if (y > 214748364 || y < -214748364) {
            return 0;
        }
        //x==123,1.y=0*10+3 2.y=3*10+2 3.y=32*10+1
        y = y * 10 + x % 10;
        x = x / 10;
    }
    return y;
}
```

# 9.回文数（简单）

- 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

```java
输入: 121
输出: true

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

## 自己思路

```java
 public boolean isPalindrome(int x) {
     //只要小于0，一定不是回文数
        if (x<0) return false;
        List<Integer> list=new ArrayList<>();
     //把数字一个一个的取出来添加进数组里面
        while (x!=0){
            list.add(x%10);
            x=x/10;
        }
        //比较次数：3个数比较1次 4个数比较两次...
        int size=list.size();
        for (int i = 0; i < (size>>1); i++) {
            //第1个和最后一个比较，第2个和倒数第二个比较
            if (!list.get(i).equals(list.get(size-1-i))) return false;
        }
        return true;
    }
```

## 自我改进

```java
 public boolean isPalindrome(int x) {
        if (x<0) return false;
     //接收反转整数
        int y=0;
        int temp=x;
     //回文数若反转之后一定还是相同的数字
        while (temp!=0){
            //1,12 12,1 121
            y=y*10+temp%10;
            temp=temp/10;
        }
        return y == x;
    }
```

# 13.罗马数字转为整数（简单）

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

```java
   字符          数值
    I             1
    V             5
    X             10
    L             50
    C             100
    D             500
    M             1000
```

- 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 ` XXVII`, 即为 `XX + V + II` 。

- 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做` IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
  - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
  - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
  - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

- 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

```java
输入: "III"
输出: 3

输入: "IV"
输出: 4

输入: "IX"
输出: 9

输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

## 官方题解

- 首先将所有的组合可能性列出并添加到哈希表中
- 然后对字符串进行遍历，由于组合只有两种，一种是 1 个字符，一种是 2 个字符，其中 2 个字符优先于 1 个字符
- 先判断两个字符的组合在哈希表中是否存在，存在则将值取出加到结果 ans 中，并向后移2个字符。不存在则将判断当前 1 个字符是否存在，存在则将值取出加到结果 ans 中，并向后移 1 个字符
- 遍历结束返回结果 ans

```java
public int romanToInt(String s) {
    //用哈希表存储是最好的方式
    Map<String, Integer> map = new HashMap<>();
    //对应各自的键值对
    map.put("I", 1);
    map.put("IV", 4);
    map.put("V", 5);
    map.put("IX", 9);
    map.put("X", 10);
    map.put("XL", 40);
    map.put("L", 50);
    map.put("XC", 90);
    map.put("C", 100);
    map.put("CD", 400);
    map.put("D", 500);
    map.put("CM", 900);
    map.put("M", 1000);

    int ans = 0;
    for(int i = 0;i < s.length();) {
        if(i + 1 < s.length() && map.containsKey(s.substring(i, i+2))) {
            ans += map.get(s.substring(i, i+2));
            i += 2;
        } else {
            ans += map.get(s.substring(i, i+1));
            i ++;
        }
    }
    return ans;
}
```

# 26.删除排序数组中的重复项

- 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
- 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

```java
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```

## 官方题解

- 数组完成排序后，我们可以放置两个指针 slow 和 fast，其中 slow 是慢指针，而 fast 是快指针。只要 nums[slow] == nums[fast]，我们就增加 fast 以跳过重复项。
- 当我们遇到 nums[fast] != nums[slow ] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[fast]）的值复制到 nums[slow  + 1]。然后递增 slow ，接着我们将再次重复相同的过程，直到 fast 到达数组的末尾为止。

```java
public int removeDuplicates(int[] nums) {
            //先检查数组是否为空
            if (nums.length==0) return 0;
            //慢指针
            int slow=0;
            //快指针
            int fast=1;
            
            for ( ; fast<nums.length ; ) {
                //如果相等快指针后移一位
                if (nums[slow]==nums[fast]){
                    fast++;
                }
                else {
                    //如果不相等，nums[fast]赋值给慢指针的下一位
                    nums[++slow]=nums[fast];
                }
            }
            //返回有序无重复数组的长度
            return slow+1;
    }
```

## 改用while循环

```java
public int removeDuplicates(int[] nums) {
    if(nums == null || nums.length == 0) return 0;
    int p = 0;
    int q = 1;
    while(q < nums.length){
        if(nums[p] != nums[q]){
            nums[++p] = nums[q];
        }
        //如果相等快指针就向后移一位
        q++;
    }
    return p + 1;
}
```

# 27.移除元素

- 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
- 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

- 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```java
示例 1:
给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。

示例 2:
给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
```

## 官方题解

```java
   public int removeElement(int[] nums, int val) {
       //慢指针标记可以插入的位置
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            //一旦等于目标值快指针就跳过
            //不等于目标值就插入到合适的位置
            if (nums[j] != val) {
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
    }
```

## while循环的方式

```java
  public int removeElement(int[] nums, int val) {
        int slow=0;
        int fast=0;
        while (fast<nums.length){
            if (nums[fast]!=val){
                nums[slow++]=nums[fast];
            }
            fast++;
        }
        return slow;
    }
```

# 35.搜索插入位置

- 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

- 你可以假设数组中无重复元素。

```java
输入: [1,3,5,6], 5
输出: 2

输入: [1,3,5,6], 2
输出: 1

输入: [1,3,5,6], 7
输出: 4

输入: [1,3,5,6], 0
输出: 0
```

## 自己思路

```java
 public int searchInsert(int[] nums, int target) {

        for (int begin = 0; begin < nums.length; begin++) {
            //遍历如果大于等于目标值，就返回索引
            if (nums[begin]>=target) return begin;
        }
        //默认返回最后一位
        return nums.length;
    }
```

## 二分查找算法优化

```java
 public int searchInsert(int[] nums, int target) {
        //左右边界[0,nums.length)
        int left=0;
        int right=nums.length;
        while (left<right){

            int mid=(left+right)>>1;

            if (target<nums[mid]){
                right=mid;
            }else if (target>nums[mid]){
                left=mid+1;
            }
            else {
                return mid;
            }
        }
        //当左右边界索引相同时退出
        return left;
    }
```

## 官方题解

```java
 public int searchInsert(int[] nums, int target) {
       //[0,nums.length - 1]
        int left = 0, right = nums.length - 1; 
        while(left <= right) { // 注意
            int mid = (left + right) >> 1; 
            if(nums[mid] == target) { 
                // 相关逻辑
            } else if(nums[mid] < target) {
                left = mid + 1; 
            } else {
                right = mid - 1; 
            }
        }
        // 相关返回值
        return left;
    } 
```

# 4.寻找有序数组的中位数

- 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

- 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

- 你可以假设 nums1 和 nums2 不会同时为空。

```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

## 简单思路

先将两个数组合并，两个有序数组的合并也是归并排序中的一部分。然后根据奇数，还是偶数，返回中位数。

```java
 public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        //其中一个数组为空
        int size1=nums1.length;
        int size2=nums2.length;
        if (size1==0){
            return midNumber(nums2);
        }
        if (size2==0) {
            return midNumber(nums1);
        }
        //两个数组都不为空
        //先创建一个新的数组
        int[] newArray=new int[size1+size2];
        //两个指针分别指向两个数组
        int index1=0;
        int index2=0;
        //统计新数组的实际使用空间
        int count=0;
        //一直执行,直到把两个数组都按从小到大的顺序移动到新数组里
        while (count!=newArray.length){
            //如果数组1先移动结束
            if (index1==size1){
                //那么就把数组2的元素按顺序移动到新数组
                while (index2!=size2){
                    newArray[count++]=nums2[index2++];
                }
                //移动结束新数组就满了，直接退出
                break;
            }
            //同上
            if (index2==size2){
                while (index1!=size1){
                    newArray[count++]=nums1[index1++];
                }
                break;
            }
            //两个数组都没有结束的情况下需要按顺序比较大小
            if (nums1[index1]<nums2[index2]){
                newArray[count++]=nums1[index1++];
            }else {
                newArray[count++]=nums2[index2++];
            }
        }
        //返回新数组的中位数
        return midNumber(newArray);
    }

    //给我一个数组，给你返回它的中位数
    private double midNumber(int[] array){
        int size=array.length;
        //先除以2得到中间索引
        int index=size>>1;
        //如果数组长度为偶数
        if (size%2==0){
            return (array[index]+array[index-1])/2.0;
        }else {
            //如果为奇数直接返回中间值
            return array[index];
        }
    }
```

# 11.盛水最多的容器

- 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

- 说明：你不能倾斜容器，且 n 的值至少为 2。

```
输入: [1,8,6,2,5,4,8,3,7]
输出: 49
```

## 官方题解

- **算法流程：** 设置双指针 i*i*,j*j* 分别位于容器壁两端，根据规则移动指针（后续说明），并且更新面积最大值 `res`，直到 `i == j` 时返回 `res`。

- **指针移动规则与证明：** 每次选定围成水槽两板高度 h[i],h[j]中的短板，向中间收窄 1 格。

![img](https://pic.leetcode-cn.com/a2a97349454ee3657a8a3d9db0399921894c7f581c2e9540d0e2c3df122fec95-Picture1.png)

![img](https://pic.leetcode-cn.com/239c53727f392398829ae835df2d4b8dce374954b2aac2e3745b3ff9c32d7a9f-Picture2.png)

```java
public int maxArea(int[] height) {
        int i = 0, j = height.length - 1, capacity = 0;
        while(i < j){
            capacity = height[i] < height[j] ?
                    Math.max(capacity, (j - i) * height[i++]):
                    Math.max(capacity, (j - i) * height[j--]);
        }
        return capacity;
    }
```

# 242.有效的字母异位词

- 给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。

```java
输入: s = "anagram", t = "nagaram"
输出: true

输入: s = "rat", t = "car"
输出: false
```

## 官方题解

```java
 public boolean isAnagram(String s, String t) {
        //如果长度都不等，一定为false
       if (s.length()!=t.length()) return false;
       //先转换为字符数组
        char[] chars1=s.toCharArray();
        char[] chars2=t.toCharArray();
        //对字符进行排序
        Arrays.sort(chars1);
        Arrays.sort(chars2);
        //判断两排序数组是否相等
        return Arrays.equals(chars1,chars2);
    }
```

## 优化改进

![img](https://pic.leetcode-cn.com/f52b9bdf8920058f3194706b2f9c7fce1cbcc31842e1a5662e67d3a879afbafa-frame_00001.png)

![img](https://pic.leetcode-cn.com/72de54cca80efa6b315fd49f0feef6b83ed45e82632d049c5c87de2bd74ad4b6-frame_00002.png)

```java
  public boolean isAnagram(String s, String t) {
        //如果长度不等，直接false
        if(s.length() != t.length()) return false;
        
        //创建一个装载26个单词的字母表
        int[] alphabet = new int[26];
        //s和t长度相等，遍历哪个都可以
        for(int i = 0; i< s.length(); i++) {
            //相当于计数排序，一边统计每个s中每个单词出现的次数
            //一边减少t中每个单词出现的次数
            alphabet[s.charAt(i) - 'a'] ++;
            alphabet[t.charAt(i) - 'a'] --;
        }
        //如果相等，一减一增最后必然为0
        for(int i=0;i<26;i++)
            if(alphabet[i] != 0)
                return false;
        return true;
    }
```

# 179.最大数（中等）

给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。

```text
输入: [10,2]
输出: 210

输入: [3,30,34,5,9]
输出: 9534330

输入: [0,0]
输出: 0
```

**说明:** 输出结果可能非常大，所以你需要返回一个字符串而不是整数。

## 官方题解

```java
private static class LargerNumberComparator implements Comparator<String>{
        @Override
        public int compare(String a, String b) {
            //每一对数在排序的比较过程中，我们比较两种连接顺序哪一种更好
            String order1=a + b;
            String order2=b + a;
            return order2.compareTo(order1);
        }
    }
    public String largestNumber(int[] nums){
        //把数组里的数字转换为字符串
        String[] strings=new String[nums.length];
        for (int begin = 0; begin < nums.length; begin++) {
            strings[begin]=String.valueOf(nums[begin]);
        }
        //传入比较器，根据自己设定的比较方法进行排序
        Arrays.sort(strings,new LargerNumberComparator());

        //一旦数组排好了序，最“重要”的数字会在最前面。有一个需要注意的情况是如果数组只包含 0 ，我们直接返回结果 00 即可。否则，我们用排好序的数组形成一个字符串并返回。
        if (strings[0].equals("0")) return "0";

        StringBuilder largestNumberStr= new StringBuilder();
        for (String numAsStr : strings){
            largestNumberStr.append(numAsStr);
        }
        return largestNumberStr.toString();
    }
```



