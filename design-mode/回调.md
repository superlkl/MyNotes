# 什么是回调

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmJzLmNzZG4ubmV0L3VwbG9hZC8yMDE5MDUvMjAvMTU1ODMzNTM1NV82NzczMTMucG5n)

**描述：**

1. 老板给员工下达了工作任务之后，就去做其他事情了。（此时此 刻，老板不知道需要多长时间完成，不
会一直等着，而是做自己其他事情）
2. 员工接收到任务之后，按照要求完成任务
3. 当员工任务完成的时候，主动的回馈给老板工作情况。
4. 当员工回馈工作情况的时候，此时此刻老板还在做另外的事情
  

# **回调的核心思想**

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmJzLmNzZG4ubmV0L3VwbG9hZC8yMDE5MDUvMjAvMTU1ODMzNTQxMF83NjgyNzIucG5n)

描述：

1. Boss类在“下达任务的方法”中调用 Employee类的“完成任务方法”
2. 当Employee类的“完成任务方法”执行完毕之后，会主动的调用老板Boss类的`callBack()`方法

# **案例代码实现**

**回调的接口 CallBack**

```java
/**
 * 定义回调的接口,只需要定义一个报告反馈的方法即可
 */
public interface CallBack {
 // 定义一个报告 反馈的方法
 public void baoGao(int num);
}
```

**老板类 Boss**

```java
/***
 * 定义一个老板Boss类,需要去实现回调的接口 CallBack
 */
public class Boss implements CallBack {
 // 定义下达任务的方法.需要在下达任务的当中调用 员工 完成任务的方法
 public void xiaDaRenWu(Employee e) {
// 当下达任务的时候给出提示.等待着某位员工去完成任务
 System.out.println("Boss下达任务了,等待员工去完成...");
 // 员工去完成任务
 // 由于Boss实现了接口,可以将Boss的对象 this作为参数传递
 e.wanChengRenWu(this);
 }
 // 在报告的方法当中.需要去调用 员工信息
 @Override
 public void baoGao(int num) {
 System.out.println("员工报告回馈信息: " + num);
 }
}
```

**员工抽象类 Employee**

```java
/**
 * 员工类:由于不知道每个员工的完成方式,将员工定义为抽象
 */
public abstract class Employee {
 // 员工当中完成任务的操作
 public abstract void wanChengRenWu(CallBack callBack);
}
```

**具体员工类 KoBe**

```java
/**
 * 定义具体的员工类KoBe.完成员工任务的操作
 */
public class KoBe extends Employee {
 @Override
 public void wanChengRenWu(CallBack callBack) {
 // 模拟完成工作的情况。需要消耗一定的时间
 try {
 Thread.sleep(4000);
 } catch (InterruptedException e) {
 e.printStackTrace();
 }
 // 回调操作,反馈给领导情况
 callBack.baoGao(666);
 }
}
```

**测试类 Test**

```java
/***
 * 定义测试类完成 测试.创建老板Boss的对象以及 员工对象
 */
public class Test {
 public static void main(String[] args) {
 // 老板的对象
 Boss b = new Boss();
 // 具体员工的对象
 KoBe k = new KoBe();
 // 老板下达任务
 b.xiaDaRenWu(k);
 }
}
```

**最终运行效果（“员工报告反馈信息”等4秒后 才会出现）**

Boss下达任务了,等待员工去完成...
员工报告回馈信息: 666

**总结起来，回调的核心就是 回调方将本身即this传递给调用方.这样调用方就可以在调用完毕之后告诉回调方它想要知道的信息。**

