# 一、转账演示事务

## 1.1搭建测试代码

- 账户持久层

```java
public interface IAccountDao {
    /**
     * @param name 根据名称查询账户信息
     * @return 如果结果集只有一个就返回，如果没有就返回null
     * 如何结果集有多个就抛异常
     */
    Account selectAccountByName(String name);
}
```

- 实现

```java
@Repository("accountDao")
public class AccountDaoImpl implements IAccountDao {
    @Autowired
    private QueryRunner runner;

    @Override
    public Account selectAccountByName(String name) {
        try {
            List<Account> accounts = runner.query("select * from account where name = ?",
                                                  new BeanListHandler<>(Account.class), name);
            if (accounts == null || accounts.size() == 0) return null;
            else if (accounts.size() == 1) return accounts.get(0);
            else throw new RuntimeException("结果集大于1");
        } catch (SQLException e) {
            throw new RuntimeException();
        }
    }
}

```

- 业务层

```java
public interface IAccountService {
    //更新账户信息
    void updateAccount(Account account);
    //转账功能
    void transfer(String sourceName,String targetName,Float money);

}
```

- 实现

```java
@Service("accountService")
public class AccountServiceImpl implements IAccountService {
    @Autowired
    IAccountDao accountDao;
    
    
    public void updateAccount(Account account) {
        accountDao.updateAccount(account);
    }
    
    @Override
    public void transfer(String sourceName, String targetName, Float money) {
        //1.根据名称查询转出账户
        Account source = accountDao.selectAccountByName(sourceName);
        //2.根据名称查询转入账户
        Account target = accountDao.selectAccountByName(targetName);
        //3.转出账户减钱
        source.setMoney(source.getMoney() - money);
        //4.转入账户加钱
        target.setMoney(target.getMoney() + money);
        //5.更新转出账户
        updateAccount(source);
        //6.更新转入账户
        updateAccount(target);
    }
}
```

- 测试类

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfiguration.class)
public class AccountTest {
    @Autowired
    private IAccountService service;
    
    @Test
    public void testTransfer(){
        service.transfer("张三", "李四",100f);
    }
}
```

## 1.2问题分析

- 当转账代码transfer中没有出现任何异常时转账正常进行
- 若在某一个环节出现问题，如下展示，那么就会出现转出账户转钱成功但转入账户转入失败

![image-20200715152442243](图片.assets/image-20200715152442243.png)

## 1.3添加事务操作

- 为了解决上面出现的问题：
- 需要使用ThreadLocal对象把Connection和当前线程绑定，从而使一个线程中只有一个能控制事务的对象
- 实质：在一个方法操作中保证使用的都是一个Connection连接对象

### 1.3.1获取连接的工具类

```java
package com.kl.util;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

@Component("utils") //将bean的id设置为utils并放入spring容器
public class ConnectionUtils {
    @Autowired //自动注入
    private DataSource dataSource;

    @Autowired
    private ThreadLocal<Connection> threadLocal;

    //获取当前线程上的连接
    public Connection getThreadConnection(){
        try {
            //1.先从ThreadLocal中获取
            Connection conn = threadLocal.get();
            if (conn == null){
                //2.若ThreadLocal中没有就从数据源中获取并保存到ThreadLocal
                conn = dataSource.getConnection();
                threadLocal.set(conn);
            }
            return conn;
        } catch (SQLException e) {
            throw new RuntimeException();
        }
    }

    //解除线程和连接的绑定
    public void removeConnection(){
        threadLocal.remove();
    }
}
```

### 1.3.2事务管理和线程解绑

- 包括开启事务，提交事务，回滚事务和释放连接

```java
package com.kl.util;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.sql.Connection;
import java.sql.SQLException;

@Component("manager") //将bean的id设置为manager并放入spring容器
public class TransactionManager {
    @Autowired //自动注入
    private ConnectionUtils utils;

    /**
     * 开启事务
     */
    public void startTransaction() {
        try {
            utils.getThreadConnection().setAutoCommit(false);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * 提交事务
     */
    public void commitTransaction() {
        try {
            utils.getThreadConnection().commit();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * 回滚事务
     */
    public void rollbackTransaction() {
        try {
            utils.getThreadConnection().rollback();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * 关闭连接,释放资源
     */
    public void release() {
        try {
            utils.getThreadConnection().close(); //连接被还回连接池中
            utils.removeConnection(); //解除连接与线程的绑定
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

### 1.3.3业务层和持久层代码控制

- AccountDaoImpl账户类：增加根据用户名查询账户的方法

```java
@Repository("accountDao")
public class AccountDaoImpl implements IAccountDao {
    @Autowired 
    private QueryRunner runner;

    @Autowired
    private ConnectionUtils utils;

    @Override
    public Account selectAccountByName(String name) {
        try {
            List<Account> accounts = runner.query(utils.getThreadConnection(),"select * from account where name = ?",
                    new BeanListHandler<>(Account.class), name);
            if (accounts == null || accounts.size() == 0) return null;
            else if (accounts.size() == 1) return accounts.get(0);
            else throw new RuntimeException("结果集大于1");
        } catch (SQLException e) {
            throw new RuntimeException();
        }
    }
    
    //......
}
```

- AccountServiceImpl

```java
Service("accountService") //放入spring容器
public class AccountServiceImpl implements IAccountService {
    @Autowired
    private IAccountDao accountDao;

    @Autowired
    private TransactionManager manager; //事务管理对象
    
     public void updateAccount(Account account) {
        try {
            //1.开启事务
            manager.startTransaction();
            //2.执行操作
            accountDao.updateAccount(account);
            //3.提交事务
            manager.commitTransaction();
            //4.返回结果
        } catch (Exception e) {
            //5.回滚操作
            manager.rollbackTransaction();
            e.printStackTrace();
        } finally {
            //6.释放资源
            manager.release();
        }
    }
    
    @Override
    public void transfer(String sourceName, String targetName, Float money) {
        try {
            //1.开启事务
            manager.startTransaction();

            //2.执行操作
            //2.1.根据名称查询转出账户
            Account source = accountDao.selectAccountByName(sourceName);
            //2.2.根据名称查询转入账户
            Account target = accountDao.selectAccountByName(targetName);
            //2.3.转出账户减钱
            source.setMoney(source.getMoney() - money);
            //2.4.转入账户加钱
            target.setMoney(target.getMoney() + money);
            //2.5.更新转出账户
            accountDao.updateAccount(source);
            int i = 1/0;
            //2.6.更新转入账户
            accountDao.updateAccount(target);

            //3.提交事务
            manager.commitTransaction();
            //4.返回结果
        } catch (Exception e) {
            //5.回滚操作
            manager.rollbackTransaction();
            throw new RuntimeException();
        } finally {
            //6.释放资源
            manager.release();
        }
    }
}
```

### 1.3.4srpingIOC配置

- 父配置类

```java
@Configuration //将该bean放入spring容器
@ComponentScan("com.kl") //告知要扫描的包
@Import(Config.class) //导入子配置文件
@PropertySource("classpath:jdbcConfig.properties") //配置文件路径
public class SpringConfiguration {

}
```

- 子配置类

```java
public class Config {
    @Value("${jdbc.driver}")
    private String driver;
    @Value("${jdbc.url}")
    private String jdbcUrl;
    @Value("${jdbc.user}")
    private String user;
    @Value("${jdbc.password}")
    private String password;

    @Bean(name = "runner")
    @Scope("prototype") //设置为多例模式
    public QueryRunner createQueryRunner(@Qualifier("ds1") DataSource source){
        return new QueryRunner(source);
    }

    @Bean(name = "ds1")
    public DataSource createDataSource(){
        try {
            ComboPooledDataSource dataSource = new ComboPooledDataSource();
            dataSource.setDriverClass(driver);
            dataSource.setJdbcUrl(jdbcUrl);
            dataSource.setUser(user);
            dataSource.setPassword(password);
            return dataSource;
        } catch (PropertyVetoException e) {
            throw new RuntimeException();
        }
    }

    @Bean(name = "threadLocal")
    public ThreadLocal<Connection> createThreadLocal(){
        return new ThreadLocal<>();
    }
}
```

- 配置文件jdbc.properties

```properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/eesy?serverTimezone=UTC
jdbc.user=root
jdbc.password=root
```

# 二、动态代理

![image-20200715195132718](图片.assets/image-20200715195132718.png)

- 动态代理：

>- 特点：字节码随用随创建，随用随加载
>- 作用：不修改源码的基础上对方法增强
>- 分类：
>  - 基于接口的动态代理
>  - 基于子类的动态代理

- 基于接口的动态代理：

>- 涉及的类：Proxy
>- 提供者：JDK官方

- 如何创建代理对象：使用Proxy类中的newProxyInstance方法
- 创建代理对象的要求：被代理类最少实现一个接口，如果没有则不能使用

---

- newProxyInstance方法的参数

![image-20200715200241026](图片.assets/image-20200715200241026.png)

- classLoader：类加载器
  - 它是用于加载代理对象字节码的，和被代理对象使用相同的类加载器 ------ (固定写法)
- Class[ ]：字节码数组
  - 它是用于让代理对象和被代理对象有相同方法 ------ (固定写法)
- InvocationHandler：用于提供增强的代码它是让我们写如何代理，我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的 ------ (此接口的实现类都是谁用谁写)

## 2.1基于接口的动态代理

- 接口

```java
//定义商家要求代理商的代理规范
public interface IProduce {
    //销售
    void saleProduce(Float money);

    //售后
    void afterService();
}
```

- 商家

```java
/**
 * 模拟生产者
 */
public class Produce implements IProduce {
    public void saleProduce(Float money) {
        System.out.println("商家卖了产品，收获"+money+"元");
    }

    public void afterService() {
        System.out.println("进入售后服务");
    }
}
```

- 消费者

```java
/**
 * 模拟消费者
 */
public class Consumer {
    public static void main(String[] args) {
        final Produce produce = new Produce();
        IProduce proxyProduce = (IProduce) Proxy.newProxyInstance(produce.getClass().getClassLoader(), produce.getClass().getInterfaces(), new InvocationHandler() {
            /**
             * 作用：执行被代理对象的任何接口方法都会经过该方法
             * @param o 代理对象的引用
             * @param method 当前执行的方法
             * @param objects 当前执行方法所需的参数
             * @return 和被代理对象方法有相同的返回值
             */
            public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
                //提供增强的代码
                Object returnValue = null;
                Float money = (Float) objects[0];
                //获取方法参数并判断是否是销售方法
                if ("saleProduce".equals(method.getName())){
                    returnValue = method.invoke(produce,money * 0.8f);
                }
                return returnValue;
            }
        });
        proxyProduce.saleProduce(1000f); //商家卖了产品，收获800.0元
    }
}
```

## 2.2基于子类的动态代理

- 想要代理普通的java类需要第三方jar包的支持
- 在pom.xml导入需要的jar包的坐标

```xml
<dependencies>
    <dependency>
        <groupId>cglib</groupId>
        <artifactId>cglib</artifactId>
        <version>2.1_3</version>
    </dependency>
</dependencies>
```

- 基于子类的动态代理：

>- 涉及的类：Enhancer
>- 提供者：第三方cglib库

- 如何创建代理对象：使用Enhancer类中的create方法
- 创建代理对象的要求：被代理类不能是最终类

---

- create方法的参数

![image-20200715222321115](图片.assets/image-20200715222321115.png)

- Class：字节码，它是用于指定被代理对象的字节码
- callback：用于提供增强的代码

>- 它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的
>- 此接口的实现类都是谁用谁写
>- 我们一般写的都是该接口的子接口实现类：MethodInterceptor

- 不需要接口的生产者

```java
/**
 * 模拟生产者
 */
public class Produce {
    public void saleProduce(Float money) {
        System.out.println("商家卖了产品，收获"+money+"元");
    }

    public void afterService() {
        System.out.println("进入售后服务");
    }
}
```

- 消费者测试

```java
/**
 * 模拟消费者
 */
public class Consumer {
    public static void main(String[] args) {
        final Produce produce = new Produce();
        Produce cglibProduce = (Produce) Enhancer.create(produce.getClass(), new MethodInterceptor() {
            /**
             * @param o 代理对象的引用
             * @param method 当前执行的方法
             * @param args 当前执行方法所需的参数
             * @param methodProxy 和被代理对象方法有相同的返回值
             */
            @Override
            public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                //提供增强的代码
                Object returnValue = null;
                Float money = (Float) args[0];
                //获取方法参数并判断是否是销售方法
                if ("saleProduce".equals(method.getName())){
                    returnValue = method.invoke(produce,money * 0.8f);
                }
                return returnValue;
            }
        });
        cglibProduce.saleProduce(1000f); //商家卖了产品，收获800.0元
    }
}
```

## 2.3动态代理实现事务控制

- 为IAccountService开启代理类，这样IAccountService被代理类中的所有方法都会经过代理对象

```java
package com.kl.factory;

import com.kl.service.IAccountService;
import com.kl.util.TransactionManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

@Component("beanFactory")
public class BeanFactory {
    @Autowired
    private IAccountService accountService;

    @Autowired
    private TransactionManager manager;

    @Bean(name = "proxyService")
    public IAccountService getAccountService() {
        return (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),
                accountService.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     * 添加事务的支持
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        Object rtValue = null;
                        try {
                            //1.开启事务
                            manager.startTransaction();
                            //2.执行操作
                            rtValue = method.invoke(accountService, args);
                            //3.提交事务
                            manager.commitTransaction();
                            //4.返回结果
                            return rtValue;
                        } catch (Exception e) {
                            //5.回滚操作
                            manager.rollbackTransaction();
                            throw new RuntimeException(e);
                        } finally {
                            //6.释放连接
                            manager.release();
                        }
                    }
                });
    }
}
```

- 删除AccountServiceImpl大量的重复事务方法

```java
package com.kl.service.impl;

import com.kl.dao.IAccountDao;
import com.kl.domain.Account;
import com.kl.service.IAccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service("accountService")
public class AccountServiceImpl implements IAccountService {
    @Autowired
    private IAccountDao accountDao;

    public List<Account> findAllAccount() {
        return accountDao.findAllAccount();
    }

    public Account findAccountById(Integer id) {
       return accountDao.findAccountById(id);
    }

    public void saveAccount(Account account) {
        accountDao.saveAccount(account);
    }

    public void updateAccount(Account account) {
        accountDao.updateAccount(account);
    }

    public void deleteAccountById(Integer id) {
        accountDao.deleteAccountById(id);
    }

    @Override
    public void transfer(String sourceName, String targetName, Float money) {
        //2.执行操作
        //2.1.根据名称查询转出账户
        Account source = accountDao.selectAccountByName(sourceName);
        //2.2.根据名称查询转入账户
        Account target = accountDao.selectAccountByName(targetName);
        //2.3.转出账户减钱
        source.setMoney(source.getMoney() - money);
        //2.4.转入账户加钱
        target.setMoney(target.getMoney() + money);
        //2.5.更新转出账户
        accountDao.updateAccount(source);
        int i = 1/0;
        //2.6.更新转入账户
        accountDao.updateAccount(target);
    }
}
```

- 在测试类中指定IAccountService用代理service注入

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfiguration.class)
public class AccountTest {
    @Autowired
    @Qualifier("proxyService") //配置当前的service为代理service
    private IAccountService service;

    @Test
    public void testFindAll(){
        List<Account> allAccount = service.findAllAccount();
        for (Account account : allAccount) {
            System.out.println(account);
        }
    }
    @Test
    public void testTransfer(){
        service.transfer("张三", "李四",100f);
    }
}
```

# 三、AOP

## 3.1AOP的概念和作用

- AOP：全称是Aspect oriented programming，即(面向切面编程)

>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译万式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式练程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务遷辑各部分之间的關合度降低，提高程序的可重用性，同时提高了开发的效率

- 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强
- 作用：在程序运行期间，不修改源码对已有方法进行增强
- 优势：减少重复代码，提高开发效率，维护方便



