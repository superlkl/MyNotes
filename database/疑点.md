# Group By

先来看下表1，表名为test：

![img](http://images.cnitblog.com/blog/639022/201501/162344381367279.jpg)

执行如下`SQL`语句

```sql
SELECT name FROM test
GROUP BY name
```

运行的结果:表2

![img](http://images.cnitblog.com/blog/639022/201501/162345461519459.jpg)

为了能够更好的理解“group by”多个列“和”聚合函数“的应用，我建议在思考的过程中，由表1到表2的过程中，增加一个虚构的中间表：虚拟表3。下面说说如何来思考上面SQL语句执行情况：

1. FROM test：该句执行后，应该结果和表1一样，就是原来的表。

2. FROM test Group BY name：该句执行后，我们想象生成了虚拟表3，如下所图所示，生成过程是这样的：group by name，那么找name那一列，具有相同name值的行，合并成一行，如对于name值为`aa`的，那么`<1 aa 2>`与`<2 aa 3>`两行合并成1行，所有的id值和number值写到一个单元格里面。

![img](http://images.cnitblog.com/blog/639022/201501/162343319172617.jpg)

3. 接下来就要针对虚拟表3执行Select语句了：

（1）如果执行select *的话，那么返回的结果应该是虚拟表3，可是id和number中有的单元格里面的内容是多个值的，而关系数据库就是基于关系的，单元格中是不允许有多个值的，所以你看，执行select * 语句就报错了。

（2）我们再看name列，每个单元格只有一个数据，所以我们select name的话，就没有问题了。为什么name列每个单元格只有一个值呢，因为我们就是用name列来group by的。

（3）那么对于id和number里面的单元格有多个数据的情况怎么办呢？答案就是用聚合函数，聚合函数就用来输入多个数据，输出一个数据的。如count(id)，sum(number)，而每个聚合函数的输入就是每一个多数据的单元格。

（4）例如我们执行select name,sum(number) from test group by name，那么sum就对虚拟表3的number列的每个单元格进行sum操作，例如对name为`aa`的那一行的number列执行sum操作，即2+3，返回5，最后执行结果如下：

![img](http://images.cnitblog.com/blog/639022/201501/170013481981068.jpg)

（5）group by 多个字段该怎么理解呢：如group by name,number，我们可以把name和number 看成一个整体字段，以他们整体来进行分组的

![image-20191218193038723](疑点.assets/image-20191218193038723.png)

（6）接下来就可以配合select和聚合函数进行操作了。如执行select name,sum(id) from test group by name,number，结果如下图：

![img](http://images.cnitblog.com/blog/639022/201501/170016502617188.jpg)

# 数据库的主键和外键

数据库主键是指表中一个列或列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。一个表只能有一个 PRIMARY KEY 约束，而且 PRIMARY KEY 约束中的列不能接受空值。

主键具有的特点：唯一性、非空性。

>**主键带来了什么样的优点和缺点？**

外键也叫FOREIGN KEY，是用于将两个表链接在一起的键。

FOREIGN KEY是一个表中的一个字段（或字段集合），它引用另一个表中的PRIMARY KEY。

包含外键的表称为子表，包含候选键的表称为引用表或父表。

请看以下两个表：

Person表

| PersonID | LastName  | FirstName | Age  |
| :------- | :-------- | :-------- | :--- |
| 1        | Hansen    | Ola       | 30   |
| 2        | Svendson  | Tove      | 23   |
| 3        | Pettersen | Kari      | 20   |

Orders表

| OrderID | OrderNumber | PersonID |
| :------ | :---------- | :------- |
| 1       | 77895       | 3        |
| 2       | 44678       | 3        |
| 3       | 22456       | 2        |
| 4       | 24562       | 1        |

Orders表中的PersonID列指向Persons表中的PersonID列。

Persons表中的PersonID列是Persons表中的PRIMARY KEY。

Orders表中的PersonID列是Orders表中的FOREIGN KEY。

**外键带来的好处主要是，保证数据的完整性和一致性，主要目的是控制存储在外键表中的数据。同时支持关联查询。FOREIGN KEY约束用于防止会破坏表之间链接的操作**

关于外键的使用存在一些争议，因为它在确保两个表之间的关系的时候又带来很多限制，很多工程师认为应该在代码逻辑里控制两个表的关系，而不在数据库表之间定义这样的关系。同时，外键对数据的插入删除等都会带来影响，因为表与表之间存在关联，因此各种操作都会变慢，因此在定义外键之前应该尽量考虑好数据的量，以及数据的读写频率等等。

个人从目前的实际经验出发也不是特别喜欢太多的外键关系存在。尽量子代码曾通过逻辑控制数据之间的关系可能确实是更好的做法。在使用的时候应该结合实际情况进行抉择。



>**SQL里,没有主外键关系，能进行连接查询吗？**

查询和主键外键没有关系，甚至公共字段也不是必须的。

# SQL的四种连接查询

SQL数据库中有两张表，一张人员（T_Person）表、一张卡（T_Card）表，人基本上都那么几张卡，像银行卡、饭卡、水卡、电费卡……

![img](https://img-blog.csdn.net/20150927144910225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20150927144926587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 内连接

### 1.内连接（inner join 或 join）

内连接是等值连接，它使用“=、>、<、<>”等运算符根据每个表共有的列的值匹配两个表中的行

查询语句：

```sql
select * from T_Person inner join T_Card 
on T_Person.CardId = T_Card.CardId
```

查询结果：

![img](https://img-blog.csdn.net/20150927150920047?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 外连接 

### 2.左连接（left join 或 left outer join）

左连接又称左向外连接，查询的结果集包括SQL语句中左表的所有行，右表中匹配的行。如果左表的某行在右表中没有匹配行，则用空值表示

查询语句：

```sql
select * from T_Person left join T_Card on T_Person.CardId = T_Card.CardId
```

查询结果：

![img](https://img-blog.csdn.net/20150927155411137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

3.右连接（right join 或 right outer join）
右连接也成右向外连接，查询的结果集包括SQL语句中右表的所有行，左表中匹配的行。如果右表的某行在左表中没有匹配的行，则用空值表示

查询语句：

```sql
 select * from T_Person right join T_Card on T_Person.CardId = T_Card.CardId
```
查询结果：

![img](https://img-blog.csdn.net/20150927155426463?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

4.完全外连接（full join 或 full outer join）
        完全外连接，查询的结果集包括SQL语句中左表和右表的所有行。如果某行在另一个表中没有匹配行时，则用空值表示。

查询语句：

```sql
select * from T_Person full join T_Card on T_Person.CardId = T_Card.CardId
```
查询结果：
![img](https://img-blog.csdn.net/20150927155451287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**总结：**

 SQL中连接查询分内、外连接，外连接分左连接、右连接和完全外连接，它们的功能与视图差不多。

