# 基本数据类型

C语言有丰富的数据类型，因此它很适合用来编写数据库，如DB2、Oracle等大型数据库都是C语言写的。其中，提供了4种最常用的基本数据类型：char、int、float、double，使用这些数据类型，我们就可以定义相应的变量来存储数据。

## 一、取值范围

我们已经知道，不同数据类型所占的存储空间是不一样的。比如在64bit环境下，char类型占用1个字节，int类型占用4个字节。字节长度不一样，包含的二进制位数就不一样，能表示的数据范围也就不一样。因此，int类型能表示的数据范围肯定比char类型大。下面来简单算算64bit环境下int类型的取值范围。

### 1.推算int类型的取值范围

int类型占用4个字节，所以一共32位，那么按理来说，取值范围应该是：0000 0000 0000 0000 0000 0000 0000 0000~1111 1111 1111 1111 1111 1111 1111 1111，也就是10进制的0 ~ 232 - 1。但是int类型是有正负之分的，包括了正数和负数，那怎么表示负数呢？就是拿最高位来当符号位，当最高位为0就是正数，最高位为1则是负数。即：1000 0000 1001 1011 1000 0000 1001 1011就是一个负数，0000 1001 0000 1101 0000 1001 0000 1101是一个正数。由于最高位是0才代表正数，因此最大的正数是0111 1111 1111 1111 1111 1111 1111 1111，也就是231 - 1。而最小的负数就是1000 0000 0000 0000 0000 0000 0000 0000，也就是-231（为什么是这个值呢？可以根据前面提到的负数的二进制形式，自己去换算一下，看看1000 0000 0000 0000 0000 0000 0000 0000是不是-2^31。算不出也不用去纠结，不影响写代码，知道有这么一回事就完了）。因此，int类型的取值范围是-2^31 ~ 2^31 - 1。

注意：这个推算过程是不用掌握的，大致知道过程就行了，而且这个结论也不用去记，大致知道范围就行了。

 

### 2.各种数据类型的取值范围

int类型的取值范围已经会算了，那么其他数据类型的取值范围就能够以此类推。

![img](https://images0.cnblogs.com/blog/497279/201305/09170808-73f04ed5ef094897b38a5a2cb14ecf2b.png)

（注：float和double由于是小数，它们的存储方式是特别不一样的，所以它们取值范围的算法也很不一样，这里不做介绍，也不用去掌握。e^38表示乘以10的38次方，e^-38表示乘以10的负38次方。）

上面表格中列出的只是64bit环境下的情况。如果你的设备是16bit或者32bit，这些数据类型的取值范围肯定是不一样的。比如int类型，在16bit环境下是占用2个字节的，共16bit，所以int类型的取值范围是：-2^15 ~ 2^15 - 1。

 

### 3.数值越界

#### 1> 例子演示

前面已经看到，每种数据类型都有自己的取值范围。如果给一个变量赋值了一个超出取值范围的数值，那后果会不堪设想。

```C
#include <stdio.h>

int main()
{
    int c = 1024 * 1024 * 1024 * 4;
    
    printf("%d\n", c);
    return 0;
}
```

我们都知道，int类型能保存的最大值是2^31-1。在第5行给int类型的变量c赋值一个比2^31-1大的数值：2^32 （1024是210）

先看看在终端中的输出结果：![img](https://images0.cnblogs.com/blog/497279/201305/09183149-b5faeb2c1361452f97f1e8ee992fabf5.png)，可以看出输出的值是0。

 

#### 2> 结果分析

我们可以简单分析一下为什么将232赋值给变量c之后输出的是0。2^32的 二进制形式是：1 0000 0000 0000 0000 0000 0000 0000 0000，一共有33位二进制数。变量c占用了4个字节，只能容纳32位二进制数，而且内存寻址是从大到小的，因此，变量c在内存中的存储形式是0000 0000 0000 0000 0000 0000 0000 0000，也就是0，最前面的那个1就不属于变量c的了。

![img](https://images0.cnblogs.com/blog/497279/201305/09184235-1b49b591b29a42bfadc356055d7a8769.png)

 

#### 3> 结论

可以发现，如果超出了变量的取值范围，那么将损失精度，得到“垃圾数据”（“垃圾数据”就是指并非我们想要的数据）。可是，有时候我们确实要存储一个很大很大的整数，比231-1还大的整数，这该怎么办呢？这个就要用到类型说明符，这这讲的后面会讨论。

 

## 二、char

### 1.简单使用

char是C语言中比较灵活的一种数据类型，称为“字符型”。既然叫“字符型”，那肯定是用来存储字符的，因此我们可以将一个字符常量赋值给一个字符型变量。

```C
#include <stdio.h>

int main()
{
    char c = 'A';
    
    printf("%c\n", c);
    return 0;
}
```

在第5行定义了一个char类型变量c，并将字符常量'A'赋值给了c。在第7行将字符变量c输出到屏幕，%c的意思是以字符的格式输出。

输出结果：![img](https://images0.cnblogs.com/blog/497279/201305/09195539-105cb49e0a5940bab2ce7686d47993cb.png)

 

### 2.字符常量一定要用单引号括住

1> 下面的写法是错误的：

```C
1 int main()
2 {
3     char c = A;
4     return 0;
5 }
```

编译器会直接报第3行的错，错误原因是：标识符A找不到。你直接写个大写A，编译器会认为这个A是一个变量。因此写成'A'才是正确的，或者在第3行代码的前面再定义1个变量名叫做A的char类型变量。

2> 下面的写法也是错误的：

```
1 int main()
2 {
3     char c = "A";
4     return 0;
5 }
```

第3行中的"A"并不是字符常量，而是字符串常量，将字符串"A"赋值给字符变量c是错误的做法。字符串和字符的存储机制不一样，因此"A"和'A'是有本质区别的。

 

### 3.字符型变量还可以当做整型变量使用

1个字符型变量占用1个字节，共8位，因此取值范围是-2^7~2^7-1。在这个范围内，你完全可以将字符型变量当做整型变量来使用。

```C
#include <stdio.h>

int main()
{
    char c1 = -10;
    
    char c2 = 120;
    
    printf("c1=%d  c2=%d \n", c1, c2);
    return 0;
}
```

由于第9行用的是%d，表示以十进制整数格式输出，输出结果：![img](https://images0.cnblogs.com/blog/497279/201305/09220314-d35eb8d963f24d8fa78677d3f0dec183.png)。因此，如果使用的整数不是很大的话，可以使用char代替int，这样的话，更节省内存开销。

 

### 4.字符型变量只能存储单字节字符

其实字符有2种类型：单字节字符和双字节字符。

- 单字节字符：在内存中占用1个字节的字符。包括了26个英文字母的大小写、10个阿拉伯数字等字符；
- 双字节字符：在内存中占用2个字节的字符。包括了中国、日本和韩国等国家的文字，比如汉字。

1个字符型变量只占用1个字节，所以1个字符型变量只能存储1个单字节字符。

下面的写法是错误的：

```C
#include <stdio.h>

int main()
{
    char c = 'ABCD';
    
    printf("%c\n", c);
    return 0;
}
```

编译器会对上面的代码发出警告，并不会报错，因此程序还是能够运行。由于变量c只能存储1个单字节字符，最终变量c只存储了'ABCD'中的'D'。

输出结果：![img](https://images0.cnblogs.com/blog/497279/201305/09200056-9a9e72130cb54e39975a8af335b4cb2b.png)

 

### 5.字符型变量不能存储汉字

在内存中，1个汉字需要用2个字节来存储，而1个字符型变量只占用1个字节的存储空间，所以字符型变量不能用来存储汉字。

**下面的写法是错误的：**

```C
1 int main()
2 {
3     char c = '男';    
4     return 0;
5 }
```

 编译器会直接报第3行的错误。记住一个原则：**单引号括住的必须是单字节字符。**

 

### 6.ASCII

说到字符，就不得不提ASCII这个概念

1> ASCII是基于拉丁字母的一套电脑编码系统，是现今最通用的**单字节**编码系统，全称是“American Standard Code for Information Interchange”。编码系统，看起来好像很高级，其实就是一个字符集---字符的集合。

2> ASCII字符集包括了：所有的大写和小写英文字母，数字0到9，标点符号，以及一些特殊控制字符：如退格、删除、制表、回车，一共128个字符，全部都是**“单字节字符”**。

3> 在计算机中的任何数据都是以二进制形式存储的，因此每个ASCII字符在内存中是以二进制形式存储的，而且只占用1个字节，二进制数的值就称为这个ASCII字符的ASCII值。比如大写字母A在内存中的二进制形式是：0100 0001，那么它的ASCII值就是65。

4> 下面是一张ASCII码字符表，ASCII码值的范围是0~127

![img](https://images0.cnblogs.com/blog/497279/201305/09214122-8dca20a6531a4c7dac581a2da171e449.png)

5> 我们都知道1个char型变量只占用1个字节的存储空间，而所有的ASCII字符都是单字节字符，因此char型变量能存储任何ASCII字符。而且在使用char型变量存储ASCII字符时，可以直接用ASCII字符，也可以用ASCII值。

```C
#include <stdio.h>

int main()
{
    char c1 = 65; //5
    
    char c2 = 'A';  //7
    
    printf("c1=%c  c2=%c \n", c1, c2);
    return 0;
}
```

在第5、7行分别定义了字符型变量c1、c2。很明显，变量c2存储的是ACII字符'A'；变量c1存储的是65，而ASCII值65对应的ASCII字符就是'A'，因此变量c1存储的也是'A'。

由于第9行用的是%c，表示以字符格式输出，输出结果：![img](https://images0.cnblogs.com/blog/497279/201305/09220450-b86d8afae4094e08b89e81bb92cbb816.png)

5> 经过上面的例子后，应该知道6和'6'的区别了吧

```C
#include <stdio.h>

int main()
{
    char c1 = 6;
    
    char c2 = '6';
    
    printf("c1=%d  c2=%d \n", c1, c2);
    return 0;
}
```

第5行给变量c1赋值了整数6，第7行给变量c2赋值了字符'6'，'6'的ASCII值是54。

由于第9行用的是%d，表示以十进制整数格式输出，输出结果：![img](https://images0.cnblogs.com/blog/497279/201305/09223439-098feba4e0bf47e7aa85c8bf7d1e7a81.png)

 

## 三、说明符

### 1.什么是说明符

1> 我们已经知道，在64bit环境下，1个int类型变量取值范围是-231 ~ 231 - 1，最大值是231-1。有时候，我们要使用的整数可能比231-1还大，比如234这个整数，如果还坚持用int类型变量来存储这个值的话，就会损失精度，得到的是垃圾数据。为了解决这个问题，C语言允许我们给int类型的变量加一些说明符，某些说明符可以增大int类型变量的长度，这样的话，int类型变量能存储的数据范围就变大了。

2> C语言提供了以下4种说明符，4个都属于关键字：

- short 短型
- long 长型
- signed 有符号型
- unsigned 无符号型

按照用途进行分类，short和long是一类，signed和unsigned是一类。

 

### 2.用法演示

这些说明符一般就是用来修饰int类型的，所以在使用时可以省略int

```C
// 下面两种写法是等价的
 short int s1 = 1;
 short s2 = 1;
 
 // 下面两种写法是等价的
 long int l1 = 2;
 long l2 = 2;
 
 // 可以连续使用2个long
 long long ll = 10;
 
 // 下面两种写法是等价的
 signed int si1 = 3;
 signed si2 = 3;
 
 // 下面两种写法是等价的
 unsigned int us1 = 4;
 unsigned us2 = 4;
 
 // 也可以同时使用2种修饰符
 signed short int ss = 5;
 unsigned long int ul = 5;
```

1> 第2行中的short int和第3行中的short是等价的。

2> 看第10行，可以连续使用两个long。long的作用会在后面解释。

3> 注意第21和22行，可以同时使用两种不同的说明符。但是不能同时使用相同类型的修饰符，也就是说不能同时使用short和long 或者 不能同时使用signed和unsigned。

 

### 3.short和long

1> short和long可以提供不同长度的整型数，也就是可以改变整型数的取值范围。在64bit环境下，int占用4个字节（32bit），取值范围是-231~231-1；short占用2个字节（16bit），取值范围是-215~215-1；long占用8个字节（64bit），取值范围是-263~263-1

2> 总结一下：在64位环境下，short占2个字节(16位)，int占4个字节(32位)，long占8个字节(64位)。因此，如果使用的整数不是很大的话，可以使用short代替int，这样的话，更节省内存开销。

3> 世界上的编译器林林总总，不同编译器环境下，int、short、long的取值范围和占用的长度又是不一样的。比如在16bit环境下，long只占用4个字节。不过幸运的是，ANSI \ ISO制定了以下规则：

- short跟int至少为16位(2字节)
- long至少为32位(4字节)
- short的长度不能大于int，int的长度不能大于long
- char一定为为8位(1字节)，毕竟char是我们编程能用的最小数据类型

4> 可以连续使用2个long，也就是long long。一般来说，long long的范围是不小于long的，比如在32bit环境下，long long占用8个字节，long占用4个字节。不过在64bit环境下，long long跟long是一样的，都占用8个字节。

5> 还有一点要明确的是：short int等价于short，long int等价于long，long long int等价于long long

 

### 4.long的使用注意

#### 1> 常量

long和int都能够存储整型常量，为了区分long和int，一般会在整型常量后面加个小写字母l，比如100l，表示long类型的常量。如果是long long类型呢，就加2个l，比如100ll。如果什么都不加，就是int类型的常量。因此，100是int类型的常量，100l是long类型的常量，100ll是long long类型的常量。

```C
int main()
{
    int a = 100;
    
    long b = 100l;
    
    long long c = 100ll;
    
    return 0;
}
```

变量a、b、c最终存储的值其实都是100，只不过占用的字节不相同，变量a用4个字节来存储100，变量b、c则用8个字节来存储100。

其实，你直接将100赋值给long类型的变量也是没问题的，照样使用。因为100是个int类型的常量，只要有4个字节，就能存储它，而long类型的变量b有8个字节，那肯定可以装下100啦。

```C
int main()
{
    long b = 100;
    
    return 0;
}
```



#### 2> 输出

```C
#include <stdio.h>

int main()
{
    long a = 100000000000l;
    
    printf("%d\n", a);
    return 0;
}
```

在第5行定义了long类型变量a，在第7行尝试输出a的值。注意了，这里用的是%d，表示以十进制整数格式输出，%d会把a当做int类型来输出，它认为a是4个字节的。由于a是long类型的，占用8个字节，但是输出a的时候，只会取其中4个字节的内容进行输出，所以输出结果是：

![img](https://images0.cnblogs.com/blog/497279/201305/10002918-31ca4ffb485c4d3dbb12b239d72d50d2.png)又是传说的垃圾数据

 

那怎样才能完整地输出long类型呢？应该用格式符%ld

```C
#include <stdio.h>

int main()
{
    long a = 100000000000l;
    
    printf("%ld\n", a);
    return 0;
}
```

注意第7行，双引号里面的是%ld，表示输出1个long类型的整数，这时候的输出结果是：

![img](https://images0.cnblogs.com/blog/497279/201305/10003147-910fb5e212f548259a6d8c634633c1b4.png)

 

如果是long long类型，应该用%lld

```C
#include <stdio.h>

int main()
{
    long long a = 100000000000ll;
    
    printf("%lld\n", a);
    return 0;
}
```



### 5.signed和unsigned

1> 首先要明确的：signed int等价于signed，unsigned int等价于unsigned

2> signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。

- signed：表示有符号，也就是说最高位要当做符号位，所以包括正数、负数和0。其实int的最高位本来就是符号位，已经包括了正负数和0了，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是-231 ~ 231 - 1
- unsigned：表示无符号，也就是说最高位并不当做符号位，所以不包括负数。在64bit环境下面，int占用4个字节（32bit），因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0 ~ 232 - 1

 

### 6.signed、unsigned也可以修饰char，long还可以修饰double

知道有这么一回事就行了。

```C
1 unsigned char c1 = 10;
2 signed char c2 = -10;
3 
4 long double d1 = 12.0;
```

 

### 7.不同数据类型所占用的存储空间

![img](https://images0.cnblogs.com/blog/497279/201305/10145346-1a5eb010f7ab4a8fb254599dc3923af6.png)

 

## 四、自动类型提升

### 1.什么是自动类型提升

先来看看下面的一则运算

```C
#include <stdio.h>

int main()
{
    int a = 10;
    
    double d = a + 9.5;
    
    printf("%f \n", d);
    
    return 0;
}
```

1.  在第5行定义了一个int类型的变量a，赋值了一个整数10。

2. 接着在第7行取出a的值10，加上浮点数9.5，这里做了一个**“加法运算”**，并且将“和”赋值给d。所以d的值应该是19.5。

3.  在第9行使用格式符%f输出浮点型变量d，默认是保留6位小数的。输出结果为：

![img](https://images0.cnblogs.com/blog/497279/201305/10100907-7401d4beea3648aca957314a32a428ec.png)

4. 看似这么简单的运算，其实包含了一些语法细节在里面。**严格来说，相同数据类型的值才能进行运算（比如加法运算），而且运算结果依然是同一种数据类型。**第7行的情况是：变量a的值10是int类型（4字节），9.5是double类型（8字节）。很明显，10和9.5并不是相同数据类型。按理来说，10和9.5是不允许进行加法运算的。但是，系统会自动<u>对占用内存较少的类型</u>做一个“**自动类型提升**”的操作，也就把10提升为double类型。也就是说，本来是用4个字节来存放10的，现在改为用8个字节来存放10。因此，10和9.5现在都是用8个字节来存放的，都是double类型，然后就可以进行运算了。并且把运算结果赋值给double类型的变量d。

5. 需要注意的是：经过第7行代码后，变量a一直都还是int类型的，并没有变成double类型。**1个变量在它定义的时候是什么类型，那么就一直都是什么类型。“自动类型提升”只是在运算过程中进行的。**

 

### 2.常见的自动类型提升

```C
int main()
{
    float a = 10 + 3.45f;// int 提升为 float
    
    int b = 'A' + 32; // char 提升为 int
    
    double c = 10.3f + 5.7; // float 提升为 double
    
    return 0;
}
```

1. 注意第5行，系统会将字符'A'提升为int类型数据，也就是转为'A'的ASCII值后再跟32进行加法运算。'A'的ASCII值是65，因此变量b的值为65+32=97。

2. 这个自动类型提升，知道有这么一回事就行了，不用死记这规则，因为系统会自动执行这个操作。

 

## 五、强制类型转换

### 1.什么是强制类型转换

先来看看下面的代码

```c
#include <stdio.h>

int main()
{
    int i = 10.7;
    
    printf("%d \n", i);
    return 0;
}
```

1. 注意第5行，我们将一个8个字节的浮点数10.7赋值给了只有4个字节存储空间的整型变量i。可以想象得到，把8个字节的内容塞给4个字节，肯定会损失精度。在第7行将变量i的值输出，输出结果是：

![img](https://images0.cnblogs.com/blog/497279/201305/10103224-09ed8430495745138315752005b7d527.png)输出值为10，这是必然的。

2. 这里面也有一点语法细节，其实第5行做了一个“强制类型转换”的操作：由于左边是int类型的变量i，那么就会强制把double类型的10.7转换为int类型的10，并且把转换后的值赋值给了整型变量i。由于C语言是语法限制不严格，所以系统会自动强制转换，如果换做是其他语法严格的语言，比如Java，第5行代码早就报错了。

3. 如果写得严格一点，明显地进行“强制类型转换”，应该这样写：

```C
#include <stdio.h>

int main()
{
    int i = (int) 10.7;
    
    printf("%d \n", i);
    return 0;
}
```

注意第5行，在10.7的前面加了个(int)，表示强制转换为int类型的数据。这样就绝对不会有语法问题了。总之你将一个浮点型数据转换为整型数据，就会丢失小数部分的值。



### 2.常见的强制类型转换

```C
int main()
{
    int a = 198l; // long 转换为 int
    
    char b = 65; // int 转换为 char
    
    int c = 19.5f; // float 转换为 int
    
    return 0;
}
```

这个强制类型转换，知道有这么一回事就行了，不用死记这规则，因为很多时候系统会自动执行这个操作。



### 3.其他用法

前面看到的强制转换好像都是“大类型”转为“小类型”，其实这是不一样的，也可以由“小类型”转为“大类型”

```C
int main()
{
    int a = 10;
    
    double b = (double)a  + 9.6;
    
    return 0;
}
```

注意第5行，先将a的值强制转换为double类型后，再跟9.6进行加法运算。这样的话，系统就不用执行“自动类型提升”的操作了。其实你不强转也可以的，因为系统会做一个“自动类型提升”的操作，将变量a的值10提升为double类型。知道有这用法就行了，以后某些地方会用得上。