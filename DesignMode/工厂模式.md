# 背景介绍

在面向对象编程中, 最通常的方法是一个new操作符产生一个对象实例,new操作符就是用来构造对象实例的。但是在一些情况下, new操作符直接生成对象会带来一些问题。举例来说, 许多类型对象的创造需要一系列的步骤: 你可能需要计算或取得对象的初始设置; 选择生成哪个子对象实例; 或在生成你需要的对象之前必须先生成一些辅助功能的对象。 在这些情况,新对象的建立就是一个 “过程”，不仅是一个操作，像一部大机器中的一个齿轮传动。

# 工厂模式了解一

老规矩先用比较难理解的官方语言来表达，工厂模式是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。**在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象**。现在在以一个具体的例子来简单简化下工厂模式。假如我现在去餐馆吃饭，餐馆有回锅肉，有鱼，有烤鸭可供我选择，然后我点餐餐馆为我做出具体的菜。

# 简单工厂模式了解一

先准备一个餐馆，餐馆可以做饭给客人享用

```java
public interface Restaurant {
    void cook();
}
```

可以做烤鸭

```java
public class Duck implements Restaurant {
    @Override
    public void cook() {
        System.out.println("做一份烤鸭");
    }
}
```

可以做酸汤鱼

```java
public class Fish implements Restaurant {
    @Override
    public void cook() {
        System.out.println("做一份酸汤鱼");
    }
}
```

可以做红烧肉

```java
public class Meet implements Restaurant {
    @Override
    public void cook() {
        System.out.println("做一份红烧肉");
    }
}
```

准备一份菜单，菜单上的都可以点

```java
//菜单
class Meuns {
    public static final int MEAN_MEET = 1;
    public static final int MEAN_FISH = 2;
    public static final int MEAN_DUCK = 3;

    public static Restaurant getMeuns(int meanType){
        switch (meanType){
            case MEAN_MEET :
                return new Meet();
            case MEAN_FISH :
                return new Fish();
            case MEAN_DUCK :
                return new Duck();
            default:
                return null;
        }
    }
}
```

有客人进来了，点了一份烤鸭

```java
public class Factory {
    public static void main(String[] args) {
        //简单工厂模式
        Restaurant restaurant = Meuns.getMeuns(Meuns.MEAN_DUCK);
        restaurant.cook();
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019120619022897.png)

## 优点

我们可以对创建的对象进行一些 “加工” ，而且客户端（顾客）并不知道，因为工厂隐藏了这些细节。如果，没有工厂的话，那我们是不是就得自己在客户端上写这些代码，这就好比本来可以在工厂里生产的东西，拿来自己手工制作，不仅麻烦以后还不好维护。

## 缺点

如果需要在方法里写很多与对象创建有关的业务代码，而且需要的创建的对象还不少的话，我们要在这个简单工厂类里编写很多个方法，每个方法里都得写很多相应的业务代码，而**每次增加子类或者删除子类对象的创建都需要打开这简单工厂类来进行修改**。（每次出了新品菜肴就要重新打开菜单类在里面修改）这会导致这个简单工厂类很庞大臃肿、耦合性高，而且增加、删除某个子类对象的创建都需要打开简单工厂类来进行修改代码也**违反了开-闭原则**。


# 工厂模式了解二

## 引言

1. **还没有工厂的时代**：假如还没有工业革命，如果一个客户要一款宝马车,一般的做法是客户去创建一款宝马车，然后拿来用。
2. **简单工厂模式**：后来出现工业革命。用户不用去创建宝马车。<u>因为客户有一个工厂来帮他创建宝马.想要什么车，这个工厂就可以建</u>。比如想要`320i`系列车。工厂就创建这个系列的车。即工厂可以创建产品。
3. **工厂方法模式时代**：为了满足客户，宝马车系列越来越多，如`320i`，`523i`,`30li`等系列一<u>个工厂无法创建所有的宝马系列。于是由单独分出来多个具体的工厂。每个具体工厂创建一种系列。即具体工厂类只能创建一个具体产品</u>。但是宝马工厂还是个抽象。你需要指定某个具体的工厂才能生产车出来。
4. **抽象工厂模式时代**：随着客户的要求越来越高，<u>宝马车必须配置空调。于是这个工厂开始生产宝马车和需要的空调。</u>

最终是客户只要对宝马的销售员说：我要`523i`空调车，销售员就直接给他`523i`空调车了。而不用自己去创建`523i`空调车宝马车，这就是工厂模式。

# 简单工厂模式了解二

从无到有。客户自己创建宝马车，然后拿来用

**没有用工厂模式之前**

```java
public class BMW320 {
    public BMW320(){
        System.out.println("制造-->BMW320");
    }
}

public class BMW523 {
    public BMW523(){
        System.out.println("制造-->BMW523");
    }
}

public class Customer {
    public static void main(String[] args) {
        BMW320 bmw320 = new BMW320();
        BMW523 bmw523 = new BMW523();
    }
}
```

客户需要知道怎么去创建一款车(在构造这类车的时候得了解它的构造方法这些),客户和车就紧密耦合在一起了.为了降低耦合,就出现了工厂类,把创建宝马的操作细节都放到了工厂里面去,客户直接使用工厂的创建工厂方法,传入想要的宝马车型号就行了,而不必去知道创建的细节.这就是工业革命了：**简单工厂模式**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191206193244448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

**产品类：**

```java
//抽象产品
abstract class BMW {
     BMW(){}
}

//具体产品
class BMW320 extends BMW {
     BMW320() {
        System.out.println("制造-->BMW320");
    }
}

//具体产品
class BMW523 extends BMW{
     BMW523(){
        System.out.println("制造-->BMW523");
    }
}
```

**工厂类：**

```java
class Factory {
     static BMW createBMW(int type) {
        switch (type) {
            case 320:
                return new BMW320();
            case 523:
                return new BMW523();
            default:
                break;
        }
        return null;
    }
}
```

**客户类：**

```java
public class Customer {
    public static void main(String[] args) {
        Factory.createBMW(320);
        Factory.createBMW(523);
    }
}
```



![在这里插入图片描述](https://img-blog.csdnimg.cn/20191206194639919.png)



1. 它是一个**具体的类**(Factory)，非接口、抽象类。有一个重要的`createBMW()`方法，利用if或者 switch创建产品并返回。

2.  `createBMW()`方法通常是**静态**的，也可以不是静态的，所以也称之为**静态工厂**。

```java
 class Factory {
     //非静态方法
    public BMW createBMW(int type) {
        switch (type) {
            case 320:
                return new BMW320();
            case 523:
                return new BMW523();
            default:
                break;
        }
        return null;
    }
}

public class Customer {
    public static void main(String[] args) {
        Factory factory = new Factory();
        factory.createBMW(320);
        factory.createBMW(523);
    }
}
```

## 分析

下面我们从**开闭原则（对扩展开放；对修改封闭）**上来再分析下简单工厂模式：

当客户不再满足现有的车型号的时候，想要一种速度快的新型车，只要这种车符合抽象产品制定的合同，那么只要通知工厂类知道就可以被客户使用了。所以**对产品部分来说，它是符合开闭原则的；**

**但是工厂部分好像不太理想，因为每增加一种新型车，都要在工厂类中增加相应的创建业务逻辑**（`createBMW(int type)`方法需要新增case），这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。对于这样的工厂类，我们称它为全能类或者上帝类。

我们举的例子是最简单的情况，而在实际应用中，很可能产品是一个多层次的树状结构。由于简单工厂模式中只有一个工厂类来对应这些产品，所以这可能会把我们的上帝累坏了，也累坏了我们这些程序员。

于是工厂方法模式作为救世主出现了。 **工厂类定义成了接口,而每新增的车种类型,就增加该车种类型对应工厂类的实现,这样工厂的设计就可以扩展了,而不必去修改原来的代码**。



# 工厂方法模式了解

工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担。
 工厂方法模式组成：

1. 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在Java中它由抽象类或者接口来实现。
2. 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
3. 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在Java中一般有抽象类或者接口来实现。
4. 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在Java中由具体的类来实现。
5. 工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活 起来——当有新的产品产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代码。可以看出工厂角色的结构也是符合开闭原则的！



**产品类：**

```java
//抽象产品
abstract class BMW {
     BMW(){}
}

//具体产品
class BMW320 extends BMW {
     BMW320() {
        System.out.println("制造-->BMW320");
    }
}

//具体产品
class BMW523 extends BMW{
     BMW523(){
        System.out.println("制造-->BMW523");
    }
}
```

**创建工厂类：**

```java
//现在的工厂是一个接口
interface FactoryBMW {  
    BMW createBMW();  
}  

//具体的工厂
public class FactoryBMW320 implements FactoryBMW{

    @Override
    public BMW createBMW() {

        return new BMW320();
    }

}

public class FactoryBMW523 implements FactoryBMW {
    @Override
    public BMW createBMW() {

        return new BMW523();
    }
}
```

**客户类：**

```java
public class Customer {
    public static void main(String[] args) {
        FactoryBMW factoryBMW320=new FactoryBMW320();
        factoryBMW320.createBMW();
        
        FactoryBMW factoryBMW523=new FactoryBMW523();
        factoryBMW523.createBMW();

    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191206194639919.png)

工厂方法模式就是把工厂类单独拿出来解耦重新设计了一下，简单工厂模式就是用switch直接按照用户的传入数据就生产相应的产品，工厂方法模式则是更加细分了，每一个工厂都只能生产具体的一种产品，简言之就是先掌握了生产产品的技术，然后需要什么产品就问什么工厂要。

## 总结

这种工厂方法，如果后期还有新的具体产品，只需要继承BMW这个类（抽象产品），然后定义新的工厂，
同样是实现`FactoryBMW`这个接口（工厂接口），生产具体的产品就OK了。这样就符合开闭原则，对扩展开发，修改关闭。
而简单工厂方法：如果后期有新的产品，产品同样可以继承BMW这个类（抽象产品），但是，如果要得到这个具体的产品时，需要在原来工厂类中修改代码，添加一个新产品的方法，这样就修改了原来的代码，这就不符合开闭原则了。

**缺点：**

工厂方法模式仿佛已经很完美的对对象的创建进行了包装，使得客户程序中仅仅处理抽象产品角色提供的接口，但使得对象的数量成倍增长。当产品种类非常多时，会出现大量的与之对应的工厂对象，这不是我们所希望的。