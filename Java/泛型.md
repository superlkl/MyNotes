# 泛型

## 前言

泛型是指在对象创建时不指定类中属性的具体类型，而由外部在声明及实例化对象时指定类型

```java
/**
 * 设计一个坐标类，不指定属性的具体类型
 * 有x和y两个坐标
 */
public class Point {
    private Object x;
    private Object y;

    public Object getX() {
        return x;
    }

    public void setX(Object x) {
        this.x = x;
    }

    public Object getY() {
        return y;
    }

    public void setY(Object y) {
        this.y = y;
    }
}

```

**测试1：用整数表示**

```java
public class Test {
    public static void main(String[] args) {
        Point point=new Point();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX(10);
        point.setY(20);
        //向下转型
        int x= (int) point.getX();
        int y= (int) point.getY();
        System.out.println("坐标:"+x+" "+y);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127140802441.png)

**测试2：用小数表示**

```java
public class Test {
    public static void main(String[] args) {
        Point point=new Point();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX(10.0f);
        point.setY(20.0f);
        //向下转型
        Float x= (Float) point.getX();
        Float y= (Float) point.getY();
        System.out.println("坐标:"+x+" "+y);
    }
}

```

一定要注意在小数后要加一个f才能表示小数

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127141107220.png)

**测试3：用字符串表示**

```java
public class Test {
    public static void main(String[] args) {
        Point point=new Point();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX("东经20度");
        point.setY("南纬30度");
        //向下转型
        String x= (String) point.getX();
        String y= (String) point.getY();
        System.out.println("坐标:"+x+" "+y);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127141354957.png)

**测试4：用字符串和数字混合表示**

```java
public class Test {
    public static void main(String[] args) {
        Point point=new Point();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX("温度");
        point.setY(20);
        //向下转型
        String x= (String) point.getX();
        int y= (int) point.getY();
        System.out.println("坐标:"+x+" "+y);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127141613325.png)

这四个测试可以看出Object的确是超类，可以接收每种类型的数据

**测试5**

```java
public class Test {
    public static void main(String[] args) {
        Point point=new Point();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX("温度");
        point.setY(20);
        //向下转型
        String x= (String) point.getX();
        String y= (String) point.getY();
        System.out.println("坐标:"+x+" "+y);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127141836496.png)

报了类别错误，因为设置的温度和20不是一个类型，却都用一个类型接收了

## 泛型的必要性

**为什么要使用泛型？**

我们在编写程序时，经常遇到<u>两个模块的功能非常相似</u>，只是一个是处理int类型数据，另一个处理String类型数据，或者其他自定义类型数据，但是我们没有办法，只能分别写多个方法处理每种数据类型，因为方法的参数类型不同。那有一种方法，<u>在方法中传入通用的数据类型，就可以用来合并代码，这就是泛型。</u>

## 使用格式

```java
/**
 * 设计一个坐标类，不指定属性的具体类型
 * 有x和y两个坐标
 */
public class Point<T> {
    private T x;
    private T y;

    public T getX() {
        return x;
    }

    public void setX(T x) {
        this.x = x;
    }

    public T getY() {
        return y;
    }

    public void setY(T y) {
        this.y = y;
    }
}

```

```java
public class Test {
    public static void main(String[] args) {
        Point<String> point=new Point<String>();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX("温度");
        point.setY("湿度");
        //向下转型
        String x= point.getX();
        String y= point.getY();
        System.out.println("天气:"+x+" "+y);
    }
}


```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127142853460.png)

这样使用的好处有两个：

1. 不用再进行类型转换了，接收的类型与设置的类型错误还会提示，可以避免类型转换出现的错误
2. point成为了模板类，当我们需要改变这个类属性的基本类型，直接修改<>括号里的设置就可以了

` Point<String> point=new Point<String>();`这条语句后面括号里的String类型可以省略不写，但是<>一定要加上，虽然不加上也可以运行程序，但是加上比较规范。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127143515733.png)

>  **显式类型参数字符串可以替换为<>**  



设置为整型

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127143753537.png)

直接设置为int的话确实报错了，说不能使用原始类型，也就是说在规定泛型的类型时我们不能传入基本数据类型，而要使用类类型Integer

```java
public class Test {
    public static void main(String[] args) {
        Point<Integer> point=new Point<>();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX(10);
        point.setY(20);
        //向下转型
        int x= point.getX();
        int y= point.getY();
        System.out.println("天气:"+x+" "+y);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/201911271441049.png)

**还可以设置多个泛型类型**

```java
/**
 * 设计一个坐标类，不指定属性的具体类型
 * 有x和y两个坐标
 */
public class Point<T,K> {
    private T x;
    private K y;

    public Point(T x, K y) {
        this.x = x;
        this.y = y;
    }
    @Override
    public String toString() {
        return "Point{" +
                "x=" + x +
                ", y=" + y +
                '}';
    }
}
```

注：泛型的构造函数和一般构造函数的设置方式是完全相同的

```java
public class Test {
    public static void main(String[] args) {
        Point<String,Integer> point=new Point<>("温度",20);
        System.out.println(point);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127144708231.png)

## 通配符‘?’

在开发中对象的引用传递最为常见，但是如果在泛型类的操作中，在进行引用传递的泛型类型必须匹配才可以传递，否则是不能传递的

```java

public class Point<T> {
    private T x;

    public Point(T x) {
        this.x = x;
    }
    @Override
    public String toString() {
        return "Point{" +
                "x=" + x +
                '}';
    }
}
```

**情况一**

```java
public class Test {
    public static void main(String[] args) {
        Point<String> point=new Point<>("温度");
        print(point);
    }

    private static void print(Point<String> point){
        System.out.println(point);
    }
}
```

`Point<String> point`直接指定了泛型的类型，下面要接收这个泛型对象时也是直接设置为这个类型

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112714591945.png)

**情况二**`Point point`

```java
public class Test {
    public static void main(String[] args) {
        Point<String> point=new Point<>("构造函数");
        print(point);
    }
    private static void print(Point point){
        System.out.println(point);
    }
}
```

`Point point`直接不加后面的泛型类型，也可以输出，但是这样不严谨，要体现泛型类型才行，但是如果我们每改一次模板的泛型类型，就要改一次打印函数里的泛型类型来接收相对麻烦，所以就有了通配符这个东西，"?"，b表示可以接收任意类型的泛型对象

情况三`Point<?> point`

```java
public class Test {
    public static void main(String[] args) {
        Point<String> point=new Point<>("构造函数");
        print(point);
    }
    private static void print(Point<?> point){
        System.out.println(point);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112715071093.png)

## 受限泛型

### 上限

假设一个方法中能接收的泛型对象只能是数字类型，此时在定义方法参数接收对象时就只能使用泛型上限。

所以数字包装类都是Number类型的子类

测试：设置方法只能接收泛型为Number类型和Number类型的子类

```java
public class Test {
    public static void main(String[] args) {
        Point<Integer> point1=new Point<>(20);
        Point<Double>point2=new Point<>(20.0);
        print(point1);
        print(point2);
    }
    private static void print(Point<? extends Number> point){
        System.out.println(point);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127151439453.png)

如果设置为字符串类型就报错

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127151617710.png)



也可以在类声明出指定泛型的上限，一样的效果

```java
public class Point<T extends Number> {
    private T x;

    public T getX() {
        return x;
    }
```

### 下限

当使用的泛型只能在<u>本类及其父类类型上</u>使用时，就必须使用泛型的范围下限进行配置

**测试1**

```java
public class Test {
    public static void main(String[] args) {
        Point<String> point=new Point<>("温度");
        Point<Object> point1=new Point<>("天气");
        print(point);
        print(point1);
    }
    //只能接收String或Obiect类型的泛型
    private static void print(Point<? super String> point){
        System.out.println(point);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127154809960.png)

**测试2**

```java
public class Test {
    public static void main(String[] args) {
        Point<Integer> point=new Point<>(20);
        Point<Object> point1=new Point<>("天气");
        print(point);
        print(point1);
    }
    private static void print(Point<? super Integer> point){
        System.out.println(point);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127155036441.png)

可以看到在指定下限为Integer后，使用Object类型传递字符串也是可以的

**测试3**

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112715533271.png)

如果直接指定泛型类型是String类型或是Double类型就会报错

## 泛型与子类继承的限制

在普通方法里，一个子类可以通过对象的多态性为其父类实例化，但是在泛型操作中，子类的泛型类型无法使用父类的泛型类型接收

**测试1**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127155729249.png)

<u>虽然String类的父类是Object类，但是在泛型操作中这个概率无效，此时只能用通配符'?'接收</u>

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127160022557.png)

但是这样做的后果就是不能指定泛型的上限和下限了

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127160202690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127160315443.png)

只能只使用通配符的一般格式

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112716040350.png)

## 为什么在泛型中不能使用向上转型

`Point<Object> point2=new Point<Integer>(20);`

这样做的话相当于把泛型指定的范围扩大了，先开始泛型只是表示整型这个范围的数据，结果转换成了指定的是全部数据，所以程序编译不能通过

## 泛型接口

定义

```java
interface Person<T> {
      T getSome();
}
```

与普通接口的区别就是多了一个表示泛型的括号

**第一种方式：在子类的定义上声明泛型类型**

继承：在子类和父类后面都声明泛型类型

```java
//Person后面的括号可以省略，Demo不能省略
public class Demo<T> implements Person<T> {
    private T name;
    Demo(T name){
        this.name=name;
    }
    @Override
    public T getSome() {
        return null;
    }
    @Override
    public String toString() {
        return "Demo{" +
                "name=" + name +
                '}';
    }
}
```

实例化：通过子类实例化父类接口对象，并且指定明确的泛型类型

```java
public class Test {
    public static void main(String[] args) {
        Person<String> person=new Demo<>("大学");
        System.out.println(person);
    }
}
//输出：Demo{name=大学}
```

**第二种方式：直接在接口中指定具体类型**

```java
public class Demo implements Person<String> {
    private int age;

    Demo(int age){
        this.age=age;
    }

    @Override
    public String toString() {
        return "Demo{" +
                "age=" + age +
                '}';
    }
    @Override
    public String getSome() {
        return null;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Person<String> person=new Demo(20);
        System.out.println(person);
    }
}
```

因为在声明子类时已经明确的指定了具体的泛型类型，这样在实例化父类对象的时候就不需要在Demo类后面指定泛型对象了，而且<u>不仅不需要，指定了还会报错</u>

`Person<String> person=new Demo(20);`

这里省略Person后面的泛型指定也可以，系统照样运行，只是为了规范化，还是加上指定的泛型类型，也便于查看

## 泛型方法

在泛型方法中可以定义泛型参数

定义

```java
public class Demo{
    public <T> T fun(T t){
        return t;
    }
}
```

测试

```java
public class Test {
    public static void main(String[] args) {
        Demo d=new Demo();
        String str=d.fun("中国");
        int age=d.fun(70);
        System.out.println(str);
        System.out.println(age);
    }
}
//输出：中国 70
```

可以看出这个泛型方法可以接受任意类型的数据



**小结：**

在类后面加<T t>可以接收任何类型的类对象，在方法后面加<T t>可以接收任何类型的数据

## 使用泛型统一传入参数类型

```java
class Person<T extends Number> {
      private T weight;

      public void setWeight(T weight) {
            this.weight = weight;
      }

      @Override
      public String toString() {
            return "Person{" +
                    "weight=" + weight +
                    '}';
      }
}
```

测试：

```java
public class Test {
    public static void main(String[] args) {
        Person<Integer> person = fun(20);
        System.out.println(person);
    }

    private static <T extends Number> Person<T> fun(T param) {
        Person<T> person = new Person<>();
        person.setWeight(param);
        return person;
    }
}
//输出：Person{weight=20}
```

解释：首先在设计Person类时就规定了泛型的上限，只能传递数字类型的数据

在测试的时候实例化Person规定泛型类型为整型，重点是fun()函数，这个函数是为了得到Person类的实例对象，而Person<T>就是返回类型，所以在规定泛型时也是设置为<T extends Number>，这是泛型类型允许的区间，接着是函数名，函数名后的参数由传入的参数类型决定

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127171101152.png)

在传入的参数不是整型的时候就会报错，说明这个函数会进行类型推断，也就是说在传入参数后就会判断20.0是不是整数，那么为什么会发生这个推断呢，函数并没有运行啊！

原因就在于` Person<Integer> person`这一行语句，<u>在传入Integer后Person类里的T就等于Integer，fun里面的类型T也都等于Integer了，然后系统就会自己进行类型推断，</u>

## 使用泛型统一传入的参数类型

如果有一个方法与要求传入的泛型对象的泛型类型是一致的，也可以通过泛型方法指定

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127172958405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

## 泛型数组

```java
public class Test
{
    public static void main(String args[]){
        //返回泛型数组
        Integer i[]=fun(1,2,3,4,5,6);
        //输出数组内容
        fun2(i);
    }

    //接收可变参数，返回泛型数组
    public static <T> T[] fun(T...arg){
        return arg;
    }

    public static <T> void fun2(T param[]){
        System.out.println("接收泛型数组：");
        for (T t : param )
        {
            System.out.print(t+"、");
        }

    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127173712880.png)

## 泛型的嵌套设置

```java
class Info<T,V>
{
    private T var;
    private V value;
    public Info(T var,V value){
        this.setVar(var);
        this.setValue(value);
    }
     public T getVar(){
        return var;
     }

     public void setVar(T var){
        this.var=var;
     }

     public V getValue(){
        return value;
     }

     public void setValue(V value){
        this.value=value;
     }
}

class Demo<S>
{
    private S info;

    public Demo(S info){
        this.setInfo(info);
    }

    public S getInfo(){
        return info;
    }

    public void setInfo(S info){
        this.info=info;
    }
}


public class  GeneriseDemo31
{
    public static void main(String args[]){
        Demo<Info<String,Integer>> d=null;
        Info<String,Integer> i=null;
        i=new Info<String,Integer>("凹凸",22);
        d=new Demo<Info<String,Integer>>(i);
        System.out.println("1."+d.getInfo().getVar());
        System.out.println("2."+d.getInfo().getValue());
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127173807821.png)

## 泛型应用

 【定义标识接口–信息】 

```java
interface Info
{
    //定义一个标识接口，此接口没有定义任何方法
}
```

 【定义第一个类–联系方式】 

```java
class Contact implements Info
{
    private String address;
    private String telphone;
    public Contact(String address,String telphone){
        this.setAddress(address);
        this.setTelphone(telphone);
    }
    public String getAddress(){
        return this.address;
    }
    public void setAddress(String address){
        this.address=address;
    }

    public String getTelphone(){
        return this.telphone;
    }

    public void setTelphone(String telphone){
        this.telphone=telphone;
    }

    public String toString(){
        return "联系方式："+"\n"+
            "\t|--联系地址："+this.address+
            "\t|--联系电话："+this.telphone;
    }
}
```

 【定义第二个类–个人信息】 

```java
class Introduce implements Info
{
    private String name;
    private int age;
    public Introduce(String name,int age){
        this.setName(name);
        this.setAge(age);
    }
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name=name;
    }

    public int getAge(){
        return age;
    }

    public void setAge(int age){
        this.age=age;
    }

    public String toString(){
        return "个人信息："+"\n"+
            "\t|--姓名："+this.name+
            "\t|--年龄："+this.age;
    }
}
```

 【定义Person类，使用泛型】 

```java
class Person<T extends Info>
{
    private T info;
    public Person(T info){
        this.setInfo(info);
    }
    public T getInfo(){
        return this.info;
    }
    public void setInfo(T info){
        this.info=info;
    }

    public String toString(){
        return this.info.toString();
    }
}
```

【测试】 

```java
public class Test
{
    public static void main(String args[]){
        //声明Person对象，同时指定Contact类型
        Person<Contact> per=null;
        per=new Person<Contact>(new Contact("中国","111111"));
        System.out.println(per);

        //声明Person对象，同时指定Introduce类型
        Person<Introduce> per2=null;
        per2=new Person<Introduce>(new Introduce("凹凸",20));
        System.out.println(per2);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127174058301.png)

