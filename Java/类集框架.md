# 为什么要用类集框架

**认识：**

在开发过程中，常常需要集中存放多个数据。我们知道，数组可以实现这个功能。但是，数组的长度是固定的，如果我们存放的数据数量是动态变化的该怎么办？这个时候，就要用到Java的集合类了。 

所有的集合都位于`java.util`包下。Java集合类有两个主要的接口：Collection和Map。他们是集合的根接口。在集合中，Map结尾的类实现了Map接口，而其他的集合类实现了Collection接口。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112817250429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

-  Collection是一个接口，它包含了集合的基本操作和属性。分为了List和Set两大分支。其中，List是一个有序的队列，其中的元素不唯一。而Set是一个无序的集合，其中的元素是唯一的 
-  List的实现类有`ArrayList`、`LinkedList`、`Vector`及`Stack`。 

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128173013913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

-  Set的实现类有`HashSet`、`TreeSet`、`LinkedHashSet`及`EnumSet`。 

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128173207594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

- Map也是一个接口，而且是一个映射接口，值以键值对(key-value)的形式存储。实现类有`EnumMap`、`HashMap`、`TreeMap`、`WeakHaskMap`、`ConcurrentHashMap`及`IdentityHashMap`。
-  `Iteator`(迭代器)是一个用来遍历集合的工具，我们可以看到Collection接口就依赖于`Iterabe`接口，所以，在Collection的实现类中可以使用Iterator来遍历元素。 

# 一、List接口

## `ArrayList`

**测试1**

```java
public class Test {
    public static void main(String[] args) {
        List<String>list=null;
        list=new ArrayList<>();
        list.add("Hello");
        list.add(0,"World");
        list.add(0,"come on");
        System.out.println(list);
        System.out.println(list.get(2));
        //返回的是删除的数据,也可以指定删除的对象
        //list.remove("Hello");
        System.out.println(list.remove(2));
        System.out.println(list);
        //判断World是否存在
        System.out.println(list.contains("World"));
        //返回大小
        System.out.println(list.size());
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128174330407.png)

**add方法:**`void add(int index, E element);`

从输出可以看出add在指定位置添加`come on`时即使是添加到同一个位置也不会覆盖之前的`world`，而是将之前的`world`向后移动一个位置

- `ArrayList`是一个**动态数组**，也是我们最常用的集合。它**允许任何符合规则的元素插入甚至包括null**。每一个`ArrayList`都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以**如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。** 

> **`ArrayList`擅长于随机访问。同时`ArrayList`是非同步的。** 

```java
List<String>list=null;
list=new ArrayList<>(5);
```

在小括号里面指定数组的初始大小

## `LinkedList`

表示的是一个链表的操作类

```java
package my;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        LinkedList<String> list=new LinkedList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        list.add("D");
        System.out.println("生成链表输出：");
        System.out.println(list);
        //在链表的表头和表尾增加数据
        list.addFirst("X");
        list.addLast("Y");
        System.out.println("增加表头和表尾:"+list);
        System.out.println("找到表头:"+list.element());
        System.out.println(list);
        System.out.println("找不到删除表头:"+list.peek());
        System.out.println(list);
        System.out.println("找到并删除表头:"+list.poll());
        System.out.println(list);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128180843816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

 **peek()和element()有什么区别 ？**

 peek()，如果链表为空，则返回null。element()，如果链表为空，则抛异常。 

**介绍：**

同样实现List接口的`LinkedList`与`ArrayList`不同，`LinkedList`是一个双向链表。所以它除了有`ArrayList`的基本操作方法外还额外提供了get，remove，insert方法在`LinkedList`的首部或尾部。

由于实现的方式不同，**`LinkedList`不能随机访问，它所有的操作都是要按照双重链表的需要执行**。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。

与`ArrayList`一样，`LinkedList`也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。

**测试1：实现对列操作（先进先出FIFO）**

```java
LinkedList<String> list=new LinkedList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        System.out.println(list.size());
        int i=0;
        while (!list.isEmpty()){
            System.out.println(list.poll());
            i++;
        }
        System.out.println(i);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128182754515.png)

**测试2：用for循环再测试**

```java
 LinkedList<String> list=new LinkedList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        int j=0;
        System.out.println(list.size());
        for (int i=0;i<list.size();i++){
            System.out.println(list.poll());
            j++;
        }
        System.out.println(j);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128183008372.png)

从输出看到链表的长度本来是3的，却只循环了两次就退出了，即使改为`i<list.size()+1`也是只循环了两次，很奇怪，一定要改为`i<list.size()+2`才会完整输出！

**测试3：**

```java
        LinkedList<String> link = new LinkedList<>();
        link.add("A");
        link.add("B");
        link.add("B");
        link.add("C");
        link.add("C");
        System.out.println("初始化：" + link);
        link.addFirst("X");
        link.addLast("Y");
        System.out.println("初始化之后：" + link);
        System.out.println("找表头并删除：" + link.poll());
        System.out.println("按顺序输出：");
        for (int i = 0; i <= link.size() + 1; i++) {
            System.out.print(link.poll() + "、");
        }
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128183554486.png)

增加两个C 

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128183859287.png)

输出：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128183939700.png)

再多添加一个C，输出为A、B 、B、C、C、C

**问题解决：**

**用for遍历的方法总是不能完全输出来，因为每次在使用poll()方法后size的长度都会减少**

```java
 LinkedList<String> list=new LinkedList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        int j=0;
        System.out.println(list.size());
        for (int i=0;i<list.size();i++){
           System.out.println("poll()使用前list的长度："+list.size()+" "+"i="+i);
            System.out.println(list.poll());
            System.out.println("使用后list的长度："+list.size()+" "+"i="+i);
            j++;
        }
        System.out.println(j);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112818490599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

所以在循环两次之后循环就结束了，最好使用while循环并判断链表是否为空的方法输出对列

