# 多线程

## 进程和多进程

- <u>一个进程对应一个应用程序</u>。在`java`的开发环境下启动`JVM`，就表示启动了一个进程。在同一个操作系统中，可以启动多个进程

- 对于单核计算机来讲，在同一个时间点上运行了游戏进程和音乐进程，但实际二者并不是同时运行
  而<u>计算机的CPU在某个时间点上只能做一件事，所以计算机在 游戏进程 和 音乐进程 之间频繁的切换执行，由于切换速度极高，所以人类感觉两者在同时进行</u>

- 多进程的作用不是提高执行速度，而是提高CPU的使用率

- 进程和进程之间的内存是独立的

## 线程和多线程

- 线程是一个进程中的执行场景。一个进程可以启动多个线程
- 多线程作用不是为了提高执行速度，而是提高应用程序的使用率
- 线程和线程共享“堆内存和方法区内存”，栈内存是独立的，一个线程一个栈
- <u>由于多线程在来回切换，所以给现实世界中的人类一种错觉：感觉多个线程在同时并发执行</u>

## 线程安全和不安全

### 定义

假设A和B同时去不同ATM上取同一张卡的1000块钱，如果是线程不安全，那么A和B可以同时取到1000块钱（两人赚大发啦），而如果线程安全呢，就只有一个人能取出来1000块钱。

线程安全是指多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的，不存在执行结果的二义性。

线程不安全就是不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据

### 线程安全的决定因素

线程安全问题都是由全局变量及静态变量引起的。
若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 

###  **解决多线程并发访问资源的安全问题** 

 有三种方式：分别是 同步代码块 、同步方法和锁机制(Lock) 

## Java程序的运行原理

 `java`命令会启动`JVM`，等于启动了一个应用程序即进程，该进程会自动启动一个主线程，然后主线程去调用某个类的main方法，所以main方法运行在主线程中 

## 实现多线程 

两种方式：

**第一种：**

- 继承 `java.lang.Thread`
- 重写 run 方法

Thread源码

```java
class Thread implements Runnable {
              ...
                 
public synchronized void start() {
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
        /* 
           通知组此线程即将启动
           以便可以将其添加到组的线程列表中
           该组的未开始计数可以减少。. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* 什么也不做。如果start0抛出一个投掷物
                   它将通过调用堆栈传递 */
            }
        }
    }
    private native void start0();
}
```

### synchronized 

看到start()方法有个 synchronized 关键词修饰

**synchronized 关键词的作用是什么？**

在`java`中，免不了为了提升效率而使用多线程，而使用了多线程，就可能会出现线程不安全，导致数据错误等结果，在这种情况下，为了防止多线程下线程不安全，就会采用synchronized（当然也有其他方法），<u>使用synchronized的关键就是线程对象会获取锁，在一个线程拥有锁的情况下，另一个线程只能等待，直到第一个线程释放了锁才能进入被synchronized修饰的方法</u>，而锁又分为类锁和对象锁



 **一个类的对象锁和另一个类的对象锁是没有关联的，当一个线程获得A类的对象锁时，它同时也可以获得B类的对象锁。** 

打个比方：一个object就像一个大房子，大门永远打开。房子里有 很多房间（也就是方法）。

这些房间有上锁的（synchronized方法）， 和不上锁之分（普通方法）。房门口放着一把钥匙（key），这把钥匙可以打开所有上锁的房间。

另外我把所有想调用该对象方法的线程比喻成想进入这房子某个 房间的人。所有的东西就这么多了，下面我们看看这些东西之间如何作用的。

在此我们先来明确一下我们的前提条件。该对象至少有一个synchronized方法，否则这个key还有啥意义。当然也就不会有我们的这个主题了。

一个人想进入某间上了锁的房间，他来到房子门口，看见钥匙在那儿（说明暂时还没有其他人要使用上锁的房间）。于是他走上去拿到了钥匙，并且按照自己 的计划使用那些房间。注意一点，<u>他每次使用完一次上锁的房间后会马上把钥匙还回去。即使他要连续使用两间上锁的房间，中间他也要把钥匙还回去，再取回来</u>。

因此，<u>普通情况下钥匙的使用原则是：“随用随借，用完即还</u>。”

<u>这时其他人可以不受限制的使用那些不上锁的房间，一个人用一间可以，两个人用一间也可以，没限制。但是如果当某个人想要进入上锁的房间，他就要跑到大门口去看看了。有钥匙当然拿了就走，没有的话，就只能等了。</u>

<u>要是很多人在等这把钥匙，等钥匙还回来以后，谁会优先得到钥匙？Not guaranteed。像前面例子里那个想连续使用两个上锁房间的家伙，他中间还钥匙的时候如果还有其他人在等钥匙，那么没有任何保证这家伙能再次拿到</u>。 （JAVA规范在很多地方都明确说明不保证，像`Thread.sleep()`休息后多久会返回运行，相同优先权的线程那个首先被执行，当要访问对象的锁被释放后处于等待池的多个线程哪个会优先得到，等等。我想最终的决定权是在`JVM`，之所以不保证，就是因为`JVM`在做出上述决定的时候，绝不是简简单单根据 一个条件来做出判断，而是根据很多条。而由于判断条件太多，如果说出来可能会影响JAVA的推广，也可能是因为知识产权保护的原因吧。SUN给了个不保证 就混过去了。无可厚非。但我相信这些不确定，并非完全不确定。因为计算机这东西本身就是按指令运行的。即使看起来很随机的现象，其实都是有规律可寻。学过 计算机的都知道，计算机里随机数的学名是伪随机数，是人运用一定的方法写出来的，看上去随机罢了。另外，或许是因为要想弄的确太费事，也没多大意义，所 以不确定就不确定了吧。）

再来看看同步代码块。和同步方法有小小的不同。

1. 从尺寸上讲，同步代码块比同步方法小。你可以把同步代码块看成是没上锁房间里的一块用带锁的屏风隔开的空间。

2. 同步代码块还可以人为的指定获得某个其它对象的key。就像是指定用哪一把钥匙才能开这个屏风的锁，你可以用本房的钥匙；你也可以指定用另一个房子的钥匙才能开，这样的话，你要跑到另一栋房子那儿把那个钥匙拿来，并用那个房子的钥匙来打开这个房子的带锁的屏风。

​     记住你获得的那另一栋房子的钥匙，并不影响其他人进入那栋房子没有锁的房间。

​     为什么要使用同步代码块呢？我想应该是这样的：首先对程序来讲同步的部分很影响运行效率，而一个方法通常是先创建一些局部变量，再对这些变量做一些 操作，如运算，显示等等；而同步所覆盖的代码越多，对效率的影响就越严重。因此我们通常尽量缩小其影响范围。

如何做？同步代码块。我们只把一个方法中该同步的地方同步，比如运算。

​     另外，同步代码块可以指定钥匙这一特点有个额外的好处，是可以在一定时期内霸占某个对象的key。还记得前面说过普通情况下钥匙的使用原则吗。现在不是普通情况了。你所取得的那把钥匙不是永远不还，而是在退出同步代码块时才还。

​     还用前面那个想连续用两个上锁房间的家伙打比方。怎样才能在用完一间以后，继续使用另一间呢。用同步代码块吧。先创建另外一个线程，做一个同步代码 块，把那个代码块的锁指向这个房子的钥匙。然后启动那个线程。只要你能在进入那个代码块时抓到这房子的钥匙，你就可以一直保留到退出那个代码块。也就是说 你甚至可以对本房内所有上锁的房间遍历，甚至再sleep(10*60*1000)，而房门口却还有1000个线程在等这把钥匙呢。很过瘾吧。

### native

在`start0()`方法前有一个native关键字

1. native 是用做`java `和其他语言（如c++）进行协作时用的也就是native 后的函数的实现不是用`java`写的

2. 既然都不是`java`，就不用管它的源代码了

3. native的意思就是通知操作系统，这个函数你必须给我实现，因为我要使用。所以native关键字的函数都是操作系统实现的，`java`只能调用。

4. `java`是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而`java`要实现对底层的控制，就要一些其他语言的帮助，这个就是native的作用了

5. `java`不是完美的，`java`的不足除了体现在运行速度上要比传统的C++慢许多之外，Java无法直接访问到操作系统底层（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。

### 第一种Thread类

这是Thread类里的run()方法，必须覆写

```java
  @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
```

1.继承 2.覆写

```java
class MyThread extends Thread{
    public void run(){
        for(int i=0;i<5;i++){
            //打印当前线程名
            System.out.println("run()方法线程:"+Thread.currentThread().getName()+"  "+i);
        }
        }
}
```

```java
public class Demo {
    public static void main(String[] args){
        MyThread mt1=new MyThread();
        MyThread mt2=new MyThread();
        //打印当前线程名
        System.out.println("main函数线程名字:"+Thread.currentThread().getName());
        //调用
        mt1.run();
        mt2.run();
    }
}
```

![1](https://github.com/superlkl/MyNotes/blob/master/pictures/1.png)

从输出看到线程并没有开启，还是主函数在执行run()方法的操作，一个线程对象执行完之后才执行的另一个对象

修改

```java
mt1.start();
mt2.start();
```

![image-20191103144329069](https://github.com/superlkl/MyNotes/blob/master/pictures/2.png)

可以看到在主线程开启后例外开启了两个线程

这里的线程名是按数字增加的,可以的得知肯定有一个static类型的静态属性用于为线程自动命名

取得当前线程的源码也是静态的，所以可以由Thread类直接调用

```java
 public static native Thread currentThread();
```

`getName()`方法是不能被覆写的

```java
public final String getName() {
        return name;
    }
```

**为何调用的是start()方法而不是run()方法**

**线程的运行需要本机操作系统的支持**

start()里还有一个`start0()`函数被native关键字修饰，表示调用本机的操作系统函数，多线程的实现需要依靠底层操作系统的支持



1. start()用来启动一个线程，当调用start()方法时，系统才会开启一个线程，<u>通过`Thead`类中start()方法来启动的线程处于就绪状态（可运行状态），此时并没有运行，一旦得到CPU时间片，就自动开始执行run()方法。</u>此时不需要等待run()方法执行完也可以继续执行下面的代码，所以也由此看出run()方法并没有实现多线程。 

2. run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。

3. 把需要处理的代码放到run()方法中，start()方法启动线程将自动调用run()方法，这个由`java`的内存机制规定的。并且run()方法必需是public访问权限，返回值类型为void。

4. 当程序调用start方法一个新线程将会被创建，并且在run方法中的代码将会在新线程上运行

**注意事项**

如果是依靠继承Thread类来开启多线程，那么一个线程对象就只能调用一次start()方法

```java
mt1.start();
mt1.start();
mt2.start();
```

![image-20191103145518026](https://github.com/superlkl/MyNotes/blob/master/pictures/3.png)

调用第二次就会报错了

```java
class Thread implements Runnable {
              ...
public synchronized void start() {
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
            ...
}
```

抛出`IllegalThreadStateException`异常

### 第二种Runnable接口

接口定义

```java
public interface Runnable {
    public abstract void run();
}
```

里面就一个run()方法，Thread类也继承了这个接口，所以实现了这个方法

```java
public class MyThreadTwo implements Runnable{
    @Override
    public void run() {
        for(int i=0;i<5;i++){
            //打印当前线程名
            System.out.println("run()方法线程:"+Thread.currentThread().getName()+"  "+i);
        }
    }
}
```

```java
  public static void main(String[] args)  {
      //打印当前线程名
        System.out.println("main函数线程名字:"+Thread.currentThread().getName());
      //实例化Runnable子类实例
        MyThreadTwo mtt1=new MyThreadTwo();
        MyThreadTwo mtt2=new MyThreadTwo();
      //实例化Thread类对象
        Thread t1=new Thread(mtt1,"线程一");
        Thread t2=new Thread(mtt2,"线程二");
      //开启线程
        t1.start();
        t2.start();
    }
```

用接口的方式开启线程和继承Thread类开启有一些区别，但无论哪种方式，都必须依靠Thread类才能够启动线程

![image-20191103150731555](https://github.com/superlkl/MyNotes/blob/master/pictures/4.png)

**给线程设置名字**

```java
 Thread t1=new Thread(mtt1,"线程一");
```

Thread类源码

```java
  public Thread(Runnable target, String name) {
        init(null, target, name, 0);
    }
```

可以看到里面有个构造函数传入接口对象和字符串就可以给线程设置名字

### 两种方式的区别

使用接口可以实现资源共享

情景：总共有五张票，让三个人去卖

**Thread类实现**

```java
class MyThread extends Thread {
    private int ticket = 5;
    @Override
    public void run() {
        for (int i = 0; i < 6; i++) {
            if (this.ticket > 0) {
                System.out.println(Thread.currentThread().getName() + "   "+this.ticket--);
            }
        }
    }
}
```

```java
 public static void main(String[] args)  {
        System.out.println("main函数线程名字:"+Thread.currentThread().getName());
        MyThread mt1 = new MyThread();
        MyThread mt2 = new MyThread();
        MyThread mt3 = new MyThread();
        mt1.start();
        mt2.start();
        mt3.start();
    }
```

![image-20191103151218902](https://github.com/superlkl/MyNotes/blob/master/pictures/5.png)

三个人各卖各自的票，相当于卖了15张票

**Runnable接口实现**

```java
public class MyThreadTwo implements Runnable{
    private int ticket = 5;
    @Override
    public void run() {
        for (int i = 0; i < 6; i++) {
            if (ticket > 0) {
                System.out.println(Thread.currentThread().getName() + "   "+ticket--);
            }
        }
    }
}
```

```java
public static void main(String[] args)  {
        System.out.println("main函数线程名字:"+Thread.currentThread().getName());
        //实例化接口子类对象
        MyThreadTwo mtt1=new MyThreadTwo();
        //将对象进行封装
        Thread mt1 = new Thread(mtt1,"线程一");
        Thread mt2 = new Thread(mtt1,"线程二");
        Thread mt3 = new Thread(mtt1,"线程三");
        mt1.start();
        mt2.start();
        mt3.start();
```

![image-20191103152514494](https://github.com/superlkl/MyNotes/blob/master/pictures/6.png)

三个人实现了资源共享，一共就卖了5票

实例化一个接口子类对象，再通过这个接口子类实例化其他Thread类对象就可以开启一个线程实现资源共享

**Runnable接口实现多线程的优势**

1. 避免了继承Thread类的单继承的局限性。
2. Runnable接口出现更符合面向对象，**将线程单独进行对象的封装**。
3. Runnable接口出现，降低了线程对象和线程任务的耦合性。所以创建线程的方式都使用Runnable接口。

### 线程的状态

1. **新建(NEW)**：新创建了一个线程对象。

2. **可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取`cpu` 的使用权 。

3. **运行(RUNNING)**：可运行状态(runnable)的线程获得了`cpu` 时间片（`timeslice`） ，执行程序代码。
4. **阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了`cpu` 使用权，也即让出了`cpu timeslice`，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得`cpu timeslice` 转到运行(running)状态。阻塞的情况分三种： 

> **(一). 等待阻塞：运行(running)的线程执行`o.wait()`方法，`JVM`会把该线程放入等待队列(`waitting queue`)中。**
> **(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则`JVM`会把该线程放入锁池(lock pool)中。**
> **(三). 其他阻塞：运行(running)的线程执行`Thread.sleep(long ms)`或`t.join()`方法，或者发出了I/O请求时，`JVM`会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。**

5. **死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

### 线程操作

**判断线程是否启动**

```java
System.out.println("main函数线程名字:"+Thread.currentThread().getName());
            MyThreadTwo mtt1=new MyThreadTwo();
            Thread mt1 = new Thread(mtt1,"线程一");
            Thread mt2 = new Thread(mtt1,"线程二");
            Thread mt3 = new Thread(mtt1,"线程三");
        //启动就返回true,否则返回false
        System.out.println(mt1.getName()+mt1.isAlive());
            mt1.start();
            mt2.start();
            mt3.start();
        System.out.println(mt1.getName()+mt1.isAlive());
```

![image-20191103155211847](https://github.com/superlkl/MyNotes/blob/master/pictures/7.png)

**也可以设置线程名**

```java
Thread.currentThread().setName("哈哈");
System.out.println(Thread.currentThread().getName());
//输出：哈哈
```

`setName()`函数是没有返回值的

```java
 public final synchronized void setName(String name) {
        checkAccess();
        if (name == null) {
            throw new NullPointerException("name cannot be null");
        }

        this.name = name;
        if (threadStatus != 0) {
            setNativeName(name);
        }
    }
```

`getName()`函数有返回值

```java
public final String getName() {
        return name;
    }
```

**设置线程的优先级**

设置方法源码

```java
public final void setPriority(int newPriority) {
        ThreadGroup g;
        checkAccess();
        if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
            throw new IllegalArgumentException();
        }
        if((g = getThreadGroup()) != null) {
            if (newPriority > g.getMaxPriority()) {
                newPriority = g.getMaxPriority();
            }
            setPriority0(priority = newPriority);
        }
    }
```

使用过程

```java
class MyThread implements Runnable{
    public void run(){
    for (int i=0;i<100;i++) {
        System.out.println(Thread.currentThread().getName()+"运行");
    }
    }
}
```

```java
 public static void main(String[] args)  {
           MyThread mt=new MyThread();
           Thread t1=new Thread(mt,"线程A");
           Thread t2=new Thread(mt,"线程B");
          t1.setPriority(Thread.MIN_PRIORITY);
          t2.setPriority(Thread.MIN_PRIORITY);
          t1.start();
          t2.start();
    }
```

![image-20191105183138538](https://github.com/superlkl/MyNotes/blob/master/pictures/8.png)

如果没有设置优先级

```java
public static void main(String[] args)  {
        MyThread mt=new MyThread();
        Thread t1=new Thread(mt,"线程A");
        Thread t2=new Thread(mt,"线程B");
        t1.start();
        t2.start();
    }
```

![image-20191105183225464](https://github.com/superlkl/MyNotes/blob/master/pictures/9.png)

| 定义                                       | 描述                     |
| ------------------------------------------ | ------------------------ |
| public static final int MIN_PRIORITY = 1;  | 线程可以拥有的最小优先级 |
| public static final int NORM_PRIORITY = 5; | 分配给线程的默认优先级   |
| public static final int MAX_PRIORITY = 10; | 线程可以拥有的最高优先级 |

### 强制执行

```java
public final void join() throws InterruptedException {
        join(0);
    }
```

 join() 方法会使当前线程等待调用 join() 方法的线程结束后才能继续执行 

```java
public class MyThreadTwo implements Runnable{
    private int ticket = 20;
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            if (ticket > 0) {
                System.out.println(Thread.currentThread().getName() + "   "+ticket--);
            }
        }
    }
}

```

```java
public static void main(String[] args)  {
            System.out.println("main函数线程名字:"+Thread.currentThread().getName());
            MyThreadTwo mtt1=new MyThreadTwo();
            Thread mt1 = new Thread(mtt1,"线程一");
            mt1.start();
            for (int i=0;i<20;i++){
                if (i>10){
                    try {
                        
                        //强制执行
                        mt1.join();
                        
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(Thread.currentThread().getName()+"执行");
            }
    }
```

输出片段

![image-20191103160005266](https://github.com/superlkl/MyNotes/blob/master/pictures/10.png)

​                                    。。。。。。。。。。。。。。。。。。。。。。

![https://github.com/superlkl/MyNotes/blob/master/pictures/11.png)

可以看出如果在start方法后还有程序要执行，子线程是抢不赢主线程的，在加入join()方法后可以强制得到`cpu`的使用权来执行

### 线程的休眠

```java
public static native void sleep(long millis) throws InterruptedException;
//静态方法
```

sleep() 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，<u>进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会</u>。但是 sleep() 方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。 

100张票，每隔0.02秒卖一张

```java
class MyThread implements Runnable{
    private int ticket = 100;
    public void run(){
        for(int i=0; i<100; i++){
      
                if (ticket > 0) {
                    try {
                        Thread.sleep(20);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() +
                            "还剩下" + this.ticket-- + "票");
                }

        }
    }
}

```

如果是一个人卖票

```java
public static void main(String[] args)  {
           MyThread mt= new MyThread();
           Thread th1 = new Thread(mt,"黄牛1");
           th1.start();
    }
```

![image-20191104210826500](https://github.com/superlkl/MyNotes/blob/master/pictures/12.png)

如果是三个人卖票

```java
  public static void main(String[] args) {
           MyThread mt= new MyThread();
           Thread th1 = new Thread(mt,"黄牛1");
           Thread th2 = new Thread(mt,"黄牛2");
           Thread th3 = new Thread(mt,"黄牛3");
           th1.start();
           th2.start();
           th3.start();
    }
```

![image-20191104210634500](https://github.com/superlkl/MyNotes/blob/master/pictures/13.png)

发现竟然出现了负数的情况，还有相等的情况，why？

因为程序中加入了延迟操作，所以在运行到最后的时候出现了负数情况

票数操作步骤：

1. 判断票数是否大于0，如果大于0就表示还有票可以卖
2. 如果票数大于0就卖票出去

但是在步骤1和2之间加入了延迟操作，那么一个线程就有可能在还没有对票数进行减操作之前其他线程就已经将票数减少了，因此出现了票数为负的情况

#### 同步

**解决：**使用同步，多个操作在同一时间段内只能有一个线程运行，其他线程要等待此线程完成之后才可以继续执行

第一种：同步代码块

```java
class MyThread implements Runnable{
    private int ticket = 100;
    public void run(){
        for(int i=0; i<100; i++){
            
            //同步代码块
            synchronized (this) {
                if (ticket > 0) {
                    try {
                        Thread.sleep(20);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() +
                            "还剩下" + this.ticket-- + "票");
                }
            }
        }
    }
}
```

同步代码块

```java
 synchronized (同步对象){....}
```

第二种：同步方法

```java
class MyThread implements Runnable{
    private int ticket = 100;
    public void run(){
        for(int i=0; i<100; i++){
            this.sale();
        }
    }
    //同步方法
    private synchronized void sale(){
        if (ticket > 0) {
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() +
                    "还剩下" + this.ticket-- + "票");
        }
    }
}
```

![image-20191104211659386](https://github.com/superlkl/MyNotes/blob/master/pictures/14.png)

#### 锁对象

  synchronized（this）以及普通的synchronized方法，只能防止多个线程同时执行同一个对象的同步段。synchronized锁的是括号中的对象而非代码段。

```java
class Sync {
    //锁的是this当前对象
    public synchronized void test(){
        System.out.println(Thread.currentThread().getName()+"方法开始...");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+"方法结束");
    }
}

```

```java
class MyThread implements Runnable{
    public void run(){
        Sync sync = new Sync();
        //sync，线程0
        //sync，线程1
        //sync，线程2
        //三个线程各有各的run方法，各锁各的sync，所以锁不住
        sync.test();
    }
}
```

```java
 public static void main(String[] args)  {
           MyThread mt= new MyThread();
           for(int i=0; i<3; i++){
                  new Thread(mt,"线程"+i).start();
           }
    }
```

![image-20191104212030741](https://github.com/superlkl/MyNotes/blob/master/pictures/15.png)

从结果可以看到 synchronized没有起到作用，三个线程同时运行test（）方法 

**修改**: 锁同一个对象 

```java
class MyThread implements Runnable{
    private Sync sync;
    public MyThread(Sync sync) {
        this.sync = sync;
    }
    public void run(){
        //现在只有一个sync所以一定可以锁得住
        sync.test();
    }
}
```

```java
public static void main(String[] args)  {
           Sync sync = new Sync();
           MyThread mt= new MyThread(sync);
           for(int i=0; i<3; i++){
                  new Thread(mt,"线程"+i).start();
           }
    }
```

![image-20191104212541567](https://github.com/superlkl/MyNotes/blob/master/pictures/16.png)

### 线程礼让

```java
public static native void yield();
//静态方法
```

yield() 方法和 sleep() 方法类似，也不会释放“锁标志”，区别在于，它没有参数，即 yield() 方法只是使当前线程重新回到可执行状态，所以执行 yield() 的线程有可能在进入到可执行状态后马上又被执行，另外 yield() 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep() 方法不同。 

```java
class MyThread implements Runnable{
    public void run(){
    for (int i=0;i<5;i++) {
        System.out.println(Thread.currentThread().getName()+"运行");
        if (i == 3) {
            System.out.print("线程礼让:");
            Thread.yield();
        }
    }
  }
}
```

```java
public static void main(String[] args)  {
           MyThread mt=new MyThread();
           new Thread(mt,"线程A").start();
           new Thread(mt,"线程B").start();
    }
```

![image-20191104215827139](https://github.com/superlkl/MyNotes/blob/master/pictures/17.png)

当线程条件满足i=3时就会让其他线程先执行，因为执行的速度太快就出现了两次礼让

> **两个线程是在急速的来回切换的，在一个线程的run()方法结束后马上切换到另一个线程，而在线程A执行到i=3切结束run()方法后,i要在内存空间里面加1，但i修改数据的速度小于线程切换运行的速度，所以线程B执行的时候i还是等于3，线程B又运行两次后i的值才更新结束**

### 中断线程

#### `interrupt()`

```java
 public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }
```

interrupt()其作用是中断此线程（此线程不一定是当前线程，而是指调用该方法的Thread实例所代表的线程），但<u>实际上只是给线程设置一个中断标志，**线程仍会继续运行** 。需要用户自己去监视线程的状态为并做处理</u>。 

```java
class MyThread implements Runnable {


    public void run() {
    for (int i=0;i<100;i++) {
        String name=Thread.currentThread().getName();
        System.out.println(name+"运行");
        try {
            System.out.println("休眠之前");
            Thread.sleep(10000);
            System.out.println("休眠之后");
            System.out.println(name+"try"+Thread.currentThread().isInterrupted());

        } catch (InterruptedException e) {
            e.printStackTrace();
            System.out.println("休眠被终止");
            System.out.println(name+"catch"+"  "+Thread.currentThread().isInterrupted());
            return;
        }
    }
    }
}


```

```java
public static void main(String[] args)  {
        String name=Thread.currentThread().getName();
        MyThread mt=new MyThread();
        Thread t1=new Thread(mt,"线程A");
        t1.start();
        System.out.println("main函数线程名："+name);
        try {
            Thread.sleep(2000);
        } catch (Exception e) {
            e.printStackTrace();
        }
        t1.interrupt();
    }
```

![image-20191105192109659](https://github.com/superlkl/MyNotes/blob/master/pictures/18.png)

**红色的那段代码就是`MyThread`类里抛出的`InterruptedException`异常**

**interrupt()方法总结**

如果不会中断sleep，wait，join方法或文档描述的其他情况，就<u>不会抛`InterruptException`异常，就不会清除中断标志位</u>，`isInterrupt()`返回true。

如果中断sleep，wait，join等，就会抛`InterruptException`异常，就会清除中断标志位，`isInterrupt()`返回false

####  **`interrupted()`方法** 

```java
public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }
```

作用是<u>测试当前线程是否被中断</u>（检查中断标志），返回一个boolean并清除中断状态，第二次再调用时中断状态已经被清除，将返回一个false 

####  **`isInterrupted()`方法** 

```java
public boolean isInterrupted() {
        return isInterrupted(false);
    }
```

 作用是只测试此线程是否被中断 ，不清除中断状态 

####  **测试** 

```java
public class MyThread extends Thread {
    @Override
    public  void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("i="+(i+1));
        }
    }
}


public class Demo {
    public static void main(String[] args)  {
        MyThread thread=new MyThread();
        thread.start();
        thread.interrupt();
        System.out.println("第一次调用thread.isInterrupted()："+thread.isInterrupted());
        System.out.println("第二次调用thread.isInterrupted()："+thread.isInterrupted());
    }
}
```

![image-20191105193524053](https://github.com/superlkl/MyNotes/blob/master/pictures/19.png)

从结果可以看出调用interrupt（）方法后，线程仍在继续运行，并未停止，但已经给线程设置了中断标志，两个`isInterrupted（）`方法都会输出true，也说明`isInterrupted（）`方法并不会清除中断状态。 

修改代码

```java
 public static void main(String[] args)  {
        MyThread thread=new MyThread();
        thread.start();
        thread.interrupt();
        System.out.println("第一次调用thread.isInterrupted()："+thread.isInterrupted());
        System.out.println("第二次调用thread.isInterrupted()："+thread.isInterrupted());

        //测试interrupted（）函数
        System.out.println("第一次调用thread.interrupted()："+thread.interrupted());
        System.out.println("第二次调用thread.interrupted()："+thread.interrupted());
        System.out.println("thread是否存活："+thread.isAlive());

    }
```

![image-20191105193833406](https://github.com/superlkl/MyNotes/blob/master/pictures/20.png)

 <u>为什么后面两个interrupted方法输出的都是false，而不是预料中的一个true一个false？</u> 

这是一个坑！！！上面说到，interrupted（）方法<u>测试的是当前线程是否被中断</u>，当前线程！！！当前线程！！！<u>这里当前线程是main线程</u>，而`thread.interrupt(）`中断的是thread线程，这里的main线程就是thread线程。所以<u>当前线程main从未被中断过，尽管interrupted（）方法是以`thread.interrupted（）`的形式被调用，但它检测的仍然是main线程而不是检测thread线程</u>，所以`thread.interrupted（）`在这里相当于`main.interrupted`（）

**继续修改**

```java
public static void main(String[] args)  {
        Thread.currentThread().interrupt();
        System.out.println("第一次调用Thread.currentThread().interrupt()："
                +Thread.currentThread().isInterrupted());
        System.out.println("第一次调用thread.interrupted()："
                +Thread.currentThread().interrupted());
        System.out.println("第二次调用thread.interrupted()："
                +Thread.currentThread().interrupted());
    }
```

这里都是针对当前线程在操作，如果interrupted（）方法有检测中断并清除中断状态的作用，预料中的输出应该是true-true-false，实际输出如下： 

![image-20191105194449777](https://github.com/superlkl/MyNotes/blob/master/pictures/21.png)

结果证明猜想是正确的。

若果想要是实现调用interrupt（）方法真正的终止线程，则可以在线程的run方法中做处理即可，比如直接跳出run（）方法使线程结束，视具体情况而定

**具体例子测试：**

```java
public class MyThread extends Thread {
    @Override
    public  void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("i="+(i+1));
            if(this.isInterrupted()){
                System.out.println("通过this.isInterrupted()检测到中断");
                System.out.println("第一个interrupted()"+this.interrupted());
                System.out.println("第二个interrupted()"+this.interrupted());
                break;
            }
        }
        System.out.println("因为检测到中断，所以跳出循环，线程到这里结束，因为后面没有内容了");
    }
}


public class Demo {
    public static void main(String[] args) throws InterruptedException  {
        MyThread myThread=new MyThread();
        myThread.start();
        myThread.interrupt();
        //sleep等待一秒，等myThread运行完
        Thread.currentThread().sleep(1000);
        System.out.println("myThread线程是否存活："+myThread.isAlive());
    }
}
```

![image-20191105194818086](https://github.com/superlkl/MyNotes/blob/master/pictures/22.png)

**最后总结:**

- 关于这三个方法，`interrupt（）`是给线程设置中断标志；

- `interrupted（）`是检测中断并清除中断状态；

- `isInterrupted（）`只检测中断。

- 还有重要的一点就是`interrupted（）`作用于当前线程，`interrupt（）`和`isInterrupted（）`作用于此线程，**即代码中调用此方法的实例所代表的线程**。
  

继续修改

```java
public class MyThread extends Thread {
    @Override
    public  void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("i="+(i+1));
            
            
            //增加休眠操作来阻塞线程
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
                //返回到方法执行处
                return;
            }
            
            
            
            if(this.isInterrupted()){
                System.out.println("通过this.isInterrupted()检测到中断");
                System.out.println("第一个interrupted()"+this.interrupted());
                System.out.println("第二个interrupted()"+this.interrupted());
                break;
            }
        }
        System.out.println("因为检测到中断，所以跳出循环，线程到这里结束，因为后面没有内容了");
    }
}

public class Demo {
    public static void main(String[] args) throws InterruptedException  {
        MyThread myThread=new MyThread();
        myThread.start();
        myThread.interrupt();
        //sleep等待一秒，等myThread运行完
        Thread.currentThread().sleep(1000);
        System.out.println("myThread线程是否存活："+myThread.isAlive());
    }
}
```

![image-20191105200820613](https://github.com/superlkl/MyNotes/blob/master/pictures/23.png)

被中断后马上返回调用出查看线程情况



**如果没有加return语句**

让return语句让线程退出就是用户自己去监视线程的状态为并做处理的操作

![image-20191105200914076](https://github.com/superlkl/MyNotes/blob/master/pictures/24.png)

他会继续执行for()循环，因为try{}catch{}语句是嵌套在循环厉里面的，  如果在sleep状态下停止某一线程，会进入catch语句，并且清除停止中断标记位，使之变为false ，所以`if(this.isInterrupted())`判断为假，没有执行，因为for()循环还没有结束，线程又重新开始执行，`myThread.isAlive()`判断为ture

### 线程的生命周期

线程的生命周期会经历以下几个状态：

**新建**：**new**创建线程对象时

**就绪**：调用**start()**方法时

**运行**：调用**run()**方法时

**阻塞**： 多种原因可导致阻塞

**死亡**：多种原因

![image-20191105202221171](https://github.com/superlkl/MyNotes/blob/master/pictures/25.png)

 由图可看出，解除阻塞后会重新进入就绪状态 

#### 新建、就绪状态

1. 使用new 关键字创建一个线程时，该线程处于新建状态

2. 线程对象调用 start（）方法时，该线程处于就绪状态（线程获得CPU，等待执行）

3. 线程的启动是从调用start（）方法开始的，而不是run（）方法

4. 永远不要调用线程对象的run（）方法

- 如果直接调用 run() 方法，系统会把该线程对象当成普通对象，run（）方法也将变成一个普通方法（而不是线程执行体）而立即执行。

- 如果直接调用了 run() 方法，则该线程不再处于新建状态，不能再次调用 start()方法，否则会报`IllegalThreadStateException`异常

- 如果直接调用了 run() 方法，则在run() 方法里不能直接通过`this.getName() `方法获得线程名（此时获取的是对象名，因为此时已经没有线程体了，线程对象变成了普通对象），而是通过`Thread.currentThread().getName() `获得。

5. 如果希望线程对象调用start() 方法后立即执行run() 方法（线程体），可通过`Thread.sleep(1)`让主线程睡眠1毫秒，而给其他线程执行机会。
   

#### 运行、阻塞状态

1. 如果CPU是单核，则在任一时刻都只有一个线程在执行。当线程数据大于核数时，就会出现线程轮换。

2. 所有桌面和服务器系统都采用的是抢占式调度策略，即当前线程在系统允许的执行时间之后，就给其他线程获得执行机会，且优先给优化级高的线程。

3. 有些小型系统如手机会采用协作式调度策略，即只能当前线程主动放弃所占资源（调用sleep()或yield()方法）

4. 线程从阻塞状态解除后只能转变为就绪状态，而就绪状态变为运行状态只能由系统线程调度转换。

5. 线程调用了yield（）方法也会重新进入就绪状态

**发生以下情况时，线程将进入阻塞状态** 

- 调用sleep（）方法时。此时会放弃它所占用的处理器资源。

> 【**过了sleep指定时间不再阻塞**】

- 调用一个阻塞式IO方法还没有返回之前，该线程被阻塞。

> 【**阻塞IO方法返回后不再阻塞**】

- 试图获取一个正被其他线程所持有的同步监视器。

> 【**拿到监听器不再阻塞**】

- 等待通知时（notify）。

> 【**其他线程调用了notify时不再阻塞**】

- 调用suspend（）方法将程序挂起时。

> 【**线程调用resume()方法时撤销挂起时不再阻塞**】
> 

#### 线程死亡

**线程死亡情况：**

1. 线程正常结束（run或call方法执行完）

2. 线程抛出一个未捕获的Exception或Error

3. 线程自己调用stop（）方法（该方法容易导致死锁）

4. 一旦子线程启动后，它就拥有和主线程相同的地位，不受主线程的影响。

5. 线程对象只能调用一次start()方法，且只能在新建状态时才能调用。否则会抛出`IllegalThreadStateException`异常



#### 停止线程

在java中有以下3种方法可以终止正在运行的线程：

1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
2. 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。
3. 使用interrupt方法中断线程。

- **interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程。** 



- **停止一个线程意味着在任务处理完任务之前停掉正在做的操作，也就是放弃当前的操作。停止一个线程可以用`Thread.stop()`方法，但最好不要用它。虽然它确实可以停止一个正在运行的线程，但是这个方法是不安全的，而且是已被废弃的方法** 



#####  使用return停止线程

 将方法interrupt()与return结合使用也能实现停止线程的效果 

```java
public class MyThread extends Thread {
    public void run(){
        while (true){
            if(this.isInterrupted()){
                System.out.println("线程被停止了！");
                //返回到方法调用处
                return;
            }
            System.out.println("Time: " + System.currentTimeMillis());
        }
    }
}

public class Run {
    public static void main(String args[]) throws InterruptedException {
        Thread thread = new MyThread();
        thread.start();
        //主线程先休眠2秒让子线程执行
        Thread.sleep(2000);
        thread.interrupt();
    }
}
```

输出结果：

```java
...
Time: 1467072288503
Time: 1467072288503
Time: 1467072288503
//线程被停止了！
```

不过还是建议使用“抛异常”的方法来实现线程的停止，因为在catch块中还可以将异常向上抛，使线程停止事件得以传播 

##### 最好的方式

```java
public class MyThread implements Runnable {
    public boolean flag=true;

    @Override
    public void run() {
        int i=0;
        while (flag){
            System.out.print(Thread.currentThread().getName());
            System.out.println(i++);
        }
    }
    public void stop(){
        try {
            Thread.sleep(1);
            System.out.println("线程名:"+Thread.currentThread().getName());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        flag=false;
    }
}


public class Demo {
    public static void main(String[] args) throws InterruptedException  {
        MyThread myThread=new MyThread();
        Thread t=new Thread(myThread,"线程A");
        t.start();
        myThread.stop();
    }
}

```

为了能看到效果，在调用stop()方法时在里面加了一个sleep()方法，这个sleep()是让main线程睡眠了

![image-20191105205606334](https://github.com/superlkl/MyNotes/blob/master/pictures/26.png)

上面的程序一旦调用了stop()方法就会将`MyThread`类中的flag变量值设置为false,因此run()方法就停止运行，这种停止运行的方式在开发中比较常用

## 线程的等待和唤醒

```java
public class Object {
    
          .......
              
public final void wait() throws InterruptedException {
        wait(0L);
    }
}
```

```java
public class Object {
    ......
@HotSpotIntrinsicCandidate
    public final native void notifyAll();
}
```

```java
public class Object {
    ......
@HotSpotIntrinsicCandidate
    public final native void notify();
}
```

可以注意到`notify()`和`notifyAll()`两个方法都要native关键字修饰

### sleep()和wait()的区别

- sleep()是Thread()类定义的静态方法，表示当前线程休眠，将执行机会让给其他线程，但是监控状态依然保持，休眠时间到了就自动恢复
- wait()是Object类定义的方法，表示线程等待，一直到执行了`notify()`或`notifyAll()`方法后才结束等待

 **总结：**

wait()方法与notify()必须要与synchronized(resource)一起使用。也就是wait与notify针对已经获取了resource锁的线程进行操作，从语法角度来说就是`Obj.wait()`,`Obj.notify`必须在synchronized(Obj){...}语句块内。

从功能上来说wait()线程在获取对象锁后，主动释放CPU控制权，主动释放对象锁，同时本线程休眠。<u>直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行</u>。相应的notify()就是对对象锁的释放操作。【因此，我们可以发现，wait和notify方法均可释放对象的锁，但<u>wait同时释放CPU控制权，即它后面的代码停止执行，线程进入阻塞状态，而notify方法不立刻释放CPU控制权，而是在相应的synchronized(){}语句块执行结束，再自动释放锁</u>。】释放锁后，`JVM`会在等待`resoure`的线程中选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。`Thread.sleep()`与`Object.wait()`二者都可以暂停当前线程，释放CPU控制权，主要的区别在于<u>`Object.wait()`在释放CPU同时，释放了对象锁的控制，而在同步块中的`Thread.sleep()`方法并不释放锁，仅释放CPU控制权</u>。



## 生产者和消费者案例

店长做好一杯奶茶，一个顾客就取走一杯，然后店长继续做奶茶，其他的顾客就等着店长做，店长做好后又喊顾客来拿。

### 买奶茶需要排队

```java
public class Queue {

    private int n;
    private boolean flag = false; // 控制值 默认为 生产模式

    /**
     * 消费,一开始由消费者提出买奶茶的要求
     * @return
     */
    
    public synchronized int getN() {
        if(!flag) {
            try {
                wait(); // 线程等待 只有为true 才消费
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        System.out.println("消费:"+n);
        flag = false;
        notifyAll();
        return n;
    }

    /**
     * 生产。消费者订单生成后开始做奶茶
     * @return
     */
    public synchronized void setN(int n) {
        if(flag) {
            try {
                wait(); // 线程等待 
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
         //只有为false 才干活 生产
        System.out.println("生产:"+n);
        this.n = n;
        flag = true;
        notifyAll(); //释放 wait()
    }

}
```

### 店长开始做奶茶

```java
public class Product implements Runnable {
    private	Queue queue;

    public Product(Queue queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        int i=0;
        while(true) {
            queue.setN(++i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

    }
}
```

### 顾客取奶茶

```java
public class Consumer implements Runnable {

    private	Queue queue;

    public Consumer(Queue queue) {
        this.queue = queue;
    }
    @Override
    public void run() {
        while(true) {
            queue.getN();
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

    }
}

```

### 店铺开始营业

```java
public class Demo {
    public static void main(String[] args) throws InterruptedException  {
        Queue queue = new Queue();
        //开始线程测试
        new Thread(new Consumer(queue)).start();
        new Thread(new Product(queue)).start();
    }
}
```

实现同步效果

![image-20191105214243700](https://github.com/superlkl/MyNotes/blob/master/pictures/27.png)



**逻辑思路：**

先是消费者线程运行，然后判断flag=true，就开始wait()，接着就是生产者线程运行，判断flag=false，就开始生产，修改flag=true，然后唤醒wait线程，但是生产者线程的run()函数还在运行，这个线程还没有结束，于是继续运行判断flag，这时生产者wait()方法被调用，因为消费者线程被唤醒了的，消费者线程继续从之前被wait处开始执行，取得产品，然后修改flag=false，再运行消费者线程后有进入flag判断的方法体内调用了wait()方法，之后就这样一直循坏.......

run方法里是while(true)永真循环，这两个线程就在：准备运行->运行->阻塞->准备运行...这样的循环中一直无限循环下去



## 多线程常见问题

### stop为什么不合适 

多线程之间一般是有联系的，若用stop停止了线程，容易强行打断线程之间的联系， 容易产生错误。 

### 同步代码块和同步方法的区别 

同步方法持有的锁匙是this，即本类对象。而同步代码块可以自定义一把锁，语法为： synchronized(对象){同步内容}，当然这个对象也可以是this。同步代码块的作用域小于同 步函数,而同步函数的作用域大于同步代码块，同步代码块效率相对更高。 

### 为什么没有同步效果 

```java
void add(int n){ 
           Object obj=new Object();           
    synchronized (obj) {   同步代码   }     
} 
```

把Object obj=new Object();定义在add方法内部，每次调用方法都会new一个对象， synchronized (obj) 判断的标记不是同一个锁， 可以直接用类的字节码文件加锁， 将Object obj=new Object(); synchronized (obj)  改为：synchronized (`TongBuHanShu.class`) 

### 线程的优先级 

线程优先级：1-10，代表线程被执行到概率的高低。当两个线程优先级相差不是很 多的情况下，比如4、5、6执行概率不会有明显变化。如果线程优先级相差过多，例如1、 10.那么当优先级较高的程序过多时，优先级为1的线程可能永远执行不到。在编写程序时，不建议指定线程的优先级

### 线程获取名称 

```java
 class Test extends Thread{         
     Test( String name){                 
         //调用了Thread有参数的构造方法。                  
         super(name);         
     }         
     public void run(){                 
         for(int i=0; i<60; i++){                         
             //这里显示的名字是设置的名字。                         System.out.println(this.getName()+"test..."+i);                 
         }         
     } 
 } 
public class ThreadTest { 
public static void main(String[] args) { 
 //给每个对象设置名字。                 
 Test t1 = new Test("one");                 
 Test t2 = new Test("two");                 
 t1.start();                
 t2.start();   
 }
}
```

在使用Test类中，使用super在显示线程名称时显示one,two的原因是：

①Test继承了Thread类，在Test的构造方法中，调用了super(name)方法，这个就 是调用了父类的 public Thread(String name)构造方法，这个构造方法就是为线程命名的。   

②如果在Test类的构造方法中不调用super(name)，系统会默认给Test取名字，默认 为 Thread-0开始     

③自己定义名字，可以使用`setName`(String name)方式修改线程的名字

### 什么情况下使用Thread 什么情况下使用Runnable 

继承Thread类：如果一个类有了父类，便无法再继承。实现`Runnale`：更灵活，没 有单继承的局限。 

### 同步函数锁问题 

```java
public class Demon 

{ //1.静态方法同步函数          

public static synchronized void method1(){} 

//2.非静态方法同步       

public  synchronized void method2(){} 

//3.这个方法可以等价与静态方法同步函数，即静态方法同步函数省略了锁为Demon.class 的静态代码块,因为静态方法是被类本身调用的，而每个类初始化的时候加载了class字节码， 所以锁是Demon.class       

public void method3(){              

synchronized(Demon.class){}              

 } 

//4这个方法可以等价为非静态方法同步函数，也就是非静态方法底层的实现原理

 //注意这个时候，静态代码块的锁就是this,因为函数需要被对象调用，那么函数都有一个 所属对象引用，所以用this。       

public void method4(){              

synchronized(this){}      

 } 

//需要同步的一般是多线程的情况，并且涉及到操作共享数据。 

}

}
```

### 进程和线程的区别 

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资 源分配和调度的一个独立单位。 线程是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运 行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如 程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程； 进程和线程的关系：

①一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

②资源分配给进程，同一进程的所有线程共享该进程的所有资源。 

③线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

④处理机分给线程，即真正在处理机上运行的是线程。 

⑤线程是指进程内的一个执行单元，也是进程内的可调度实体。 线程与进程的区别： 

①调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。

②并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。 

③拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进 程的资源。 

④系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明 显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不 会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和 局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进 程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。     

线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有 独立的内存单元，而多个线程共享内存，从而极大的提高了程序运行效率。    

线程在执行过程中，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制。 从逻辑角度看，多线程的意义子啊与一个应用程序中，有多个执行部分可以同时执行。但操 作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这 就是进程和线程的重要区别。 

### Synchronized锁与 lock锁有什么区别 

①synchronized 锁只锁括号里面的代码内容，一个方法或者一个类等等。如果被锁 的代码抛出异常会自动释放锁资源。       

②lock 锁锁定lock和unlock之间的代码，被锁的代码抛出异常不会自动释放锁资 源，需要try catch 后在finally里面手动unlock释放锁资源。 
