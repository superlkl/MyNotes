# IO操作

## File类

针对文件本身进行操作

### 1.创建一个text.txt文件夹

File类这个构造函数里就是需要传入文件的完整路径

```java
public class demo {
    public static void main(String[] args) {
        File file=new File("d:\\test.txt");//实例化File类对象，必须给出文件完整路径
        try {
            file.createNewFile();//根据给定的路径创建一个新文件
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(File.pathSeparator);
        System.out.println(File.separator);
    }
}
```

因为在不同得操作系统同文件的分隔符不一样,把上述操作方式改为：更合适,File.separator这个函数就是取得本机操作系统的分隔符

```java
//组合出符合操作系统的路径
String path="d:"+File.separator+"test.txt";
//给出路径实例化File对象
File file=new File(path);
```

### 2.关于转义字符

右斜杠需要转义

```java
System.out.println("\\");//  输出 \        System.out.println("/");//   输出 /        System.out.println("//");//  输出 //      System.out.println("\'");//  输出 '        System.out.println("\"");//  输出 "
\n 换行
\r 回车
\t 水平制表（调到下一个TAB位置）
```

### 3.删除文件

判断文件是否存在exists()，然后delete()删除文件

```java
if (file.exists()){
                file.delete();
            }
```

### 4.创建文件夹

```
file.getParentFile()就是取得最后一个目录的上级目录路径
```

```java
String path="d:"+File.separator+"mldn";
        File file=new File(path);
        //判断父目录是否存在
        if (file.getParentFile().exists()){
            //创建文件夹
            file.mkdir();
        }
```

**mkdir()和mkdirs()的区别**

* **mkdir()是创建单级目录**

  必须要在父目录存在的情况下才会创建文件夹

  ```java
  String path="d:"+File.separator+"mldn"+File.separator+"lkl";
          File file=new File(path);
          file.mkdir();
  ```

  如果mldn文件夹不存在那lkl文件夹就不会被创建

* **mkdirs()是创建多级目录**

  ```java
  String path="d:"+File.separator+"mldn"+File.separator+"lkl";
          File file=new File(path);
          file.mkdirs();
  ```

  
  
  mldn文件夹不存在也有效,会创建d:\mldn\lkl的分级目录

### 5.列出目录文件

1.先找到一个文件路径，再把这个文件路径下的所有子路径找到

2.调用list()方法列出目录文件

```java
File file=new File("d:"+File.separator);
//只列出文件名，没有文件路径
        String str[]=file.list();
        for (int i=0;i<str.length;i++){
            System.out.println(str[i]);
        }
```

**列出文件路径**

```java
File file=new File("d:"+File.separator);
//注意与上面不同的是这里的数组类型是File类型，直接打印的是File对象
        File files[]=file.listFiles();
        for (int i=0;i<files.length;i++){
            System.out.println(files[i]);
     }
```



**判断给定的路径是不是目录**

```
File file=new File("d:"+File.separator);
        if (file.isDirectory()){
            System.out.println(file.getPath()+"是目录");
        }
        else {
            System.out.println(file.getPath()+"不是");
        }
```

**输出：** d:\是目录

```
File file=new File("d:/text.txt");
```

**输出**： d:\text.txt不是目录

### 6.综合使用-列出指定目录的全部内容

* 要求：把给定路径下的所有非目录文件全部输出

  采用了递归调用，判断为目录时就继续调用自身函数继续往下找目录，若判断不是目录就打印输出

  ```
  public class demo {
      public static void main(String[] args) {
          File file=new File("F:"+File.separator+"小软件");
          print(file);
  
      }
      public static void print(File file){
          if (file!=null){
              if (file.isDirectory()){
                  File listFile[]=file.listFiles();
                  for (int i=0;i<listFile.length;i++){
                      print(listFile[i]);
                  }
              }
          }
          System.out.println(file);
      }
  }
  
  ```

## 字节流和字符流

程序中的所有数据都是以流的方式进行传输和保存的

### IO操作的步骤

1.使用File类打开一个文件

2.通过字节流或字符流的子类指定输出的位置

3.进行读/写操作

4.关闭输入/输出

### 字节流

#### 字节输出流OutputStream

```java
public abstract class OutputStream implements Closeable, Flushable {
      public abstract void write(int b) throws IOException;
    public void write(byte b[]) throws IOException {
        write(b, 0, b.length);
    }
    public void flush() throws IOException {
    }
     public void close() throws IOException {
    }
}
```

继承了关闭和刷新的接口，里面带有写，关闭和刷新的方法，又是抽象类，必须通过子类来实例化

**通过write(byte b[])写入文件内容**

```java
        //通过File类找到了一个文件
File file=new File("d:"+File.separator+"test.txt");
        //准备好一个输出的对象
        OutputStream out=null;
        try {
            //通过对象的多态性向上转型进行实例化
            out=new FileOutputStream(file);
            //要输出的数据
            String str="Hello World";
            //只能输出byte[]数组
            byte b[]=str.getBytes();
            //讲内容输入
            out.write(b);
            //关闭输出流
            out.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
```

简化代码

```
 public static void main(String[] args) throws Exception {
        File file = new File("d:" + File.separator + "test.txt");
        OutputStream out = null;
            out = new FileOutputStream(file);
            String str = "Hello World!";
            byte b[] = str.getBytes();
            out.write(b);
            out.close();
    }
```

上述代码在实例化，写，关闭的时候都有异常发生，直接在主方法使用throws关键字抛出异常可以减小try...catch...的使用

**通过write(int b)写入文件**

```java
File file = new File("d:" + File.separator + "test.txt");
        OutputStream out = null;
            out = new FileOutputStream(file);
            String str = "Hello World";
            byte b[] = str.getBytes();
//与上面的代码唯一不同之处，只是换成将byte[]数值里的数据一个一个的写入文件中，最终的实现效果是相同的
            for (int i=0;i<b.length;i++){
                out.write(b[i]);
            }
            out.close();
```

#### 追加新内容

按上述方法进行文件操作新内容的输入会默认覆盖旧内容

FileOutputStream有多种构造方法

```java
public FileOutputStream(String name) throws FileNotFoundException {
        this(name != null ? new File(name) : null, false);
    }
```

```java
public FileOutputStream(String name, boolean append)
        throws FileNotFoundException
    {
        this(name != null ? new File(name) : null, append);
    }
```

使用第二种构造方法将append的值设置为true即可实现追加新数据

```java
File file = new File("d:" + File.separator + "test.txt");
        OutputStream out = null;
            //仅仅需要在后面再加一个参数true即可
            out = new FileOutputStream(file,true);
            String str = "Hello World!!!";
            byte b[] = str.getBytes();
            out.write(b);
            out.close();
```

如何写入换行:都可以

```java
String str = "\r Hello World!!!";
```

```java 
String str = "\n Hello World!!!";
```

#### 字节输入流InputStream

```java
         //先找到文件
File file = new File("d:" + File.separator + "test.txt");
         //准备好输入对象
        InputStream inputStream=null;
         //实例化输入对象
        inputStream=new FileInputStream(file);
         //准备字节数组把所有内容读到此数组中
        byte b[]=new byte[80];
         //把内容取出装进数组里面
        inputStream.read(b);
         //关闭输入流
        inputStream.close();
         //把字节数组转换为字符串输出
        System.out.println(new String(b));
```

![image-20191029220655236](https://github.com/superlkl/MyNotes/blob/master/pictures/00.png)

开辟的byte数组空间有80，但是实际却用不了这么多，最后再转换为字符串输出时也把空出来的多余空间转换为字符串了

**修改**

```java
File file = new File("d:" + File.separator + "test.txt");
        InputStream inputStream=null;
        inputStream=new FileInputStream(file);
        byte b[]=new byte[80];
//InputStream类里重载了3个read()函数，这个read()方法返回的是数据中写入的数据大小，和上面的read()方法不一样
        int len=inputStream.read(b);
        inputStream.close();
        System.out.println(len);
        System.out.println(new String(b,0,len));
```

![image-20191029221222004](https://github.com/superlkl/MyNotes/blob/master/pictures/01-20191029221222004.png)

new String(b,0,len)方法

```java 
public String(byte bytes[], int offset, int length) {
        checkBoundsOffCount(offset, length, bytes.length);
        StringCoding.Result ret = StringCoding.decode(bytes, offset, length);
        this.value = ret.value;
        this.coder = ret.coder;
    }
```

作用： 简单的来说就是byte数组b从下标为n开始前进m个下标的那一段数组变为字符串item 

**最优解**

```java
File file = new File("d:" + File.separator + "test.txt");
        InputStream inputStream=null;
        inputStream=new FileInputStream(file);
        //直接确定好文件的大小然后给定数组空间的大小
        byte b[]=new byte[(int) file.length()];
        inputStream.read(b);
        inputStream.close();
        System.out.println(new String(b));
```

循环读取

```java
 File file = new File("d:" + File.separator + "test.txt");
        InputStream inputStream=null;
        inputStream=new FileInputStream(file);
        byte b[]=new byte[(int) file.length()];
        for (int i=0;i<b.length;i++){
            b[i]= (byte) inputStream.read();
        }
        inputStream.close();
        System.out.println(new String(b));
```

逐个字节读取

```java
File file = new File("d:" + File.separator + "test.txt");
        InputStream inputStream=null;
        inputStream=new FileInputStream(file);
        int len=0;
        byte b[]=new byte[1024];
        int temp;
        //当读取的返回值为-1时即表示文件读取结束
        while ((temp=inputStream.read())!=-1){
            //方法返回值为int型,所以需要类型转换
            b[len]= (byte) temp;
            len++;
        }
        inputStream.close();
        System.out.println(new String(b,0,len));
```

源码如下,可看出返回值为int型

```
public int read(byte b[], int off, int len) throws IOException {
        Objects.requireNonNull(b);
        Objects.checkFromIndexSize(off, len, b.length);
        if (len == 0) {
            return 0;
        }

        int c = read();
        if (c == -1) {
            return -1;
        }
        b[off] = (byte)c;

        int i = 1;
        try {
            for (; i < len ; i++) {
                c = read();
                if (c == -1) {
                    break;
                }
                b[off + i] = (byte)c;
            }
        } catch (IOException ee) {
        }
        return i;
    }
```



### 字符流

在程序中一个字符等于两个字节，使用Reader和Writer两个类来操作字符流

#### 字符输出流

输出数据到文件

```java
 File file = new File("d:" + File.separator + "test.txt");
        //准备输出对象
        Writer out=null;
        //对象的多态，实例化输出对象
        out=new FileWriter(file);
        String str="Hello world";
        //将内容输出
        out.write(str);
        out.close();
```

与OutputStream的区别就是可以直接输出而不用再转换为byte[]数组了

#### 追加内容

```java
out=new FileWriter(file,true);
```

#### 字符输入流

从文件里读取数据

```java
File file = new File("d:" + File.separator + "test.txt");
        Reader in=null;
        in=new FileReader(file);
        //储存读取内容的字符数组
        char c[]=new char[1024];
        //把文本内容读到字符数组里，并接收读到的字符大小
        int len =in.read(c);
        in.close();
        System.out.println(new String(c,0,len));
```

### 字节和字符

 1、**计算机存储信息的最小单位，称之为位(bit)，音译为比特**，二进制的一个“0”或一个“1”叫一位。
2、**计算机存储容量基本单位是字节(Byte)，音译为拜特**，8个二进制位组成1个字节。一般而言：一个标准英文字母占一个字节位置，一个标准汉字占二个字节位置。
3、**计算机存储容量大小以字节数来度量，1024进位制：**
　　1024B=1K(千)B
　　1024KB=1M(兆)B
　　1024MB=1G(吉)B
　　1024GB=1T(太)B
　　以下还有PB、EB、ZB、YB 、NB、DB，一般人不常使用了。
4、**字符是一种符号**，同以上说的存储单位不是一回事。 

**（一）“字节”的定义**
字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位。

**（二）“字符”的定义**
字符是指计算机中使用的文字和符号，比如1、2、3、A、B、C、~！·#￥%……—*（）——+、等等。

**（三）“字节”与“字符”的区别**
它们完全不是一个位面的概念，所以两者之间没有“区别”这个说法。

### 字节流和字符流的区别

字节流在操作的时候本身不会用到缓冲区(内存),是与文件本身直接操作，而字节流在操作的时候要用到缓冲区，通过缓冲文件再操作文件

![image-20191030112321565](https://github.com/superlkl/MyNotes/blob/master/pictures/02.png)

![image-20191030112404867](https://github.com/superlkl/MyNotes/blob/master/pictures/28.png)

使用字节流读写文件时不用关闭输出流也可以成功，但字符流操作不关闭输出流就会失败

```java
 File file = new File("d:" + File.separator + "test.txt");
        OutputStream out=null;
        out=new FileOutputStream(file);
        String str="Hello World!!!";
        byte[] b=str.getBytes();
       //还是能够输出到文件里
        out.write(b);
       // out.close();
```

```java
File file = new File("d:" + File.separator + "test.txt");
        Writer writer=null;
        writer=new FileWriter(file);
        String str="Hello World";
        writer.write(str);
        //输出失败
        //writer.close();
```

字符流操作的时候使用到了缓冲区，在关闭字符流的时候会强制性的将缓冲区的内容进行输出，但是如果程序没有关闭则缓冲区的内容无法输出

**Write里有一个flush()冲洗的方法可以强制清空缓冲区**，此时不关闭输出流也能成功

```java
public void flush() throws IOException {
    }
```

```java
File file = new File("d:" + File.separator + "test.txt");
        Writer writer=null;
        writer=new FileWriter(file);
        String str="Hello World!!";
        writer.write(str);
        //强制清空缓冲区，让内容输出
        writer.flush();
        //writer.close();
```

**使用哪一张方式操作文件较好？**

在开发之中，对于字节数据处理比较多，例如，图片，电影，文字，而字符流最大的好处是它可以进行中文的有效处理。如果在日常开发中有中文处理，用字符流，如果没有，建议使用字节流。 

### 文件复制

命令框的复制功能，将D盘下的test.txt文件内容复制到D盘下的lkl.txt

![image-20191030114257308](https://github.com/superlkl/MyNotes/blob/master/pictures/03.png)

**程序不知道怎么运行?**

```java
public static void main(String[] args) throws Exception {
     if (args.length!=2){
         System.out.println("输入的参数不正确");
         System.out.println("例：java Copy 源文件路径 目标文件路径");
         System.exit(1);
     }
     File f1=new File(args[0]);
     File f2=new File(args[1]);
     if (!f1.exists()){
         System.out.println("源文件不存在！");
         System.exit(1);
     }
     InputStream inputStream=null;
     OutputStream outputStream=null;
     inputStream=new FileInputStream(f1);
     outputStream=new FileOutputStream(f2);
     if (inputStream!=null&&outputStream!=null){
         int temp=0;
         byte data[] =new byte[1024];
         while ((temp=inputStream.read())!=-1){
             outputStream.write(data,0,temp);
         }
         System.out.println("复制完成");
         inputStream.close();
         outputStream.close();
     }
    }
```

### 转换流

#### OutputStreamWriter类

这个类是Writer的子类，可以将输出的字符变为字节流，即将一个字符流的输出对象变为字节流输出对象

```java
  File file = new File("d:" + File.separator + "test.txt");
        Writer writer = null;
        //字节流变为字符流
        writer = new OutputStreamWriter(new FileOutputStream(file));
        writer.write("Hello World");
        writer.close();
```



#### InputStreamReader类

这个类是Reader的子类，可以将输入的字节流变为字符流，即将一个字节流的输入对象变为字符流的输入对象

```java
File file = new File("d:" + File.separator + "test.txt");
        Reader reader=null;
        //字节流变为字符流
        reader=new InputStreamReader(new FileInputStream(file));
        char c[]=new char[1024];
        int len=reader.read(c);
        reader.close();
        System.out.println(new String(c,0,len));
```

### 内存操作流

假设有某一种应用需要进行IO操作，但又不希望在磁盘上产生新的文件，这时就可以将内存当作一个临时文件进行操作

```java
String str="HELLO WORLD";
       //内存输入流
       ByteArrayInputStream bis=null;
       //内存输出流
       ByteArrayOutputStream bos=null;
       //向内存中输出内容
       bis=new ByteArrayInputStream(str.getBytes());
       bos=new ByteArrayOutputStream();
       int temp=0;
       while ((temp=bis.read())!=-1){
           //将读取的数字变为字符
           char c= (char) temp;
           //将字符变为小写
           bos.write(Character.toLowerCase(c));
       }
       //取出内容
       String newStr=bos.toString();
       bis.close();
       bos.close();
       System.out.println(newStr);
```

### 管道流

管道流的主要作用是可以进行两个线程间的通信

![image-20191030132101460](https://github.com/superlkl/MyNotes/blob/master/pictures/04.png)

```java
public class Send implements Runnable   {

    PipedOutputStream pos=null;
    public Send(){
        pos=new PipedOutputStream();
    }
    @Override
    public void run() {
        String str="Hello World";
        try {
            //输出信息
            pos.write(str.getBytes());
            pos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
//通过线程类得到输出流
    public PipedOutputStream getPos() {
        return pos;
    }
}
```

```java
public class Receive implements Runnable {
    PipedInputStream pis=null;
    public Receive(){
        pis=new PipedInputStream();
    }

    @Override
    public void run() {
       byte b[]=new byte[1024];
       int len=0;
        try {
            //接收数据
            len=this.pis.read(b);
            pis.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(new String(b,0,len));
    }

    public PipedInputStream getPis() {
        return pis;
    }
}
```

```java
public class Demo {
    public static void main(String[] args) {
        Send send=new Send();
        Receive receive=new Receive();
        try {
            //连接管道
            send.getPos().connect(receive.getPis());
        } catch (IOException e) {
            e.printStackTrace();
        }
        //启动线程
        new Thread(send).start();
        new Thread(receive).start();
    }
}
```

输出：Hello World

### 打印流

**整个IO包中，打印流是输出信息最方便的类**

 PrintStream是OutputStream的子类，打印流把输出流重新装饰了一下，就像送别人礼物时要包装一下，这样的设计模式叫装饰设计模式

```java
File file=new File("d://test.txt");
        PrintStream stream=null;
//通过FileOutputStream实例化，意味着所有的输出是向文件之中打印
        stream=new PrintStream(new FileOutputStream(file));
        stream.print("Hello");
        stream.println("\nWorld!!!");
        stream.print("1+1=2");
        stream.close();
```

直接就输出到了文件里面，与OutputStream相比方便了很多

格式化输出

```java
File file=new File("d://test.txt");
        PrintStream stream=null;
        stream=new PrintStream(new FileOutputStream(file));
        String name="刘坤龙";
        int age=20;
        char sex='M';
        float GAP=3.0f;
        stream.printf("%s,%d,%f,%c",name,age,GAP,sex);
        stream.close();
```



| 字符 | 描述             |
| ---- | ---------------- |
| %s   | 表示内容为字符串 |
| %d   | 表示内容为整数   |
| %f   | 表示内容为小数   |
| %c   | 表示内容为字符   |

输出：

![image-20191030134220577](https://github.com/superlkl/MyNotes/blob/master/pictures/05.png)



# System类对IO的支持

## System.out

System.out是PrintStream的对象，System.out.print()实际上调用的就是PrintStream类的方法，而PrintStream又是OutputStream的子类

```java
public static void main(String[] args) throws Exception {
    //此时的输出流是向屏幕上输出
        OutputStream out=System.out;
    //输出数据
        out.write("hello world".getBytes());
        out.close();
    }
```

OutputStream的那个子项为其实例化就具备向哪里输出的能力，如果是使用FileOutputStream则表示向文件输出，如果使用System.out则表示向显示器输出

## System.err

表示错误信息的输出，但是实际的输出效果和System.out的完全一样

只能从概念的上解释他们的差别，System.out打印的内容是希望用户看到的，是正常的显示信息，而System.err相反

## System.in

System.in是一个键盘输入流，是InputStream的对象，可以利用此方法读取键盘输入数据

```java
//从键盘输入内容
InputStream input=System.in;
byte b[]=new byte[1024];
System.out.println("请输入内容");
//读取键盘内容到byte[]数组并得到数据大小
int len=input.read(b);
input.close();
//输出键盘输入的内容
System.out.println(new String(b,0,len));
```

该程序指定了byte[]数组的大小存在两个问题：

1.如果输入的数据超过了指定的数组大小，则只能输入部分的数据

2.如果指定的byte[]数组长度小的话还可能存在乱码的情况

```java
byte b[]=new byte[6];
```

输出：![image-20191030181132663](https://github.com/superlkl/MyNotes/blob/master/pictures/06.png)



```java
byte b[]=new byte[8];
```

输出：![image-20191030180856481](https://github.com/superlkl/MyNotes/blob/master/pictures/08.png)

不同的编码格式占字节数是不同的，UTF-8编码下一个中文所占字节也是不确定的，可能是2个、3个、4个字节； 我的电脑显示的

不同的编码格式占字节数是不同的，UTF-8编码下一个中文所占字节也是不确定的，可能是2个、3个、4个字节； 我的电脑显示的是一个汉字占三个字节，所以需要9个字节才够

**直接读取不规定byte[]数组大小**

```java
 InputStream input=System.in;
        StringBuffer str=new StringBuffer();
        System.out.println("请输入内容");
        int temp=0;
        while ((temp=input.read())!=-1){
            char c= (char) temp;
            if (c=='\n'){
                break;
            }
            else {
                str.append(c);
            }
        }
        input.close();
        System.out.println(str);
```

![image-20191030181809644](https://github.com/superlkl/MyNotes/blob/master/pictures/07.png)

![image-20191030181824356](https://github.com/superlkl/MyNotes/blob/master/pictures/08.png)

输出英文和符号没问题，但是输入中文就出现了乱码的情况，因为一个中文占的字符大于等于2，而这里的数据又是一个一个读进来的，一个汉字分两次读所以就造成了乱码的现象

**问题？指定数据大小会出现空间限制，不指定大小会出现中文乱码**

应该将输入的数据暂时放到一块内存中然后一次性的从内存中读取数据

### BufferedReader类

有两个构造函数

```
public BufferedReader(Reader in)
public BufferedReader(Reader in, int sz)
```

但是都需要穿入字符流对象，而System.in构造的是字节流对象实例，所以必须用字节输入流的转换类InputStreamReader类把字节流对象转换为字符流对象

**键盘输入数据的标准格式**

```java
public static void main(String[] args) throws Exception {
       BufferedReader reader=null;
       reader=new BufferedReader(new InputStreamReader(System.in));
       String str=null;
        System.out.println("请输入内容");
        str=reader.readLine();
        System.out.println("输入的内容为:"+str);
    }
```

![image-20191030183352735](https://github.com/superlkl/MyNotes/blob/master/pictures/099.png)

![image-20191030183955504](https://github.com/superlkl/MyNotes/blob/master/pictures/010.png)

### Scanner类

```java
Scanner scanner=new Scanner(System.in);
        System.out.println("输入数据");
        String str=scanner.next();
        System.out.println(str);
```

![image-20191030185643664](https://github.com/superlkl/MyNotes/blob/master/pictures/011.png)

![image-20191030185724537](https://github.com/superlkl/MyNotes/blob/master/pictures/012.png)

空格之后的数据没有了，这是因为 Scanner 将空格当作了一个分隔符，Scanner对象将首先跳过输入流开头的所有空白分隔符，然后对输入流中的信息进行检查，直到遇到空白分隔符为止 

```
//修改输入数据的分隔符，把分隔符修改为"\n回车"或其他字符
scanner.useDelimiter("\n");
```

![image-20191030185913174](https://github.com/superlkl/MyNotes/blob/master/pictures/015.png)

 Scanner是一个扫描器，我们录取到键盘的数据，先存到缓存区等待读取，它判断读取结束的标示是  空白符；比如空格，回车，tab 等等。 

#### next()和nextLine()的区别

**next():**只读取输入直到空格。它不能读两个由空格或符号隔开的单词。此外，next()在读取输入后将光标放在同一行中。(next()只读空格之前的数据,并且光标指向本行),不论多少个空格都算一个空格。

**nextLine():**读取输入，包括单词之间的空格和除回车以外的所有符号(即。它读到行尾)。读取输入后，nextLine()将光标定位在下一行。

```java
Scanner scanner=new Scanner(System.in);
        //不修改默认分隔符
        //scanner.useDelimiter("\n");
        System.out.println("输入数据");
        String str=scanner.nextLine();
        System.out.println(str);
```

![image-20191030191616375](https://github.com/superlkl/MyNotes/blob/master/pictures/013.png)

#### hasNext()

hasNext()这个方法是如果此扫描器的输入中有另一个标记，则返回 true。在等待要扫描的输入时，此方法可能阻塞。扫描器将不执行任何输入。所以循环会一直下去。
你可以设置一个终止符，调用hasNext()的重载方法hasNext(String patten)：如果下一个标记与从指定字符串构造的模式匹配，则返回 true。扫描器不执行任何输入。

```java 
 System.out.println("请输入若干单词，以空格作为分隔");
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext())
        {
            System.out.println("键盘输入的内容是："

                    + sc.nextLine());
        }
        System.out.println("执行?");
```

![image-20191031211121378](https://github.com/superlkl/MyNotes/blob/master/pictures/014.png)

```java
System.out.println("请输入若干单词，以空格作为分隔");
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext())
        {
            System.out.println("键盘输入的内容是："

                    + sc.next());
        }
        System.out.println("执行?");
```

![image-20191030195928236](https://github.com/superlkl/MyNotes/blob/master/pictures/015.png)

利用他的重载函数添加分隔符，规定遇到符号#时停止扫描，如果没有分隔符这个方法就不会停止，会阻塞等待下一次输入

```
while(sc.hasNext("#"))
```

![image-20191030193600508](https://github.com/superlkl/MyNotes/blob/master/pictures/016.png)

读取文件内容

```java 
File file=new File("d://test.txt");
        Scanner scanner=null;
        scanner=new Scanner(file);
        StringBuffer str=new StringBuffer();
        //判断是否还有内容
        while (scanner.hasNext()){
            str.append(scanner.next()).append("\n");
        }
        System.out.println(str);
```

![image-20191030194207419](https://github.com/superlkl/MyNotes/blob/master/pictures/017.png)

文件中有空格的地方就被换行输出了，scanner.hasNext()执行了三次

### 对象序列化

对象序列化就是把一个对象变为二进制的数据流的一种方法，可以更方便实现对象的传输或储存

**Serializable接口**

```
public interface Serializable {}
```

在此接口中并没有定义任何方法，所以此接口是一个标识接口，表示一个类具有了被序列化的能力

**标识接口的定义**

标识接口是没有任何方法和属性的接口。标识接口不对实现它的类有任何语义上的要求，它仅仅表明实现它的类属于一个特定的类型。
与其他接口的区别是：这个接口里面什么方法都没有，只是标记而已。 

#### 对象输出流

**ObjectOutoutStream**

构造函数

```java
public class ObjectOutputStream
    extends OutputStream implements ObjectOutput, ObjectStreamConstants
```

序列化操作实例,将Person类对象保存在文件中

```java
private static final long serialVersionUID=1L;
看了一些文章，我的理解就是，这个东西是用来serialization 的key，A和B相互之间传输信息，用seralize，但是相互之间把解包之后的文件进行了更改，如果你程序中不加这个，相互之间再传输，会因为这个key不一样，而失败。所以，在程序中定义，会使软件版本兼容，无论怎么改，都可以相互序列化和反序列化。
```

```java
public class Person implements Serializable {
    //很关键
    private static final long serialVersionUID=1L;
    private String name;
    private int age;
    public Person(String name,int age){
        this.name=name;
        this.age=age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    
}

```

```java
 public static void main(String[] args) throws Exception {
        File file=new File("d://test.txt");
        ObjectOutputStream oos=null;
        OutputStream out=new FileOutputStream(file);
        oos=new ObjectOutputStream(out);
        oos.writeObject(new Person("刘坤龙",20));
        oos.close();
    }
```

![image-20191030212804509](https://github.com/superlkl/MyNotes/blob/master/pictures/018.png)

在记事本里保存的都是二进制数

到底序列化了那些内容？

每个对象都具有相同的方法，但不一定具有相同的属性，所以只有对象的属性被序列化

#### 对象输入流

ObjectInputStream

反序列化操作，将文件中的序列化对象输出

```java
File file=new File("d://test.txt");
       ObjectInputStream ois=null;
       InputStream input=new FileInputStream(file);
       ois=new ObjectInputStream(input);
       Object obj=ois.readObject();
       ois.close();
       System.out.println(obj);
```

![image-20191030214021463](https://github.com/superlkl/MyNotes/blob/master/pictures/019.png)

#### transient

如果希望一个对象中的某个属性不被序列化就可以使用transient关键字声明

```java
private transient String name;
```

![image-20191030214704148](https://github.com/superlkl/MyNotes/blob/master/pictures/020.pngg)

## 文件操作类的继承关系结构图

![image-20191030203500762](https://github.com/superlkl/MyNotes/blob/master/pictures/021.png)

## ![image-20191030202948483](https://github.com/superlkl/MyNotes/blob/master/pictures/022.png)

![image-20191030203103791](https://github.com/superlkl/MyNotes/blob/master/pictures/023.png)

![image-20191030203221829](https://github.com/superlkl/MyNotes/blob/master/pictures/024.png)

# 总结反思

## 怎么读写文件？

1.用File类关联一个文件路径，File类的构造函数就是传入一个文件的完整路径

2.准备一个输出流对象，用这个对象输出数据到文件里

3.实例化输出流对象，是输出到文件就用输出文件的输出流，要用File类对象构造

4.准备输出的数据

5.输出对象后要关闭输出流
