<a href="#1">反射</a>

<a href="#2">Java代码执行的三个阶段</a>

<a href="#3">代码执行的三个阶段</a>

<a href="#4">获取Class对象的三种方式</a>

<a href="#5">使用Class对象功能</a>

<a href="#6">Person代码</a>



# <a name="1">反射</a>

反射被称为框架设计的灵魂

框架：半成品软件，可以在框架的基础上进行的软件的开发，简化代码

>本来需要一万行的代码用了框架后就只需要一千行了，其余的框架已经帮你写好了
>
>使用框架不需要反射，设计框架需要反射

概念：将类的各个组成部分封装为其他对象，这就是反射机制

# <a name="2">Java代码执行的三个阶段</a>

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020011012393958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

把类属性name,age封装为Fileld对象，把构造函数Person封装成constructor对象，把成员方法eat封装成Method对象

# <a name="3">代码执行的三个阶段</a>

第一个阶段【源代码阶段】：

我们一般都是先创建一个类文件，例如Person.java，当我们把代码写好，也就是写好基本的类属性，类构造函数，类成员函数之后，就要进行系统编译，如果没有语法错误，就把Java文件里面的类属性，类构造函数，类成员函数一一编译为字节码文件

>**虽然把Java文件编译成了字节码文件，但想要运行还是不够的，当我们在main函数里创建一个对象时，这个对象是在内存当中的，但字节码文件还储存在硬盘上，所以必须先加载进内存**

第二个阶段【Class类对象阶段】：

Java中有一个类就叫Class，这个类是用来描述所有字节码文件共同特征的一个类，这个类里面有三个对象数组，也就是用来分别描述类属性，类构造函数和类成员函数的。Java语言的特点就是万物皆对象，现在我终于明白这句话是什么意思了，不论是类属性，类构造函数，还是类成员函数，通过类加载器加载之后他们都会进入对应的对象数组里面，进入内存中。

>**类的属性可以取值，可以设值，而且也许不止一个，就封装在Fileld[]对象数组中**
>
>**类的构造函数可以构造出类对象，也会有多个，就封装在constructor[]对象数组中**
>
>**构造出类对象后用成员方法来表现类的动作，就封装在Method[]对象数组中**

第三个阶段【Runtime运行时阶段】：

创建对象并运行，所有真正的类对象其实都是通过Class类对象来创建出来的

# <a name="4">获取Class对象的三种方式</a>

>**参照上图**

第一个阶段：只有Java字节码文件，还没有进内存，我们需要手动的把字节码文件加载进入内存【class.forName("全类名")】，生成一个字节码文件对象，就是Class类对象

第二种方式：字节码文件已经被我们加载一次了，已经进入内存了，那么就可以通过类名来获取【类名.class】，类有一个属性就是class

第三种方式：已经在运行时阶段了，那么就已经有对象了，就可以通过该对象的get方法来获取【对象.getClass()】

**概要：**

1. class.forName("全类名")；将字节码文件加载进内存，返回Class对象
   - 多用于配置文件，将类名定义在配置文件中，加载类

2. 类名.class；通过类名的属性class获取
   - 多用于参数传递

3. 对象.getClass()，get方法是封装在Object类中的
   - 多用于对象的获取字节码的方式

**好处：**

1. 可以在程序运行过程中，操作这些对象 。

获取和设置

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110121610850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

>**定义了一个String对象，通过反射就可以得到这个对象里的方法**
>
>定义了String字符串，系统把字符串的字节码文件加载进内存，内存里面有个Class对象，Class对象已经把所有的方法抽取出来放进了Method数组里，当我们需要用到里面的方法时就把名字放到展示列表就可以了，如上图所示

2. 可以解耦，提高程序的可扩展性

```java
public class ReflectDemo {
    public static void main(String[] args) throws ClassNotFoundException {
        //1
        Class cls1= Class.forName("domain.Person");
        System.out.println(cls1);
        //2
        Class cls2= Person.class;
        System.out.println(cls2);
        //3
        Person p=new Person();
        Class cls3=p.getClass();
        System.out.println(cls3);

        //判断对象是否是同一个
        System.out.println(cls1==cls2);
        System.out.println(cls1==cls3);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110160428675.png)

结论：

同一个字节码文件(*.class)在一次程序运行过程中只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个

# <a name="5">使用Class对象功能</a>

一、获取功能：常用API

1. 获取成员变量们  

   ```java
   * Field[] getFields() ：获取所有public修饰的成员变量
   * Field getField(String name)   获取指定名称的 public修饰的成员变量
   
   * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符
   * Field getDeclaredField(String name)  
   ```

2. 获取构造方法们

   ```java
   * Constructor<?>[] getConstructors()  
   * Constructor<T> getConstructor(类<?>... parameterTypes)
       
   * Constructor<T> getDeclaredConstructor(类<?>... parameterTypes)  
   * Constructor<?>[] getDeclaredConstructors() 
   ```

3. 获取成员方法们

   ```java
   * Method[] getMethods()  
   * Method getMethod(String name, 类<?>... parameterTypes)  
   * Method[] getDeclaredMethods()  
   * Method getDeclaredMethod(String name, 类<?>... parameterTypes)  
   ```

4. 获取类名

   ```java
   * String getName()  
   ```

   二、测试：

   1. 获取成员变量

   ```java
   public class ReflectDemo {
       public static void main(String[] args) throws ClassNotFoundException {
           Class personClass=Person.class;
           Field[] fields=personClass.getFields();
           for (Field field : fields){
               System.out.println(field);
           }
       }
   }
   ```

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110163318468.png)

   没有输出结果，原因是这个方法只能获取public修饰的成员变量

   修改Person代码①

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110163619782.png)

确实只输出了Public修饰的成员变量a

```java
Class personClass=Person.class;
Field field=personClass.getField("a");
System.out.println(field);
```

输出结果也是相同的，只不过这个方法是输出指定变量名的字节码



- Field：成员变量

  - 操作：

    - 获取值

      get(Object obj)

    - 修改值

      void set(Object obj,Object value)

    - 忽略访问修饰符的安全检查

      `field.setAccessible(true)`;//暴力反射

```java
Class personClass=Person.class;
        Field field=personClass.getField("a");
        Person person=new Person();
        //获取
        Object value1=field.get(person);
        System.out.println(value1);
        //修改
        field.set(person,520);
        System.out.println(person);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110165608865.png)

注：在使用get(Object object)获取值的时候传入的是对象

```
 Class personClass= Person.class;
        Field[] fields=personClass.getDeclaredFields();
        for (Field field : fields){
            System.out.println(field);
        }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110165937841.png)

`getDeclaredFields()`这个方法是可以获取所以的成员变量，不论什么修饰符修饰的都可以获取到

>**可以获取，那么就说明可以设置值，但在以前没有使用反射前私有的属性是不能单独设置的，也就是说在反射的功能下，没有私有公有的说法**

获取单个private修饰的成员变量的值

```java
 Class personClass = Person.class;
        Field field = personClass.getDeclaredField("d");
        Person person = new Person();
        Object value = field.get(person);
        System.out.println(value);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110170622915.png)

打印显示出了错误

修改：我们要忽略访问修饰符的安全检查才行

```java
 Class personClass = Person.class;
        Field field = personClass.getDeclaredField("d");
        //忽略访问修饰符的安全检查
        field.setAccessible(true);//暴力反射
        Person person = new Person();
        Object value = field.get(person);
        System.out.println(value);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110170852248.png)

结果就出来了，也没有报错



- Constructor:构造方法
  - 创建对象
    - `T newInstance(Object...initargs)`
    - 如果使用空参数构造方法创建对象，操作可以简化：Class对象的`newInstance`方法



```java
 public static void main(String[] args) throws Exception {
        Class personClass =Person.class;
        Constructor constructor= personClass.getConstructor(String.class,int.class);
        Object person=constructor.newInstance("张三",20);
        System.out.println(person);
    }
```



```java
 public static void main(String[] args) throws Exception {
     //先找到Person类在Class类里面的字节码文件
        Class<Person> personClass =Person.class;
     //
        Constructor<Person> constructor= personClass.getConstructor(String.class,int.class);
        Object person=constructor.newInstance("张三",20);
        System.out.println(person);
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110173925533.png)

访问空参的两种方法

```java
//第一种
Constructor constructor1=personClass.getConstructor();
        Object person1=constructor1.newInstance();
        System.out.println(person1);
//第二种
        Object person2=personClass.newInstance();
        System.out.println(person2);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110174450464.png)

可以看出，输出结果都是一样的，第二种方式虽然简单，但是方法已经被弃用了

>**注：也是和获取成员属性一样，如果要获取私有的构造方法，就要先设置忽略访问修饰符为true**
>
>```java
>constructor.setAccessible(true);
>```



# <a name="6">Person代码</a>

```java
package domain;

public class Person {
    private String name;
    private int age;
    
    //修改①
    public int a;
    protected int b;
    int c;
    private int d;

    public Person(){
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return super.toString();
    }
    
    //修改②
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", a=" + a +
                ", b=" + b +
                ", c=" + c +
                ", d=" + d +
                '}';
    }
}
```

