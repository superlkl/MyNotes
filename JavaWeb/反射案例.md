反射案例

- 需求：写一个“框架”，可以帮我们去创建任意类的对象，并且执行任意的方法
  - 实现
    - 配置文件
    - 反射
  - 步骤
    - 将需要创建的对象的全类名和需要执行的文化定义在配置文件中
    - 在程序中加载读取配置文件
    - 使用反射技术来加载类文件进入内存
    - 创建对象
    - 执行方法

按照以前的逻辑，先创建一个类再调用类的方法，弊端：需要改动原来的代码

```java
public class ReflectTest {
    public static void main(String[] args) {
        //不能改变该类的任何代码的前提下，可以创建任意类对象，并且执行方法
        Person person = new Person();
        person.eat();
    }
}
```

但是我要调用另一个类就需要先注释掉这个Person类再创建另一个类，而框架的意义是一个半成品，使用框架不能改变该类的任何代码，所以这样的操作是显然不行的

修改：

1. 先`src->new file`创建一个配置文件`pro.properties`

```java
className=domain.Person
methodName=eat
```

2. 简单案例

```java
public class ReflectTest {
    public static void main(String[] args) throws Exception {
       //不能改变该类的任何代码的前提下，可以创建任意类对象，并且执行方法

        //1.加载配置文件
        //1.1创建Properties对象
        Properties pro=new Properties();
        //1.2加载配置文件，转换为一个集合
        ClassLoader classLoader=ReflectTest.class.getClassLoader();
        //1.3读取class文件下的配置文件
        InputStream in = classLoader.getResourceAsStream("pro.properties");
        pro.load(in);

        //2.获取配置文件中定义的数据
        String className=pro.getProperty("className");
        String methodName=pro.getProperty("methodName");

        //3.加载该类进内存
        Class cls=Class.forName(className);
        //4.创建对象
        Object o = cls.newInstance();
        //5.获取对象
        Method method=cls.getMethod(methodName);
        //6.执行方法
        method.invoke(o);
    }
}
//输出：eat...
```

若是要使用Student类中的方法就只需要改动配置文件就行了

```java
className=domain.Student
methodName=sleep
//输出：sleep...
```

**改代码和改配置文件的区别？**

如果这个项目代码系统非常庞大的话，代码一改了话需要重新测试，需要重新编译，重新上线，而配置文件是一个物理文件，如果仅仅改一下配置文件，改了就完事了，并且该配置文件的方式也可以增强文件的扩展性，这就是反射的魅力，只要看到在配置文件中有一个地方配了全类名，那么就可以知道那个地方用的就是反射机制



在程序中使用注解：获取注解中定义的属性值

1. 获取注解定义位置的对象，{Class,Method,Field对象}
2. 获取指定的注解
   - getAnnotation(Class)
3. 调用注解中抽象方法获取配置的属性值



先创建一个配置文件Pro在该包下

```java
**
 * 描述需要去执行的类名和方法名
 */
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Pro {
    String className();
    String methodName();
}
```

创建一个类

```java
public class Demo1 {
    public void show(){
        System.out.println("Demo1...show...");
    }
}
```

使用注解

```java
@Pro(className = "annotation.Demo1",methodName = "show")
public class ReflectTest {
    public static void main(String[] args) throws Exception {
        //可以创建任意类对象，并且执行方法

        //1.解析注解
        //1.1获取改类的字节码文件对象
        Class<ReflectTest> reflectTestClass = ReflectTest.class;
        //2.获取上面的注解对象
        //其实就是在内存中去生成了一个该注解接口的子类实现对象
        Pro annotation = reflectTestClass.getAnnotation(Pro.class);
        //3.调用注解对象中定义的抽象方法，获取返回值
        String className = annotation.className();
        String methodName = annotation.methodName();
        System.out.println(className);
        System.out.println(methodName);

        //3.加载该类进内存
        Class cls=Class.forName(className);
        //4.创建对象
        Object o = cls.newInstance();
        //5.获取对象
        Method method=cls.getMethod(methodName);
        //6.执行方法
        method.invoke(o);
    }
}
//输出：
annotation.Demo1
show
Demo1...show...
```

注解接口

```java
 //其实就是在内存中去生成了一个该注解接口的子类实现对象
        Pro annotation = reflectTestClass.getAnnotation(Pro.class);

//上面代码的意思就像下面的代码所表示的这样
public class ProImpl implement Pro{
    public String className(){
    return "annotation.Demo";
    }
    public String methodName(){
    return "show";
    }
}
```



##### 使用注解来检查程序的框架案例

先定义一个注解类Check

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Check {
}
```

定义一个计算机类，包含加减乘除

```java
package Demo;

public class Calculator {
    //加
    @Check
    public void add(){
        System.out.println(1+1);
    }
    //减
    @Check
    public void sub(){
        System.out.println(1-1);
    }
    //乘
    @Check
    public void mul(){
        System.out.println(1*0);
    }
    //除
    @Check
    public void div(){
        System.out.println(1/0);
    }
}
```

定义测试类

```java
package Demo;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Method;

/**
 * 简单的测试框架
 * 当主方法执行后会自动去执行被检测的所有方法(加了check注解的方法，判断方法是否有异常，记录到文件中)
 */
public class TestCheck {
    public static void main(String[] args) throws IOException {
        //1.创建计算器对象
        Calculator calculator=new Calculator();
        //2.获取字节码文件对象
        Class cls = calculator.getClass();
        //3.获取所有方法
        Method[] methods=cls.getMethods();

        int number=0;//出现异常的次数
        BufferedWriter buf=new BufferedWriter(new FileWriter("bug.txt"));
        //判断方法上是否有check注释，有就执行
        for (Method method:methods){
            if (method.isAnnotationPresent(Check.class)){
                try {
                    method.invoke(calculator);
                } catch (Exception e) {
                    //捕获异常
                    number++;
                    //记录到文件中
                    buf.write(method.getName()+"方法出异常了");
                    buf.newLine();
                    buf.write("异常的名称"+e.getCause().getClass().getSimpleName());
                    buf.newLine();
                    buf.write("异常的原因"+e.getCause().getMessage());
                    buf.newLine();
                    buf.write("---------------");
                    buf.newLine();
                }
            }
        }
        buf.write("本次测试一共出现"+number+"次异常");
        buf.flush();
        buf.close();
    }
}
```



小结：

1. 以后我们大多时候都会使用注解，而不是自定义注解
2. 注解给谁用？
   - 编译器
   - 给解析程序用
3. 注解不是程序的一部分，可以理解为注解就是一个标签
   - 因为一个程序就算没有注解也是照常运行

