概念：说明程序的，给计算机看的

注释：用文件描述程序，给程序员看的



概念描述：

- `JDK1.5`之后的新特性
- 说明程序的
- 使用注解：@注解名称

作用分类：

1. 编写文档：通过代码里标识的注解生成文档【生成doc文档】
2. 代码分析：通过代码里标识的注解对代码进行分析【使用反射】
3. 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】



**生成文档：**

1. ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110184938108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

2. ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110185132877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)
3. ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110185314783.png)
4. ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200110185334846.png)
5. 注：这里如果`JDK`版本过低的话是生成不了文档的



**编译检查：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200112004249896.png)

发现方法名字不正确，马上就报错了



#### 学习目标

[①的解释跳转](#1)

- ①了解JDK中一些预定义的注解
  - @Override - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。
  - @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。
  - @SuppressWarnings - 压制警告。指示编译器去忽略注解中声明的警告。
    - 一般传递参数all
    - `@SuppressWarnings("all")`

[②的解释跳转](#2)

- ②自定义注解

  - 格式

    - 元注解

      public @interface 注解名称{}

  - 本质：本质上就是一个接口，该接口默认继承Annotation接口

    `public interface MyAnnotation extends java.lang.annotation.Annotation {`
  
  属性列表`
    }`

  - 属性：接口中可以定义的成员方法，是抽象方法

    - 要求：

      1.属性的返回值类型：

      基本数据类型

      String

      枚举

      注解
  
      以上类型的数组
      
      2.定义了属性，在使用的时候需要给属性赋值
      
      - 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值
      - 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略不写，自己定义值即可
      - 数组赋值时，值使用{}包裹，如果数组中只有一个值时，{}可以省略
  
- 元注解：描述注解的注解（[元注解的解释跳转](#元)）

  - @Target:描述注解能够作用的位置
    - ElementType取值 
      - TYPE:可以作用于类上
      - METHOD：可以作用用方法上
      - FILED：可以作用用成员变量上
  - @Retention:描述注解能够被保留的阶段
    - `@Retention(RetentionPolicy.RUNTIME)`:当前被描述的注解，会保留到class字节码文件中，并被JVM读取到

  - @Documented:描述注解是否被抽取到api文档中
  - @Inherited:描述注解是否被子类继承

[③的解释跳转](#3)

- ③在程序中使用注解：获取注解中定义的属性值



<a id="1">①的解释</a>

```java
public class Demo {
    @Override
    public String toString(){
        return super.toString();
    }
    @Deprecated
    public void show1(){
        //已经过时
    }
    public void show2(){
        //代替show()2
        show1();
    }
```

在调用show1()的时候就有一条横线划掉的提示

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200112005612527.png)

在方法没有被调用的时候最左边的窗口上就会出现警告的提示

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020011200575110.png)

```java
@SuppressWarnings("all")
public class Demo {...}
```

在类的最上方加是上注解，并且传递一个all参数表示忽略所有警告，右边窗口的警告就会消除掉

<a id="2">②的解释</a>

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200112015202969.png)

>在进行javac编译操作后，没有报错，也没有编译出.class文件，很奇怪，明明都已经把代码粘贴复制进文件了的，为什么会出现编译没有作用的情况？
>
>再用记事本打开文件一看，竟然是空的，难怪编译没有效果，这是因为之前使用的是NotePad++打开的，把代码复制进去关闭后它并没有保存，所以文件夹里面还是空的

先用javac编译.java文件得到.class文件，再用javap进行反编译输出了反编译后的代码

---



自定义注解

```java
public @interface MyAnnotation {
    String show1();
//    int show2();
//    MyAnnoTest value(); //注解类型
//    Student stu();  //枚举类型的Student
//    String[] str();
}
```

在创建一个Test类

```java
@MyAnnotation(show1 = "my")
public class AnnotationTest {
}

```

我们自留下来show()1方法，所以在给注解赋值的时候只用给show1()赋值就行了，我们可以看到这种赋值的方法就像一个类中给属性赋值一样，所以才把这种注解里的方法叫做注解的属性，为了让我们更好的读代码和理解，我们应该尽量把注解的属性名改成我们所常用的，所熟悉的名字，如下：

```java
public @interface MyAnnotation {
    int age();
    String name() ;
}
```

在每次使用的时候都需要给属性赋值

```java
@MyAnnotation(age = 20,name="lkl")
public class AnnotationTest {
}
```

如果我们不想每次使用都给属性赋值，就给它加一个默认值

```java
public @interface MyAnnotation {
    int age();
    String name() default "佚名";
}
```

这样就会自动采用默认值了

```java
@MyAnnotation(age = 20)
public class AnnotationTest {
}
```

---



**如果只有一个属性且使用value可以直接写**

```java
public @interface MyAnnotation {
    int value();
   // String name() default "佚名";
}
```

如下：

```java
@MyAnnotation(20)
public class AnnotationTest {
}
```

查找value的蛛丝马迹

我们在使用压制警告的时候就是直接赋值的

```java
@SuppressWarnings("all")
```

打开里面的内容一看，果然有一个属性名就是value

```java
public @interface SuppressWarnings {  
    String[] value();
}
```

---

使用注解时给注解赋值，注意数组的赋值

```java
@MyAnnotation(value = 20, str = {"aaa", "bbb", "ccc"}, stu = Student.S1)
public class AnnotationTest {
}
```

<a id="元">元注解</a>

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
//上面的就是原注解
public @interface Override {
}
```

一个是表名这个注解可以用于方法之上

另一个表名这个注解可以存到源代码中

1. @Target

```java
public @interface Target {
    ElementType[] value();
}
```

ElementType

```java
public enum ElementType {
    /** Class, interface (including annotation type), or enum declaration */
    TYPE,

    /** Field declaration (includes enum constants) */
    FIELD,

    /** Method declaration */
    METHOD,
    ...
}
```

使用：

```java
@Target(value = {ElementType.TYPE})//加上元注解
public @interface MyAnnotation {
    int value();
    String name() default "佚名";
}
```

只能作用于类上

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200112114600590.png)

想要都能作用，直接在数组里继续添加其他类型

```java
@Target(value = {ElementType.TYPE,ElementType.METHOD,ElementType.FIELD})
//添加了类，方法和属性，表示都能注解了，而且这里的value还可以省略
public @interface MyAnnotation {
    int value();
    String name() default "佚名";
}
```

确实没有报错了

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200112115006448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)



<a id=3>③的解释</a>



