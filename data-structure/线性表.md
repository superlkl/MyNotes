# 顺序表`java`实现

## 顺序表的定义

顺序表是指用一组地址连续的存储单元依次存储各个元素，使得在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中的线性表。 

 **一个标准的顺序表需要实现以下基本操作：** 

先用一个接口把需要实现的功能列出来:

增删改查

```java
public interface ISequence {
    // 在 pos 位置插入 val
    boolean add(int pos, Object data);

    // 查找关键字 key 找到返回 key 的下表，没有返回 -1
    int search(Object key);

    // 查找是否包含关键字 key 是否在顺序表当中（这个和search有点冲突）
    boolean contains(Object key);

    // 得到 pos 位置的值
    Object getPos(int pos);

    // 删除第一次出现的关键字 key
    Object remove(Object key);

    // 得到顺序表的长度
    int size();

    // 打印顺序表
    void display();

    // 清空顺序表以防内存泄漏
    void clear();
}
```

## 初始化

```java
public class MySequence implements ISequence {

    private Object[] elem;
    // 有效数据个数
    private int usedSize;
    //顺序表总长度
    private static final int DEFAULT_SIZE = 10;

    public MySequence() {
        this.elem = new Object[DEFAULT_SIZE];
        this.usedSize = 0;
    }

    public MySequence(int max){
        this.elem=new Object[max];
        this.usedSize=0;
    }
           ........
}
```

## 判断是否为满

```java
/**
     * 判断是否为满
     * @return 满了返回true,否则返回false
     */
    private boolean isFull() {
        return this.elem.length == this.usedSize;
    }
```

## 插入数据

```java
/**
     * 在 pos 位置插入 val
     * @param pos
     *        要插入的位置
     * @param data
     *        要插入的值
     * @return
     *        插入成功返回true，否则返回false
     */
    @Override
    public boolean add(int pos, Object data) {
        // 1. 判断pos位置的合法性
        if (pos < 0 || pos > this.elem.length) {
            return false;
        }

        // 2. 判断是否满了，如果满了进行扩容
        if (isFull()) {
            this.elem = Arrays.copyOf(this.elem, 2*this.elem.length);
        }

        // 3. 把pos位置以及之后的数全部向后挪一个位置
        for (int i = this.usedSize-1; i >= pos; i--) {
            this.elem[i+1] = this.elem[i];
        }

        // 4. 在 pos 位置插入 val
        this.elem[pos] = data;

        // 5. 更新长度
        this.usedSize++;

        return true;
    }
```

## 是否为空

```java
 /**
     * 判断是否为空
     * @return 表为空返回true，否则返回false
     */
    private boolean isEmpty() {
        return this.usedSize == 0;
    }
```

## 查找关键字并返回下标

```java
/**
     * 查找关键字 key 找到返回 key 的下标，没有返回 -1
     * @param key 关键字的值
     * @return 查找成功返回true，失败返回false
     */
    @Override
    public int search(Object key) {
        // 1. 判断是否为空
        if (isEmpty()) {
            return -1;
        }

        // 2. 遍历查找
        for (int i = 0; i < this.elem.length; i++) {
            // 注意：判断条件不能写成：this.elem[i] == key
            if (this.elem[i].equals(key)) {
                return i;
            }
        }
        return -1;
    }
```

## 是否含有关键字Boolean

```java
/**
     * 查找是否包含关键字 key 是否在顺序表当中（这个和search有点冲突）
     * @param key 关键字的值
     * @return 查找成功返回true，失败返回false
     */
    @Override
    public boolean contains(Object key) {
        // 1. 判断是否为空
        if (isEmpty()) {
            return false;
        }

        // 2. 遍历查找
        for (int i = 0; i < this.elem.length; i++) {
            // 注意：判断条件不能写成：this.elem[i] == key
            if (this.elem[i].equals(key)) {
                return true;
            }
        }
        return false;
    }
```

## 取得指定位置的值

```java
/**
     * 得到 pos 位置的值
     * @param pos 得到的值的位置
     * @return 成功得到 pos位置的值返回true，否则返回false
     */
    @Override
    public Object getPos(int pos) {
        // 1. 判断位置是否合法
        if (pos<0 || pos>=this.elem.length) {
            return null;
        }

        // 2. 位置合法
        return this.elem[pos];
    }

```

## 删除第一个出现的关键数据

```java
 /**
     * 删除第一次出现的关键字 key
     * @param key 关键字
     * @return
     */
    @Override
    public Object remove(Object key) {
        // 1. 先查表看有没有这个关键字
        // index:关键字下标
        int index = search(key);

        // 2. 若表里没有这个关键字
        if (index == -1) {
            return null;
        }

        // 3. 表里有这个关键字
        Object data = this.elem[index];
        int i;
        // 删除第一次出现的关键字 key,把key后面的数全部向前挪一个位置
        for (i = index; i < this.usedSize; i++) {
            elem[i] = elem[i+1];
        }
        this.usedSize--;
        this.elem[i+1] = null;
        return data;
    }
```

## 返回顺序表长度

```java
/**
     * 得到顺序表的长度
     * @return 顺序表的长度
     */
    @Override
    public int size() {
        return this.usedSize;
    }
```

## 遍历并打印表

```java
/**
     * 打印顺序表
     */
    @Override
    public void display() {
        for (int i = 0; i < this.usedSize; i++) {
            System.out.print(this.elem[i] + " ");
        }
        System.out.println();
    }
```

## 清空表

```java
/**
     * 清空顺序表以防内存泄漏
     */
    @Override
    public void clear() {
        for (int i = 0; i < this.usedSize; i++) {
            this.elem[i] = null;
        }
    }
```

## 测试

```java
public class Test {
    public static void main(String[] args) {
        MySequence mySequence = new MySequence();

        for (int i = 0; i < 10; i++) {
            mySequence.add(i,i);
        }
        System.out.println("在最大值10的范围内插入数据：");
        mySequence.display();
        System.out.println();

        for (int i = 10; i < 20; i++) {
            mySequence.add(i,i);
        }
        System.out.println("扩容：");
        mySequence.display();
        System.out.println();

        System.out.println("随机位置插入数据：");
        mySequence.add(9,"list");
        mySequence.display();
        System.out.println();

        System.out.println("search查找一个数据："+mySequence.search("list"));
        System.out.println("contains查找一个数据："+mySequence.contains("list"));
        System.out.println();

        System.out.println("查找某一个位置对应的值："+mySequence.getPos(9));
        System.out.println();

        System.out.println("删除一个数据："+mySequence.remove(8));
        mySequence.display();
        System.out.println();

        System.out.println("得到顺序表的长度:"+mySequence.size());
    }
```

![image-20191116112815534](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191116112815534.png)

# 单链表`java`实现

## 概要

链表是一种数据结构，和数组同级。比如，Java中我们使用的`ArrayList`，其实现原理是数组。而`LinkedList`的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。下面对单向链表做一个介绍。

<u>单向链表是一种线性表，实际上是由结点（Node）组成的</u>，一个链表拥有不定数量的节点。

其数据在内存中存储是不连续的，它存储的数据分散在内存中，<u>每个结点只能也只有它能知道下一个结点的存储位置</u>。由N各节点（Node）组成单向链表，每一个Node记录本Node的数据及下一个Node。

向外暴露的只有一个头节点（Head），<u>我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的</u>。
![image-20191116152622801](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191116152622801.png)



 ![这里写图片描述](https://img-blog.csdn.net/20160420141138723) 

上图中最左边的节点即为头结点（Head），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。<u>最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。</u>因为有着不断的引用，所以头节点就可以操作所有节点了。
下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。
 ![这里写图片描述](https://img-blog.csdn.net/20160420134010570) 

节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，<u>节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：</u> 

 ![这里写图片描述](https://img-blog.csdn.net/20160420134000174) 

## 实现

### 构造结点对象

```java
public class MyLink {
    public Node head = null; // 头节点

    /**
     * 链表中的节点，data代表节点的值，next是指向下一个节点的引用
     */
    class Node {
        Node next = null;// 节点的引用，指向下一个节点
        int data;// 节点的对象，即内容

        private Node(int data) {
            this.data = data;
        }
    }
    ....
} 
```

### 向结点插入数据

```java
/**
     * 向链表中插入数据
     */
    public void addNode(int value) {
        Node newNode = new Node(value);// 实例化一个节点
        if (head == null) {
            head = newNode;
            return;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
    }
```

------

测试1：

```java
System.out.println("linkLength:" + list.length());
System.out.println("head.data:" + list.head.data);
System.out.println(list.head.next);
```

![image-20191116182733029](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191116182733029.png)

代码逻辑：手动debug

先初始化头结点：在方法里创建一个结点对象，判断头结点为空之后就把这个对象的引用给头结点，头结点就算初始化了，有了一个data=0，指向向一个结点引用的next为null；

创建第一个结点：也是在方法里创建一个新的结点对象，判断头结点不为空，继续向下执行，把头结点的引用给一个临时结点，这个临时结点判断下一个结点的引用为空，直接就将第一个结点的引用给头结点里的next对象，这一步运行完头结点就丰满了，有了一个数值0，还有第一个结点的引用；但第一个结点只有数值1，引用为null

创建第二个结点：先创建一个新的对象，头结点不为空，把头结点引用给一个临时结点，这个的结点的引用不为空，也就是存在第一个结点的地址，那就把第一个结点的地址又给这个临时结点，由这个临时结点判断第一个结点里的引用是null，那就把第二个结点的引用给第一个结点的next对象；

。。。。。。

依次类推直到最后一个结点

小测试2

```java
 MyLink list = new MyLink();
        list.addNode(0);
        list.addNode(1);
        list.addNode(2);
        System.out.println("linkLength:" + list.length());
        System.out.println("head.data:" + list.head.data);
        System.out.println(list.head);
        System.out.println(list.head.next.next);
        System.out.println(list.head.next.next.next);
```

![image-20191116184244985](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191116184244985.png)

头结点有地址，有引用；但是尾结点只有地址没有引用。



**第一次addNode方法调试：**

![image-20191116173658909](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191116173658909.png)

**第二次addNode方法调试：**

![image-20191116173907646](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191116173907646.png)

**第三次addNode方法调试：**

![image-20191116174052888](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191116174052888.png)

​                                                   。。。。。。。。。。。。。。。。。。。。。。

**最后一次：第五次addNode方法调试：**

![image-20191116174318568](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191116174318568.png)

从输出和调试结果可以看出头结点的data是0，自己的地址是671，存在下一个结点的引用672，结点互相串联在一起，最后一个结点的自己的引用地址为676，没有下一个结点的引用地址了null

### 删除指定位置节点

这个程序有问题

```java
/**
     *
     * @param index:删除第index个节点
     */
    public boolean deleteNode(int index) {
        if (index < 1 || index > length()) {
            return false;
        }
        if (index == 1) {
            head = head.next;
            return true;
        }
        int i = 2;
        //头结点的引用
        Node preNode = head;
        //第一个结点的引用
        Node curNode = preNode.next;
        while (curNode != null) {
            if (i == index) {
                preNode.next = curNode.next;
                return true;
            }
            preNode = curNode;
            curNode = curNode.next;
            i++;
        }
        return false;
}
```

思路：

链表和数组不一样，链表应该是从1开始的，那么在删除结点的时候我们就要先排除非法输入，如果输入比1还小的数或比链表长度还大的数就返回false；

删除头结点：如果是等于1的话，就是删除头结点，那么就直接把头结点的引用，也就是第一结点的地址给头结点就好了，头结点的原本地址被第一个结点的地址覆盖，就删除了。

如果是删除其他结点

删除第二个为例：

进入循环，先判断第一结点地址为null吗，有第一结点才向下执行，如果index=2，i=2，此时判断条件成立，那么就把第一个结点的引用给头结点，也就是用第二个结点的地址覆盖掉第一个结点的地址，那么第一个结点就被删除了，这样头结点的引用也变成了原来第二个结点的引用

删除第二个结点，但是没有第三个结点的情况：

也是进入if判断，为true，然后把第二行结点的引用给第一个结点，那第一个结点就变为null，但null也是值，只是在打印的时候判断不打印为null的值出来

### 返回结点长度

```java
/**
     * @return 返回节点长度
     */
    public int length() {
        int length = 0;
        Node temp = head;
        while (temp != null) {
            length++;
            temp = temp.next;
        }
        return length;
    }
```

思路：

从头结点地址开始访问，如果存在就继续访问下一个，让长度加1，知道下一个结点的地址为空，那么链表的长度也出来了

### 未知头指针删除结点

```java
    /**
     * 在不知道头指针的情况下删除指定节点
     */
    public boolean deleteNode11(Node n) {
        if (n == null || n.next == null)
            return false;
        int tmp = n.data;
        n.data = n.next.data;
        n.next.data = tmp;
        n.next = n.next.next;
        System.out.println("删除成功！");
        return true;
    }
```

### 打印结点数据

```java
 public void printList() {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data+" ");
            temp = temp.next;
        }
    }
```

思路：和返回结点长度的思路一样，挨个结点判断地址是否存在，存在就输出该结点携带的值，不存在了就

结束打印的循环

### 测试

```java
 public static void main(String[] args) {
        MyLink list = new MyLink();
        list.addNode(0);
        list.addNode(1);
        list.addNode(2);
        list.addNode(3);
        list.addNode(4);
        System.out.println("linkLength:" + list.length());
        System.out.println("head.data:" + list.head.data);


        list.printList();
        System.out.println();
        System.out.println("After deleteNode(4):");
        list.deleteNode(4);
        list.printList();
        System.out.println();
        System.out.println("After deleteNode(1):头结点");
        list.deleteNode(1);
        list.printList();
    }
```

**输出：**

![image-20191116190203439](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191116190203439.png)

> **结点计数是从1开始的**

# 单链表的整表创建

## 头插法

先创建第一个结点，让它为头结点；接着又创建第二个结点，把第一个结点的引用给第二个结点，并把第二个结点又设置为头结点；接着又创建第三个结点，把第二个结点的引用给第三个结点，再把第三个结点设置为头结点，以此类推。。。。。。

```java
public class Link {
    //创建一个存储数据的属性
    private int data;
    //创建存储下一个节点地址的属性
    private Link next;
    static int length=0;
    /**
     * 创建一个链表
     * @param len  产生数据的长度
     * @return  链表第一个节点地址
     */
    public static Link create(int len){
        //定义随机对象
        Random r=new Random();
        //定义链表的节点
        Link newnode,header;
        //header永远存储第一个节点的地址，tailer永远存储最后一个节点的地址
        header=null;
        for (int i = 0; i < len; i++) {
            //生成一个[0-100)的随机数字
            int temp=r.nextInt(100);
            //创建一个临时节点
            newnode=new Link();
            //长度
            length++;
            //为属性赋值
            newnode.data=temp;
            //判断当前链表是否第一次赋值
            if(header==null){
                header=newnode;
            }else{
                //将新节点连接到链表的头部
                newnode.next=header;
                //header永远存储第一个节点的地址
                header=newnode;
            }
        }
        return header;
    }
```

![image-20191117152131115](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191117152131115.png)

思路：先输入一个数字确定链表的长度，然后开始循环创建结点，第一次创建第一个临时结点，给这个结点初始化一个随机值23，如果头结点为空就把这个结点的引用给头结点，这样头结点就有了一个数据23，但引用next为null；第二次循环又创建第二个临时结点(`newNode`与第一个结点对象的引用断开，第一个结点对象被释放)，给这个结点初始化数据为27，这时头结点不为空，就把头结点的引用给临时结点的引用，这时这个临时结点就有了数据27和头结点的地址引用，再把这个临时结点的引用给头结点，头结点的地址就被这个临时结点的地址覆盖(头结点对第一个结点的引用断开，指向第二个结点)，有了第二个临时结点携带的内容(第二个结点的数据和第一个结点的引用地址)；然后创建第三个结点，以此类推，header永远存储第一个节点的地址，最后一个结点的引用next为null，这就是头插法

```java
 public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        System.out.println("输入长度：");
        int len=sc.nextInt();
        System.out.println("打印数组：");
        //调用数组生成方法 传入键盘值l
        Link head=Link.create(len);
        for (int i = 0; i < Link.length; i++) {
            System.out.print(head.data+" ");
            //把当前对象的下一个对象地址传给当前对象
            head=head.next;
        }
    }

```

![image-20191116200436903](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191116200436903.png)

## 尾插法

```java
public class Link {
    //创建一个存储数据的属性
    private int data;
    //创建存储下一个节点地址的属性
    private Link next;
    private static int length=0;
    /**
     * 创建一个链表
     * @param len  产生数据的长度
     * @return  链表第一个节点地址
     */
    public static Link create(int len){
        //定义随机对象
        Random r=new Random();
        //定义链表的节点
        Link newnode,header,tailer;
        //header永远存储第一个节点的地址，tailer永远存储最后一个节点的地址
        header=tailer=null;
        for (int i = 0; i < len; i++) {
            //生成一个随机数字
            int temp=r.nextInt(100);
            //创建一个临时节点
            newnode=new Link();
            //长度
            length++;
            //为属性赋值
            newnode.data=temp;
            //判断当前链表是否第一次赋值
            if(header==null){
                header=tailer=newnode;
            }else{
                //将新节点连接到链表的尾部
                tailer.next=newnode;
                //tailer永远存储最后一个节点的地址
                tailer=newnode;
            }
        }
        return header;
    }
```

**尾插法： 尾插法相对于头插法有些许不同 因为要返回头 头不能动 所以需要一个tailer来记录最后一个值 tailer右移**

```java
 public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        System.out.println("输入长度：");
        int len=sc.nextInt();
        System.out.println("打印数组：");
        //调用数组生成方法 传入键盘值l
        Link head=Link.create(len);
        for (int i = 0; i < Link.length; i++) {
            System.out.print(head.data+" ");
            //把当前对象的下一个对象地址传给当前对象
            head=head.next;
        }
    }
```

![image-20191117162119675](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191117162119675.png)

![image-20191117163514763](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191117163514763.png)





这里可以比较一下两种方法的不同：

![image-20191117162359757](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191117162359757.png)



## 疑问

在每次`newnode=new Link()`一个对象后，`newnode`引用的对象就会发生改变，那么之前那个节点就失去了引用，这个结点会被垃圾回收机制回收吗？

不会，因为失去名字的结点虽然没有名字了，但是他的地址还存在上一个结点的next对象里，相当于它的名字最终就是next

