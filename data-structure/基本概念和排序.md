# 时间复杂度

简单来说就是用来描述一个程序运行的时间长短

![image-20191110152209479](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110152209479.png)

分析程序怎么运行：

蓝色框运行1次；黑色框运行n+1次(最后还要比较就多一次)；红色框运行n次；

总的运行次数=`1+1+(n+1)+2n=3n+3`次；程序的消耗时间和n呈线性关系

![image-20191110152609615](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110152609615.png)

在计算比较中 一般只关心随着问题规模n趋于无穷时函数中对函数结果影响最大的项，**也就是最高次项** 

![image-20191110152716587](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110152716587.png)

由图知： `T(n)=3n+3`,当n非常大的时候常数3和n的系数3对函数结果的影响就很小了 

比如：                             

`T(n)=n+1` 忽略常数项 `T(n)~n`          

`T(n)=n+n^2` 忽略低阶项 `T(n)~n^2`     

`T(n)=3n` 忽略最高阶的系数`T(n)~n ` 

所谓低阶项，简单地说就是当n非常大时，这个项相对于另外一个项很小，可以忽略，比如n相对于n^2,n就是低阶项 

## **函数大小关系**

![image-20191110152919552](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110152919552.png)

1. 常见的算法时间复杂度由小到大依次为：上图所示。随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低
2. 我们应该尽可能避免使用指数阶的算法 

## **时间复杂度的表示**

简化后的式子被称为这个程序算法的时间复杂度，记做`O(f(n))`,`f(n)`就是简化后的式子，比如说刚开始讨论的`T(n)=3n+3`,简化后`T(n)~f(n)=n`,那我们记为`O(n) `

> <u>更准确地说O代表了运行时间函数的一个渐进上界，即T(n)在数量级上小于等于f(n)</u>
>
> **对这句话我并不理解，数量级小于？**

## **什么叫数量级**

数量级释义：用来量度或估计某些物理量大小的一种概念。当一个物理量的数值写成以10为底的指数表达式时，指数的数目就是这个物理量的数量级。

例如地球赤道半径为6378千米，可以写成6.378×103千米或6.378×106米。就千米来说，它的数量级是3；就米来说，它的数量级是6。

需要特别注意的是：数量级应用范围必须是正数或自然数！尽管负数也可以计算数量级，没有实际的意义。比如：-10和-1000这两个数从纯数学角度说相差100倍，不过不能说这两个数相差2个数量级。

## **时间复杂度的计算** 

 一、得出运行时间的函数  

①用常数1来取代运行时间中所有加法常数 

②修改后的函数中，只保留最高阶项      

③如果最高阶项存在且不是1，则忽略这个项的系数 

 二、对函数进行简化     

比如：

![image-20191110155550666](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110155550666.png)

显然，T(n)=3,对这个函数进行简化，用常数1取代常数3，然后取代后的函数没有最高阶项，那么这个算法的时间复杂度就是O(1). **O(1)也被称为常数阶**

**每次都这么计算显然很麻烦：**

可以耍耍小聪明，一般来说，最内层执行次数最多的语句就决定了整个算法的趋势 

![image-20191110155710793](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110155710793.png)

只要看看最内层的语句执行次数的规律就行了，这个内层打印语句随着问题规模n的增加会呈线性增加，直接就可以判定复杂度为O(n) 

再比如：

![image-20191110155734398](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110155734398.png)

按照这个方法就很容易得出下面这个嵌套的两层for循环的复杂度为O（n^2了 

最内层的语句随n的增加会呈二次函数的规律执行，代表了这个算法执行时间的一个趋势 

## **对数函数计算示例**

 对数函数的趋势显然比线性函数好(对数函数随着自变量的增大因变量增长的很慢) 

![image-20191110155917352](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110155917352.png)

怎么计算下面函数的时间复杂度

![image-20191110155936941](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110155936941.png)

 这段代码的复杂度就为对数级别的，`O(logn)` ，怎么分析？

![image-20191110160017870](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110160017870.png)

每循环一次，sum就给自身乘以2，乘了多少次就跳出循环了呢(大于等于n)？不知道，就设为x吧，那么`2^x=n`,解出`x=logn`，这说明随着n的增大，最消耗时间的内层语句是呈对数变化的 

## 常见的时间复杂度

1.  常数阶 `O(1)`
2. 对数阶 `O(log2n)`
3.  线性阶 `O(n)`
4. 线性对数阶 `O(nlog2n)`
5. 平方阶 `O(n^2)`
6. 立方阶 `O(n^3)`
7. k 次方阶 `O(n^k)`
8. 指数阶` O(2^n)`

## 空间复杂度 

 时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的 

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。 

------

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)

举例： 

 空间复杂度比较常用的有：O(1)、O(n)、O(n²) 

 **空间复杂度 O(1)** 

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

 代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1) 

 **空间复杂度 O(n)** 

```java
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n) 



# 直接插入排序

所谓直接插入排序，就是把未排的元素一个个的插入到有序的集合中，把有序集合从后到前扫一遍，然后插入到合适的位置中



直接插入排序：

基本思想：

1. 在要排序的一组数中，假设前面(n-1)[n>=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。

2. 直接插入排序是由两层嵌套循环组成的。外层循环标识并决定待比较的数值。

3. 内层循环为待比较数值确定其最终位置。<u>直接插入排序是将待比较的数值与它的前一个数值进行比较，所以外层循环是从第二个数值开始的</u>。当前一数值比待“比较数值”大的情况下继续循环比较

4. 直到找到比待“比较数值”小的并将待比较数值置入其后一位置，结束该次循环。

 *  时间复杂度：`O(n2)`
 * 空间复杂度：`O(1)`

```java
public class Main {
    public static void main(String[] args) {
        int[] arr={5,8,3,9};
        insertSort(arr);
        print(arr);
    }

    //直接插入排序
    private static void insertSort(int[] arr){

        //外层循环确定待比较数值
        //必须i=1，因为开始从第二个数与第一个数进行比较
        for (int i=1;i<arr.length;i++) { 
            int temp = arr[i];             //待比较数值
            int j = i - 1;                 //与前一个数值比较
            
            //内层循环为待比较数值确定其最终位置
            for (;j>=0 && arr[j]>temp;j--) {   //待比较数值比前一位置小，应插往前插一位
                
                arr[j+1] = arr[j];             //将大于temp的值整体后移一个单位
            }
            arr[j+1] = temp;                   //待比较数值比前一位置大，最终位置无误
        }

    }

    private static void print(int[] arr){
                    for (int i:arr) {
                        System.out.print(i + "  ");
                    }
    }
}


```

![image-20191110170308203](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110170308203.png)

**代码文字debug：**

从第二个数开始往前比较。把8存到temp里，5>8为false，不作变化，第二次循环从3开始比较，8>3为true，把8的位置向后移一位，j--，再比较5>3为true，把5的位置向后移动1位，再把3设置到第一位，最后8>9为false，不作变化

**函数的意义：**

**第一个for循环**

我们要插入排序自然要先把我们准备排序的值取出来，那这个循环就可以遍历数组取到值

**temp**

把待比较值与其他数值比较的数组单独存在temp里，在数值向后移动的时候会覆盖了待比较值，所以作用就是留下一个存档

**j--**

当待比较值比它前一个数小的时候，那个数后移一位，那待比较值就应该继续向它前面的数比较，直到比较到第一位j<0之后比较结束，j就是数组的索引

**第二个for循环**

由第一个循环取值出来，这个循环就添加数值比较的逻辑，然后实行插入排序的效果

**arr[j+1] = temp**

当跳出第二个循环时就会执行这条语句，也就是当已经比较完数组中的第一个数了或者是在比较时遇到前面的那个数更小的时候就是执行的条件

**int j=i-1**

把j这个变量单独踢出来可以减少代码的耦合度，j变量的作用范围更广

## 图解

![image-20191110185536967](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110185536967.png)

![image-20191110185609718](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110185609718.png)

![image-20191110185628328](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110185628328.png)

这段代码最耗时的地方就花在最内层for循环里面的操作上（比较和移动）了，我只要大概估算出这些操作执行的次数就可以了 

对于n个元素，首先我的外层for循环要循环n-1次

![img](https://mmbiz.qpic.cn/mmbiz_png/zrIoKPEFItepfKib7z5icayxuFfDRC3icAdDQpK9upZcEhtg2UHdibclVqibhUKJsl3AapEJfLdyByIDsDQo0A2HFdA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

然后`insertSort`里的内层for循环的循环次数是根据 i 来决定的，i = 1时,循环 1 次，i = 2,循环 2 次，...，i = n-1,循环 n-1次，那总共加起来就是 

![img](https://mmbiz.qpic.cn/mmbiz_png/zrIoKPEFItepfKib7z5icayxuFfDRC3icAdX1Jkwg6bticn0oP2YPTsRfL8hjibku4kQ2XJwib7IgLUjErvRlEqNQniaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 根据复杂度计算规则，保留高阶项，并去掉系数，那么时间复杂度为O(n^2) 

## 稳定性 

 是稳定的，因为在比较的时候，过两个数相等的话，不会进行移动，前后两个数的次序不会发生改变 

![image-20191110185914501](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110185914501.png)

## 使用场景

小规模数据或基本有序的数据使用起来十分高效，但一般的数据都是很大且无序的，如果遇到数据量中等的情况下就可以使用希尔排序

# 希尔排序

思路：

首先它把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高 

![image-20191113212920811](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191113212920811.png)

颜色相同的就是逻辑上的分组，但是数组里数据的位置还是原来的没有变化

可以看出，他是按下标相隔距离为4分的组，也就是说把下标相差4的分到一组，比如这个例子中a[0]与a[4]是一组、a[1]与a[5]是一组...，这里的差值（距离）被称为增量 

![image-20191113212945872](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191113212945872.png)

 每个分组进行插入排序后，各个分组就变成了有序的了（整体不一定有序） 

![image-20191113213014923](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191113213014923.png)

 此时，整个数组变的部分有序了（有序程度可能不是很高） 

![image-20191113213129562](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191113213129562.png)

 然后缩小增量为上个增量的一半:2，继续划分分组，此时，每个分组元素个数多了，但是，数组变的部分有序了，插入排序效率同样比高 

![image-20191113213204145](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191113213204145.png)

 同理对每个分组进行排序（插入排序），使其每个分组各自有序 

![image-20191113213230436](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191113213230436.png)

最后设置增量为上一个增量的一半：1，则整个数组被分为一组，此时，整个数组已经接近有序了，插入排序效率高 

![image-20191113213307902](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191113213307902.png)

```java
private static void shellSort(int[] arr){
        //进行分组
        int N=arr.length;
        //对各个分组进行插入排序
        for (int gap=N/2;gap>0;gap/=2){
            for (int i=gap;i<N;i++){
                //插入到正确位置
                insertI(arr,gap,i);
            }
        }
    }
    private static void insertI(int[] arr,int gap,int i){
        int inserted =arr[i];
        int j;
        for (j=i-gap;j>=0&&inserted<arr[j];j-=gap){
            arr[j+gap]=arr[j];
        }
        arr[j+gap]=inserted;
    }
```

