# 常见算法的稳定性

堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。

# 稳定性的意义

1. 如果只是简单的进行数字的排序，那么稳定性将毫无意义。
2. 如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义
3. 如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。
4. 除非要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序。（当然，如果需求不需要保持初始的排序意义，那么使用稳定性算法依旧将毫无意义）
5. 换句话说，以某种关键字的方式排序后，能不影响到其他关键字原来排序结果的方法就是稳定的，比如一开始按照价格高低排序结果为 a(10元，卖了5个) b(8元，卖了20个) c(6元，卖了20个) d(4元，卖了30个),则按照销量重拍后如果保持 d(30个,价格为4元) b(20个，价格为8元) c(20个，价格为6元) a(5个，价格为10元)，则说明该方法为稳定的，而如果出现c在b前，破坏了排序前b在c前的顺序，则说明这个方法是不稳定的



# 冒泡排序

```java
static void sort1(int[] array){
    //外循环每循环一次就确定一个有序数，总的需要确定n-1个，剩下的一个自然有序了
    for (int i = 0; i < array.length-1; i++) {
        //两两比较，如果有两个数，需要比较一次；三个数需要比较两次
        //n个数第一次比较n-1次,第二次比较n-2次
        //i代表确定的有序数，有i个有序数就少比较i次
        for (int j = 0; j < array.length-1-i; j++) {
            //如果前一个数大于后一个数就交换
            if (array[j]>array[j+1]){
                int temp=array[j+1];
                array[j+1]=array[j];
                array[j]=temp;
            }
        }
    }
}
```

## 优化一

如果数据在循环结束之前已经有序了就提前终止循环

```java
static void sort2(int[] array){
        for (int i = 0; i < array.length - 1; i++) {
            //用来标记是否终止循环
            boolean start=true;
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j]>array[j+1]){
                    int temp=array[j+1];
                    array[j+1]=array[j];
                    array[j]=temp;
                    //只要内循环结束有数据交换就证明排序未完成
                    start=false;
                }
            }
            //反之，内循环里没有数据交换说明数据已经有序，可以退出
            if (start) break;
        }
    }
```

这种优化只对基本有序的数据排列有效，如果是大量无序，那么start标记可能一直都没有作用，还多了两个赋值操作，一个判断操作，还浪费空间

## 优化二

```java
  static void sort3(int[] array){
        int len=array.length;
        //ordered表示有序数数量
        for (int ordered = 0; ordered <len-1; ordered++) {
            //用来统计已经有序的有序数,默认为最好的情况，全都是排好序的
            int sortIndex=len;
            for (int j = 0; j < len - 1 - ordered; j++) {
                if (array[j]>array[j+1]){
                    int temp=array[j+1];
                    array[j+1]=array[j];
                    array[j]=temp;
                    //最后一次执行还有j个数无序
                    sortIndex=(len-j-2);
                }
            }
            //如果是最好的情况
            ordered=sortIndex;
        }
    }
```

但是这里要进行`sortIndex=(len-j-2);`两次减法操作，很耗性能，也不是最佳的解决办法

## 优化三

从逆向开始循环，记录无序数的个数，从第二个开始进行与它前面的数的比较

```java
static void sort4(int[] array) {
        //disorder记录的是未排好序的数的数量
        for (int disorder = array.length-1; disorder >0 ; disorder--) {
            //记录每次循环后未排好序的数量
            int sortIndex=0;
            //每次只用循环访问到最后一个无序数,disorder之后的数已经有序了
            for (int begin = 1; begin <=disorder; begin++) {
                if (array[begin]<array[begin-1]){
                    int temp=array[begin];
                    array[begin-1]=array[begin];
                    array[begin]=temp;
                    //循环结束之后begin=无序数数量+1个有序数
                    sortIndex=begin;
                }
            }
            //end再进行减减操作就是未排序的数量
            disorder=sortIndex;
        }
    }
```

`sortIndex=begin;`操作和`disorder--`操作正好匹配，得到的正好就是无序数的数量

# 选择排序

```java
static void sort1(int[] array){
    //数组长度
    int len=array.length;
    for (int i = 0; i < len-1; i++) {
        //记录每一轮比较后最大值的下标
        int maxIndex=0;
        //j从1开始
        for (int j = 1; j < len - i; j++) {
            //默认第一个数最大，与后面的数依次比较
            //为了使算法具有稳定性，大小相等时也要交换最大值下标
            if (array[maxIndex]<=array[j]){
                //记录每次比较后较大值的下标
                maxIndex=j;
            }
        }
        //比较结束后与无序数列的最后一个值交换位置
        int temp=array[maxIndex];
        array[maxIndex]=array[len-1-i];
        array[len-1-i]=temp;
    }
}
```

优化:从第二个数开始往前比较更好

```java
static void sort2(int[] array){
    //一开始整个数组都是无序的，disorder记录数组的最后一个无序数下标
    //最小的下标都要大于零
    for (int disorder =array.length-1 ; disorder >0 ; disorder--) {
        //记录一轮内循环后最后值的下标
        int maxIndex=0;
        //从第二个数比到最后一个数，遇到较大的数就记录其下标
        for (int begin = 1; begin <= disorder; begin++) {
            if (array[maxIndex]<array[begin]){
                //循环结束得到的就是最大值下标
                maxIndex=begin;
            }
        }
        //最大值交换到无序数列最后
        int temp=array[maxIndex];
        array[maxIndex]=array[disorder];
        array[disorder]=temp;
    }
}
```

# 堆排序

可以看做是对选择排序的优化，这是不稳定的排序

```java
public class HeapSort extends Sort {
    //堆的大小
    private int heapSize;
    @Override
    protected void sort() {
        //先进行原地建堆
        //初始化堆的大小
        heapSize=array.length;
        //采用自下而上的下溢,从最后一个非叶子结点开始
        for (int notLeaf = (heapSize>>1)-1; notLeaf >=0 ; notLeaf--) {
            siftDown(notLeaf);
        }

        //堆建好之后把堆顶元素依次与最后一个元素交换
        //起码得有两个元素才能进行交换
        while (heapSize>1){
            //把heapSize-1和heapSize--的操作合并
            swap(0,--heapSize);
            //对0位置进行siftDown（恢复堆的性质）
            siftDown(0);
        }
    }

    private void siftDown(int index){
        //先取出要下溢的元素
        int element=array[index];
        //明确只有非叶子结点才需要进行下溢
        //非叶子结点的数量
        int notLeaf=heapSize>>1;
        //下溢结点必须在非叶子结点的范围
        while (index<notLeaf){
            //取出左孩子节点的位置和元素
            int childIndex=(index<<1)+1;
            int maxChild=array[childIndex];
            //判断是否有右孩子
            int rightIndex=childIndex+1;
            if (rightIndex<heapSize&&compare(childIndex,rightIndex)<0){
                maxChild=array[rightIndex];
                childIndex=rightIndex;
            }
            //用的大孩子节点和父节点比价
            if (element>array[childIndex]) break;
            //用大的孩子节点覆盖父节点的值
            array[index]=maxChild;
            //index指针下移
            index=childIndex;
        }
        array[index]=element;
    }
}
```

# 插入排序

```java
protected void sort1() {
    for (int begin = 1; begin < array.length; begin++) {
        //摸出第二张牌和手里的一张牌比较
        //再摸出第三张牌和前面的两张牌依次再比较
        for (int i = begin; i >0 ; i--) {
            //比前一张牌小就交换位置
            if (compare(i,i-1)<0){
                swap(i,i-1);
            }
        }
    }
```

## 优化一

**将交换改为挪动，逆序对越多优化越明显**

```java
protected void sort2(){
        for (int begin = 1; begin < array.length; begin++) {
            //先备份数据
            int save=array[begin];
            //备份数据的起始位置，也是最终位置
            int cur=begin;
            for (int j = begin; j >0 ; j--) {
                if (save<array[j-1]){
                    //往后挪动一位
                    array[j]=array[j-1];
                    //备份数据现在的实际位置
                    cur--;
                }else {
                    //begin前面都是有序的
                    //备份数据不比前面的数小就提前退出
                    break;
                }
            }
            //放回实际位置
            array[cur]=save;
        }
    }
```

**可以把for循环改成while循环**

```java
private void sort3(){
    for (int begin = 1; begin < array.length; begin++) {
        //取出待插入元素备份
        int save=array[begin];
        //待插入元素该插入的位置
        int cur=begin;
        while (cur>0&&save<array[cur-1]){
            array[cur]=array[cur-1];
            cur--;
        }
        array[cur]=save;
    }
```

# 二分搜索

```java
public class BinarySearch {
    //传入数组和元素，返回这个元素在数组中的下标
    public static int indexOf(int[] array,int element){
        //起点
        int begin=0;
        //终点
        int end=array.length;
        //搜索范围[begin,end)
        //end-begin==元素的总数
        while (begin<end){
            //中点
            int mid=(end+begin)>>1;
            //从中间开始比较
            if (element<array[mid]){
                //begin的位置不变，end改变
                end=mid;
            }else if (element>array[mid]){
                //end的位置不变，begin改变
                begin=mid+1;
            }else {
                //找到该元素
                return mid;
            }
        }
        //该元素不存在
        return -1;
    }
}
```



