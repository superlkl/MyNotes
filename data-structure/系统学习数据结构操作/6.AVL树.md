# AVL树 

-  AVL树是最早发明的自平衡二叉搜索树之一
-  AVL 取名于两位发明者的名字 G. M. Adelson-Velsky 和 E. M. Landis（来自苏联的科学家）
-  Something interesting 有人把AVL树念做“艾薇儿树”
- 平衡因子（Balance Factor）：某结点的左右子树的高度差 
-  AVL树的特点 
  - 每个节点的平衡因子只可能是 1、0、-1（绝对值 ≤ 1，如果超过 1，称之为“失衡”） 
  - 每个节点的左右子树高度差不超过 1 
  - 搜索、添加、删除的时间复杂度是 O(logn)

## 添加导致的失衡

- 最坏情况：可能会导致所有祖先节点都失衡 
-  父节点、非祖先节点，都不可能失衡

## LL – 右旋转（单旋）



## RR – 左旋转（单旋)



## LR – RR左旋转，LL右旋转（双旋)



## RL – LL右旋转，RR左旋转（双旋)



## 步骤

1. AVL数相当于是`BST`树的升级版，需要在每次添加结点之后判断是否平衡（也就是平衡因子是否小于等于1），添加逻辑在`BST`树里，实现逻辑要在AVL树里，那么在`BST`树里写一个空的`afterAdd`方法让AVL重写这个方法实现里面的逻辑即可
2. 对于AVL树，要根据左右子树的高度差来计算平衡因子，定位到失衡的那个结点，那么height这个结点属性就必不可少，但`BST`树并不需要这个属性，最好的办法就是在AVL树里重写一个AVLNode继承`BST`树里的结点，再单独为AVLNode添加这个特有的属性
3. 对于AVLNode应该针对height再设计一个更新高度的方法，判断是否平衡的方法
4. 对于`afterAdd`方法，首先要判断是否平衡`isBalance`，如果不平衡就恢复平衡`reBalance`，添加的新结点必为叶子结点，高度自然为一，所以要判断是否平衡起码要从该结点的父节点`parent`开始判断，如果平衡，还可以顺便把该父节点`parent`的高度进行一次更新，一直往上更新直到AVL树的根节点或遇到失衡的结点
5. 对于失衡的结点要恢复平衡`reBalance`，我们要判断是四种失衡类型的哪一种，再根据对应的情况调整；另一种思路就是找到中间的b,c,d,e,f五个结点（就是按照中序遍历过来的五个结点，a,g不管，他们的位置不会改变）对应着不同情况再进行修改

## AVLNode

```java
//AVL-Node
static class AVLNode<E> extends Node<E>{
    //存储结点自己所在位置的高度，一创建就为1
    int height=1;

    AVLNode(E element, Node<E> parent) {
        super(element, parent);
    }

    //计算Node的平衡因子
    public int balanceFactor(){
        //左子树的高度与右子树高度的绝对值为平衡因子
        int leftTree= left == null ? 0: ((AVLNode<E>)left).height;
        int rightTree= right == null ? 0: ((AVLNode<E>)right).height;
        return Math.abs(leftTree-rightTree);

    }

    //更新高度：height是AVLNode的内部属性，要使用left这些引用只能将这个方法写在AVLNode类内部
    public void updateHeight() {
        int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;
        int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;
        //树的总高度等于左右子树的最大高度加一
        height = 1 + Math.max(leftHeight, rightHeight);
    }

    public Node<E> tallerChild(){
        int leftHeight = left == null ? 0 : ((AVLNode<E>)left).height;
        int rightHeight = right == null ? 0 : ((AVLNode<E>)right).height;
        if (leftHeight>rightHeight) return left;
        if (rightHeight>leftHeight) return right;
        //如果左右子树高度相等就返回与其父节点同方向的子树
        return isLeftChild()?left:right;
    }
}
```

## afterAdd

```java
public class AVLTree<E> extends BinaryTree<E> {
    public AVLTree() {
        this(null);
    }

    //可以传入构造器实现自定义比较逻辑
    public AVLTree(Comparator<E> comparator) {
        super(comparator);
    }

    @Override
    protected void afterAdd(Node<E> node) {
        //添加结点后判断是否平衡:叶子结点的高度必为1，那就从其父节点开始判断
        node=node.parent;
        //能进入这里的都是添加后结点的父节点
        while (node!=null){
            //如果平衡就更新该结点高度
            if (isBalance(node)){
                //左右子树的最高者加一，沿着其父节点一路往上更新高度，直到根节点或不平衡结点出现
                updateHeight(node);
            }else {
                //如果不平衡就恢复平衡
                reBalance(node);
            }
            node=node.parent;
        }
    }
```

### isBalance

```java
    //平衡因子小于等于一就是平衡
    public boolean isBalance(Node<E> node){
        return ((AVLNode<E>)node).balanceFactor()<=1;
    }
```

### updateHeight

```java
//更新高度:为什么要封装这个函数，结点强制转换的细节被隐藏，调用代码更好看
private void updateHeight(Node<E> node) {
    ((AVLNode<E>)node).updateHeight();
}
```

### reBalance

```java
    private void reBalance(Node<E> grandpa){
        Node<E> parent=((AVLNode<E>)grandpa).tallerChild();
        Node<E> node=((AVLNode<E>)parent).tallerChild();
        if (parent.isLeftChild()){//L
            if (node.isLeftChild()){//LL
                rotate(grandpa,node,node.right,parent,parent.right,grandpa);
            }
            else {//LR
                rotate(grandpa,parent,node.left,node,node.right,grandpa);
            }
        }
        else {//R
            if (node.isLeftChild()){//RR
                rotate(grandpa,grandpa,node.left,node,node.right,parent);
            }else {//RR
                rotate(grandpa,grandpa,parent.left,parent,node.left,node);
            }
        }
    }
```

## rotate

```java
private void rotate(Node<E> r,//根节点
                    Node<E> b,Node<E> c,
                    Node<E> d,
                    Node<E> e,Node<E> f){
    // 让d成为这棵子树的根节点
    d.parent = r.parent;
    if (r.isLeftChild()) {
        r.parent.left = d;
    } else if (r.isRightChild()) {
        r.parent.right = d;
    } else {
        root = d;
    }

    //b-c
    b.right = c;
    if (c != null) {
        c.parent = b;
    }
    updateHeight(b);

    // e-f
    f.left = e;
    if (e != null) {
        e.parent = f;
    }
    updateHeight(f);

    // b-d-f
    d.left = b;
    d.right = f;
    b.parent = d;
    f.parent = d;
    updateHeight(d);

}
```