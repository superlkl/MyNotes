# 循环队列

何谓循环队列？首先我们要说明的是**循环队列仍然是基于数组实现**的。但是为了形象化的说明问题，我们如下图所示

![img](https://images2015.cnblogs.com/blog/991470/201701/991470-20170104151923222-1186136905.png)

1. 图中有两个指针(其实就是两个整数型变量，因为在这里有指示作用，所以这里理解为指针)front、rear,一个指示队头，一个指示队尾。
2. rear和front互相追赶着，这个追赶过程就是队列添加和删除的过程，如果rear追到head说明队列满了，如果front追到rear说明队列为空。
3. 我们把它掰弯，用的是求余，这样两个值就不会跑出最大范围，并且可以实现弯曲的效果，所以说对于循环队列我们必须给定容量capacity。

- 这其实是我们臆想的，反正我们要做的就是利用循环来解决空间浪费的问题。
  
  

**在这里，我简单做几点说明:**

- `front`：表示队列队首，始终指向队列中的**第一个**元素（当队列空时，`front`指向索引为0的位置）
- `tail`：表示队列队尾，始终指向队列中的**最后一个**元素的**下一个位置**
- 元素入队，维护`tail`的位置，进行`tail++`操作
- 元素出队，维护`front`的位置，进行`front++`操作



>**上面所说的，元素进行入队和出队操作，都简单的进行`++`操作，来维护`tail`和`front`的位置，其实是不严谨的，正确的维护`tail`的位置应该是`(tail + 1) % capacity`，同理`front`的位置应该是`(front + 1) % capacity`，这也是为什么叫做循环队列的原因，大家先在这里知道下，暂时不理解也没关系，后面相信大家会知晓。**



现在，我们再来几个元素`b、c、d、e`进行入队操作，看一下此时的示意图：

![image-20190321012501661](https://segmentfault.com/img/remote/1460000018665652)

元素`a`出队，示意图如下：

![image-20190321012912749](https://segmentfault.com/img/remote/1460000018665653?w=1570&h=744)

现在元素`a`已经出队，`front`的位置指向了索引为`1`的位置，现在数组中所有的元素不再需要往前挪动一个位置

这一点和我们的数组队列（我们的数组队列需要元素出队，后面的元素都要往前挪动一个位置）完全不同，我们只需要改变一下`front`的指向就可以了，由之前的O(n)操作，变成了O(1)的操作



我们再次进行元素`b`出队，示意图如下：

![image-20190321014047456](https://segmentfault.com/img/remote/1460000018665654?w=1606&h=776)

为什么叫做，循环队列？那么现在我们尝试一下，我们让元素`f、g`分别进行入队操作，此时的示意图如下：

![image-20190321015054219](https://segmentfault.com/img/remote/1460000018665655)

如果此时，我们再让一个元素`h`元素进行入队操作，那么`问题来了`我们的`tail`的位置该如何指向呢？示意图如下：

![image-20190321020004501](https://segmentfault.com/img/remote/1460000018665656)

根据我们之前说的，元素入队：维护`tail`的位置，进行`tail++`操作，而此时我们的`tail`已经指向了索引为`7`的位置，如果我们此时对`tail`进行`++`操作，显然不可能（数组越界）



细心的小伙伴，会发现此时我们的队列并没有满，还剩两个位置（这是因为我们元素出队后，当前的空间，没有被后面的元素挤掉），大家可以把我们的数组想象成一个环状，那么索引`7`之后的位置就是索引`0`



如何才能从索引`7`的位置计算到索引`0`的位置，之前我们一直说进行`tail++`操作，笔者也在开头指出了，这是不严谨的，应该的是`(tail + 1) % capacity`这样就变成了`(7 + 1) % 8`等于 0



所以此时如果让元素`h`入队，那么我们的`tail`就指向了索引为`0`的位置，示意图如下：

![image-20190323120553239](https://segmentfault.com/img/remote/1460000018665657)

假设现在又有新的元素`k`入队了，那么tail的位置等于`（tail + 1） % capacity `也就是`（0 + 1）% 8 `等于`1`就指向了索引为`1`的位置

![image-20190323123428055](https://segmentfault.com/img/remote/1460000018665658)



那么问题来了，我们的循环队列还能不能在进行元素入队呢？我们来分析一下，从图中显示，我们还有一个索引为`1`的空的空间位置，也就是此时`tail`指向的位置



按照之前的逻辑，假设现在能放入一个新元素，我们的`tail`进行`(tail +1) % capacity`计算结果为`2`（如果元素成功入队，此时队列已经满了），此时我们会发现表示队首的`front`也指向了索引为`2`的位置



如果新元素成功入队的话，我们的`tail`也等于`2`，那么此时就成了 `tail == front` ，一开始我们提到过，当队列为空的`tail == front`，现在呢，如果队列为满时`tail`也等于`front`，那么我们就无法区分，队列为满时和队列为空时收的情况了



所以，在循环队列中，**我们总是浪费一个空间，来区分队列为满时和队列为空时的情况**，也就是当 `( tail + 1 ) % capacity == front`的时候，表示队列已经满了，当`front == tail`的时候，表示队列为空。

![image-20190323124927705](https://segmentfault.com/img/remote/1460000018665659)

## 代码

```java
package 对列;

import java.util.Arrays;

//循环对列
@SuppressWarnings("unchecked")
public class CircleQueue<E> implements Queue<E> {
    //存储队首下标
    private int front;
    //存储队尾下标
    private int tail;
    //对列大小
    private int size;

    private E[] queue;

    private final static int DEFAULT_CAPACITY=5;

    CircleQueue(){
        queue= (E[]) new Object[DEFAULT_CAPACITY];
    }
    CircleQueue(int capacity){
        queue= (E[]) new Object[capacity];
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size==0;
    }

    @Override
    public void clear() {
        size=0;
    }

    @Override
    public void enQueue(E element) {
        enSureCapacity();
        queue[tail]= element;
        tail=(tail+1)%queue.length;
        size++;
    }

    @Override
    public E deQueue() {
        E removing=queue[front];
        queue[front]=null;
        front=(front+1)%queue.length;
        size--;
        enSureCapacity();
        return removing;
    }

    @Override
    public E front() {
        return queue[front];
    }
    private void enSureCapacity(){
        //是否执行操作
        int len=queue.length;

        //(tail+1)%len==front;
        if (size+1==len){
            //扩容到原来的1.5倍
            int newCapacity=len+(len>>1);
            doExtend(newCapacity);
        }
        if ( (size<(len>>1)&&size>DEFAULT_CAPACITY)){
            System.out.println("in");
            //缩容为原来的2倍
            int newCapacity=len>>1;
            doExtend(newCapacity);
        }
    }
    public void doExtend(int newCapacity){
        int len=queue.length;
        E[] newQueue= (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newQueue[i]=queue[front];
            front=(front+1)%len;
        }
        front=0;
        tail=size;
        queue=newQueue;
        System.out.println("由len="+len+"扩容为"+newCapacity);
    }

    @Override
    public String toString() {
        return "CircleQueue{" +
                "front=" + front +
                ", tail=" + tail +
                ", size=" + size +
                ", queue=" + Arrays.toString(queue) +
                '}';
    }
}
```

