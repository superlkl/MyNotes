# 递归

我们可以来看一个小故事,有一天我们去看电影, 到了电影院我们想知道这是第几排,于是就问绿色箭头是第几排，他也不知道是第几排，就问黄色箭头是第几排，直到到第一排以后告诉这里是第一排。然后就把结果返回给黄色，黄色返回给蓝色，蓝色在返回给我，就知道是第几排了。其实，这就是生活中的递归。在代码中也是一样的。

## 斐波那契数列

0、1、1、2、3、5。。。

**第一版**

递归递归，有递就有归，先设置一个归来的条件，当n<=1时就归来，其他情况递出去

```java
public int fib1(int n){
        if (n<=1){
            return n;
        }
        return fib1(n-1)+fib1(n-2);
    }
```

**第二版**

相对于第一版性能更高，第三个数等于第一个和第二个相加，第四个数等于第三个和第二个数相加。。。

```
0,1,2,3,4,5,6
0,1,1,2,3,5,8
```

`fib2(2)=fib2(1)+fib2(0`)加一次就结束，即第n个数需要加n-1次

```java
 public int fib2(int n){
        if (n<=1){
            return n;
        }
        int first=0;
        int second=1;
        for (int i = 0; i < n-1; i++) {
            int sum=first+second;
            first=second;
            second=sum;
        }
        return second;
    }
```

## 求1到n的和

```java
//用递归求1+2+3+...n的和
    public int sum(int n){
        if (n==1){
            return n;
        }
        return sum(n-1)+n;
    }
```

## 求n的阶乘

```java
 //用递归求n的阶乘
    public int factorial(int n){
        if (n<=1){
            return 1;
        }
        return factorial(n-1)*n;
    }
```

# 动态数组

1. 能够增加数据
2. 删除数据
3. 由索引查找数据
4. 由索引判断数据是否存在
5. 判断数组是否为空
6. 判断数组是否满了
7. 遍历数据数据
8. 得到数组长度

```java
package 动态数组;

import java.util.Arrays;

/**
 * 动态数组
 * 动态数组的储存空间是连续的
 */
public class DynamicArray {
    //数组元素的个数
    private int size=0;
    //数组空间
    private int[] space;
    private final int ERROR=-1;

    //用户自定义数组空间大小
    public DynamicArray(int capacity){
        space=new int[capacity];
    }
    //系统默认数组空间大小
    public DynamicArray(){
        //默认数组空间
        int DEFAULT_SPACE = 10;
        space=new int[DEFAULT_SPACE];
    }

    /**
     *
     * @param number 插入的数据
     * @return 添加成功返回true
     */
    public Boolean add(int number){
        //如果数组空间满了就扩容
        if (isFull()){
            this.space = Arrays.copyOf(this.space, 2*this.space.length);
        }

        space[size]=number;
        size++;
        return true;
    }

    public boolean remove(int index) {
        if (index<0||index>size-1){
            return false;
        }
        if (isEmpty()){
            System.out.println("这是一个空数组！删除失败");
            return false;
        }
        //如果删除的是尾部数据
        if (index == size - 1) {
            size=size-1;
            return true;
        }
        //如果删除的是中间数据，那么之后的数据都要往前移动
        for (int i = index; i < size; i++) {
            space[i]=space[i+1];
        }
        size=size-1;
        return true;
    }

    /**
     * 判断数组是否满了
     * @return 满了就返回false
     */
    public boolean isFull(){
        return size <= space.length;
    }

    /**
     * 判断数组是否为空
     * @return 为空返回true
     */
   public Boolean isEmpty(){
       return size == 0;
   }

    /**
     * 获取数组使用长度
     * @return 有多少数据
     */
   public int getSize(){
       return size;
   }

    /**
     * 取出对应下标的数据
     * @param location 数组下标
     * @return 数据存在则返回数据 否则返回ERROR=-1
     */
   public boolean contain(int location){
       //错误的下标
       if (location<0||location>size-1){
           System.out.println("数组索引错误");
           return false;
       }
       //遍历查找进行对比
       for (int i = 0; i < size-1; i++) {
           if (space[i]==space[location]){
               System.out.println("该数据存在");
               return true;
           }
       }
       System.out.println("没有查找到该数据，请重新输入");
       return false;
   }

    /**
     *
     * @param location 索引
     * @return 返回对应索引的数据
     */
   public int indexOf(int location){
       //错误的下标
       if (location<0||location>size-1){
           System.out.println("数组索引错误");
           return ERROR;
       }
       return space[location];
   }

    /**
     * 打印数组中的数据
     */
   public void display() {
       //如果数组不空就遍历
       if (!isEmpty()) {
           for (int i = 0; i < size; i++) {
               System.out.print(space[i]);
           }
       }else {
           System.out.print("这是一个空数组");
       }
       System.out.println();
   }

   //清空所有数据
   public void clear(){
       size=0;
   }
}
```

# 链表

