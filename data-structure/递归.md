# 递归

我们可以来看一个小故事,有一天我们去看电影, 到了电影院我们想知道这是第几排,于是就问绿色箭头是第几排，他也不知道是第几排，就问黄色箭头是第几排，直到到第一排以后告诉这里是第一排。然后就把结果返回给黄色，黄色返回给蓝色，蓝色在返回给我，就知道是第几排了。其实，这就是生活中的递归。在代码中也是一样的。

## 斐波那契数列

0、1、1、2、3、5。。。

**第一版**

递归递归，有递就有归，先设置一个归来的条件，当n<=1时就归来，其他情况递出去

```java
public int fib1(int n){
        if (n<=1){
            return n;
        }
        return fib1(n-1)+fib1(n-2);
    }
```

**第二版**

相对于第一版性能更高，第三个数等于第一个和第二个相加，第四个数等于第三个和第二个数相加。。。

```
0,1,2,3,4,5,6
0,1,1,2,3,5,8
```

`fib2(2)=fib2(1)+fib2(0`)加一次就结束，即第n个数需要加n-1次

```java
 public int fib2(int n){
        if (n<=1){
            return n;
        }
        int first=0;
        int second=1;
        for (int i = 0; i < n-1; i++) {
            int sum=first+second;
            first=second;
            second=sum;
        }
        return second;
    }
```

## 求1到n的和

```java
//用递归求1+2+3+...n的和
    public int sum(int n){
        if (n==1){
            return n;
        }
        return sum(n-1)+n;
    }
```

## 求n的阶乘

```java
 //用递归求n的阶乘
    public int factorial(int n){
        if (n<=1){
            return 1;
        }
        return factorial(n-1)*n;
    }
```

## 递归和数学归纳法

**特点：**

1. 调用自己一次的情况：调用位置前面的代码是正循环，调用位置后面的代码是反循环。
2. 调用自己两次的情况：他是一个二叉树的遍历过程（例如：汉诺塔算法：中序遍历）。

要说递归得先说，数学归纳法，想必每一个程序员在高中的时候就应该学习了数学归纳法，当我们需要去证明一个证明题时，很可能就要用到数学归纳法，数学归纳法的思想如下：

一般地，证明一个与自然数n有关的命题P(n），有如下步骤：

1. 证明当n取第一个值`n0`时命题成立。`n0`对于一般数列取值为0或1，但也有特殊情况；
2. 假设当`n=k（k≥n0，k为自然数）`时命题成立，证明当n=k+1时命题也成立。

综合1,2，对一切自然数`n（≥n0），命题P(n）`都成立。

 

其实，数学归纳法利用的是递推的原理，形象地可以叫做多米诺原理。因为N+1的成立就可以向前向后递推所有数都成立。



这里我们先来看一个例子，非常简单，设计一程序，求自然数N的阶乘N！：

现在已知N!=N*(N-1)*(N-2)*(N-3)*…*2*1

首先可知当N=1时 N!=1

第二步可设当R(N)=N!，R(N+1)=(N+1)!

 第三步，求R(N+1)与R(N)之间的关系。R(N)=N!， 而R(N+1)=(N+1)!=(N+1)*(N)*(N-1)*…*2*1=(N+1)*N!=(N+1)*R(N)*

**即：R(N+1)=(N+1)R(N) =〉 R(N)=N\*R(N-1)**

现在根据这个公式草略地构造一个函数：

```java
factorial (int N)
{
return N * factorial (N - 1)   /*    递归部分    */
}
```

接下来补充截止部分，这一部分在整个过程中只使用一次，没有它，程序就将无限递归下去。可以说它是程序运行栈的栈顶，到了它，就开始一步步退栈了。
函数改为：

```java
factorial (int N)
{
if (N == 1)   return 1;
return N * factorial (N - 1)   /*    递归部分    */
}
```

**上面的步骤是可以颠倒的，但是首先设计截至部分还要好一些。**

## 总结

现在来总结设计递归程序的步骤：

一、用数学归纳法分析问题，根据数学归纳法的第一步得出截至部分。

二、根据数学归纳法的第三步来构造函数的递归部分。其实这个求解过程就是找出R(N)与R(N-1)的关系式。

# 动态数组

1. 能够增加数据
2. 删除数据
3. 由索引查找数据
4. 由索引判断数据是否存在
5. 判断数组是否为空
6. 判断数组是否满了
7. 遍历数据数据
8. 得到数组长度

```java
package 动态数组;

import java.util.Arrays;

/**
 * 动态数组
 * 动态数组的储存空间是连续的
 */
public class DynamicArray {
    //数组元素的个数
    private int size=0;
    //数组空间
    private int[] space;
    private final int ERROR=-1;

    //用户自定义数组空间大小
    public DynamicArray(int capacity){
        space=new int[capacity];
    }
    //系统默认数组空间大小
    public DynamicArray(){
        //默认数组空间
        int DEFAULT_SPACE = 10;
        space=new int[DEFAULT_SPACE];
    }

    /**
     *
     * @param number 插入的数据
     * @return 添加成功返回true
     */
    public Boolean add(int number){
        //如果数组空间满了就扩容
        if (isFull()){
            this.space = Arrays.copyOf(this.space, 2*this.space.length);
        }

        space[size]=number;
        size++;
        return true;
    }

    public boolean remove(int index) {
        if (index<0||index>size-1){
            return false;
        }
        if (isEmpty()){
            System.out.println("这是一个空数组！删除失败");
            return false;
        }
        //如果删除的是尾部数据
        if (index == size - 1) {
            size=size-1;
            return true;
        }
        //如果删除的是中间数据，那么之后的数据都要往前移动
        for (int i = index; i < size; i++) {
            space[i]=space[i+1];
        }
        size=size-1;
        return true;
    }

    /**
     * 判断数组是否满了
     * @return 满了就返回false
     */
    public boolean isFull(){
        return size <= space.length;
    }

    /**
     * 判断数组是否为空
     * @return 为空返回true
     */
   public Boolean isEmpty(){
       return size == 0;
   }

    /**
     * 获取数组使用长度
     * @return 有多少数据
     */
   public int getSize(){
       return size;
   }

    /**
     * 取出对应下标的数据
     * @param location 数组下标
     * @return 数据存在则返回数据 否则返回ERROR=-1
     */
   public boolean contain(int location){
       //错误的下标
       if (location<0||location>size-1){
           System.out.println("数组索引错误");
           return false;
       }
       //遍历查找进行对比
       for (int i = 0; i < size-1; i++) {
           if (space[i]==space[location]){
               System.out.println("该数据存在");
               return true;
           }
       }
       System.out.println("没有查找到该数据，请重新输入");
       return false;
   }

    /**
     *
     * @param location 索引
     * @return 返回对应索引的数据
     */
   public int indexOf(int location){
       //错误的下标
       if (location<0||location>size-1){
           System.out.println("数组索引错误");
           return ERROR;
       }
       return space[location];
   }

    /**
     * 打印数组中的数据
     */
   public void display() {
       //如果数组不空就遍历
       if (!isEmpty()) {
           for (int i = 0; i < size; i++) {
               System.out.print(space[i]);
           }
       }else {
           System.out.print("这是一个空数组");
       }
       System.out.println();
   }

   //清空所有数据
   public void clear(){
       size=0;
   }
}
```

# 链表

