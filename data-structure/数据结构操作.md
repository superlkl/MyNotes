# 递归

我们可以来看一个小故事,有一天我们去看电影, 到了电影院我们想知道这是第几排,于是就问绿色箭头是第几排，他也不知道是第几排，就问黄色箭头是第几排，直到到第一排以后告诉这里是第一排。然后就把结果返回给黄色，黄色返回给蓝色，蓝色在返回给我，就知道是第几排了。其实，这就是生活中的递归。在代码中也是一样的。

## 斐波那契数列

0、1、1、2、3、5。。。

**第一版**

递归递归，有递就有归，先设置一个归来的条件，当n<=1时就归来，其他情况递出去

```java
public int fib1(int n){
        if (n<=1){
            return n;
        }
        return fib1(n-1)+fib1(n-2);
    }
```

**第二版**

相对于第一版性能更高，第三个数等于第一个和第二个相加，第四个数等于第三个和第二个数相加。。。

```
0,1,2,3,4,5,6
0,1,1,2,3,5,8
```

`fib2(2)=fib2(1)+fib2(0`)加一次就结束，即第n个数需要加n-1次

```java
 public int fib2(int n){
        if (n<=1){
            return n;
        }
        int first=0;
        int second=1;
        for (int i = 0; i < n-1; i++) {
            int sum=first+second;
            first=second;
            second=sum;
        }
        return second;
    }
```

## 求1到n的和

```java
//用递归求1+2+3+...n的和
    public int sum(int n){
        if (n==1){
            return n;
        }
        return sum(n-1)+n;
    }
```

## 求n的阶乘

```java
 //用递归求n的阶乘
    public int factorial(int n){
        if (n<=1){
            return 1;
        }
        return factorial(n-1)*n;
    }
```

# 动态数组

## 满足能够储存int类型

```java
package 动态数组;

import java.util.Arrays;

/**
 * 动态数组
 * 动态数组的储存空间是连续的
 */
public class DynamicArray {
    //数组元素的个数
    private int size=0;
    //数组空间
    private int[] space;
    private final int ERROR=-1;

    //用户自定义数组空间大小
    public DynamicArray(int capacity){
        space=new int[capacity];
    }
    //系统默认数组空间大小
    public DynamicArray(){
        //默认数组空间
        int DEFAULT_SPACE = 10;
        space=new int[DEFAULT_SPACE];
    }

    /**
     *
     * @param number 插入的数据
     * @return 添加成功返回true
     */
    public Boolean add(int number){
        //如果数组空间满了就扩容
        if (isFull()){
            extendSpace();
        }

        space[size]=number;
        size++;
        return true;
    }

    /**
     * 扩容数组，一般情况下是扩容到原来的1.5倍效率最高
     */
    public void extendSpace(){
        int old=space.length;
        //扩容1.5倍
        int[] newSpace=new int[old+(old>>1)];
        for (int i = 0; i < old; i++) {
            newSpace[i]=space[i];
        }
        //把新数组的引用给旧数组，释放旧数组的空间
        space=newSpace;
        System.out.println(old + "扩容为" + newSpace.length);
    }

    public boolean remove(int index) {
        if (index<0||index>size-1){
            return false;
        }
        if (isEmpty()){
            System.out.println("这是一个空数组！删除失败");
            return false;
        }
        //如果删除的是尾部数据
        if (index == size - 1) {
            size=size-1;
            return true;
        }
        //如果删除的是中间数据，那么之后的数据都要往前移动
        for (int i = index; i < size; i++) {
            space[i]=space[i+1];
        }
        size=size-1;
        return true;
    }

    /**
     * 判断数组是否满了
     * @return 满了就返回false
     */
    public boolean isFull(){
        return space.length <= size;
    }

    /**
     * 判断数组是否为空
     * @return 为空返回true
     */
    public Boolean isEmpty(){
        return size == 0;
    }

    /**
     * 获取数组使用长度
     * @return 有多少数据
     */
    public int getSize(){
        return size;
    }

    /**
     * 取出对应下标的数据
     * @param location 数组下标
     * @return 数据存在则返回数据 否则返回ERROR=-1
     */
    public boolean contain(int location){
        //错误的下标
        if (location<0||location>size-1){
            System.out.println("数组索引错误");
            return false;
        }
        //遍历查找进行对比
        for (int i = 0; i < size-1; i++) {
            if (space[i]==space[location]){
                System.out.println("该数据存在");
                return true;
            }
        }
        System.out.println("没有查找到该数据，请重新输入");
        return false;
    }

    /**
     *
     * @param location 索引
     * @return 返回对应索引的数据
     */
    public int indexOf(int location){
        //错误的下标
        if (location<0||location>size-1){
            System.out.println("数组索引错误");
            return ERROR;
        }
        return space[location];
    }

    /**
     * 打印数组中的数据
     */
    public void display() {
        //如果数组不空就遍历
        if (!isEmpty()) {
            for (int i = 0; i < size; i++) {
                System.out.print(space[i]);
            }
        }else {
            System.out.print("这是一个空数组");
        }
        System.out.println();
    }

    //清空所有数据
    public void clear(){
        size=0;
    }

    //打印详细信息
    @Override
    public String toString() {
        return "DynamicArray{" +
            "size=" + size +
            ", space=" + Arrays.toString(space) +
            '}';
    }
}
```

## 满足能够储存所有类型

```java
package 动态数组;

import java.util.Arrays;
import java.util.Objects;

/**
 * 动态数组
 * 动态数组的储存空间是连续的
 */
public class DynamicArray<T> {
    //数组元素的个数
    private int size=0;
    //数组空间
    private T[] space;
    private static final int ERROR=-1;
    private static final int DEFAULT_SPACE = 10;
    //用户自定义数组空间大小
    public DynamicArray(int capacity){
        space= (T[]) new Object[capacity];
    }
    //系统默认数组空间大小
    public DynamicArray(){
        //默认数组空间
        space= (T[]) new Object[DEFAULT_SPACE];
    }

    /**
     *
     * @param number 插入的数据
     * @return 添加成功返回true
     */
    public Boolean add(Object number){
        //如果数组空间满了就扩容
        if (isFull()){
            extendSpace();
        }

        space[size]= (T) number;
        size++;
        return true;
    }

    /**
     * 扩容数组，一般情况下是扩容到原来的1.5倍效率最高
     */
    public void extendSpace(){
        int oldLength=space.length;
        //扩容1.5倍
       int newLength=oldLength+(oldLength>>1);
        T[] newSpace= (T[]) new Object[newLength];
        for (int i = 0; i < oldLength; i++) {
            newSpace[i]=space[i];
        }
        //把新数组的引用给旧数组，释放旧数组的空间
        space=newSpace;
        System.out.println(oldLength + "扩容为" + newLength);
    }

    public boolean remove(int index) {
        if (index<0||index>size-1){
            return false;
        }
        if (isEmpty()){
            System.out.println("这是一个空数组！删除失败");
            return false;
        }
        //如果删除的是尾部数据
        if (index == size - 1) {
            space[index]=null;
            return true;
        }
        //如果删除的是中间数据，那么之后的数据都要往前移动
        for (int i = index; i < size; i++) {
            space[i]=space[i+1];
        }
        size=size-1;
        return true;
    }
//
    /**
     * 判断数组是否满了
     * @return 满了就返回false
     */
    public boolean isFull(){
        return space.length <= size;
    }

    /**
     * 判断数组是否为空
     * @return 为空返回true
     */
    public Boolean isEmpty(){
        return size == 0;
    }

    /**
     * 获取数组使用长度
     * @return 有多少数据
     */
    public int getSize(){
        return size;
    }

    /**
     * 取出对应下标的数据
     * @param location 数组下标
     * @return 数据存在则返回数据 否则返回ERROR=-1
     */
    public boolean contain(int location){
        //错误的下标
        if (location<0||location>size-1){
            System.out.println("数组索引错误");
            return false;
        }
        //遍历查找进行对比
        for (int i = 0; i < size-1; i++) {
            if (space[i]==space[location]){
                System.out.println("该数据存在");
                return true;
            }
        }
        System.out.println("没有查找到该数据，请重新输入");
        return false;
    }

    /**
     *
     * @param location 索引
     * @return 返回对应索引的数据
     */
    public T indexOf(int location){
        //错误的下标
        if (location<0||location>size-1){
            System.out.println("数组索引错误");
            return null;
        }
        return space[location];
    }

    /**
     * 打印数组中的数据
     */
    public void display() {
        //如果数组不空就遍历
        if (!isEmpty()) {
            for (int i = 0; i < size; i++) {
                System.out.print(space[i]);
            }
        }else {
            System.out.print("这是一个空数组");
        }
        System.out.println();
    }

    //清空所有数据
    public void clear(){
        for (int i = 0; i < size; i++) {
            space[i]=null;
        }
        size=0;
    }

    //打印详细信息
    @Override
    public String toString() {
        StringBuilder builder=new StringBuilder();
        builder.append("对象数组大小为size=").append(size).append(" [");
        for (int i = 0; i < size; i++) {
            if (i!=0){
                builder.append(",");
            }
            builder.append(space[i]);
        }
        builder.append("]");
        return builder.toString();
    }
}
```

# 链表

- 链表是一种链式储存的线性表，所有元素的内存地址不一定是连续的

## 单向链表

```java
package 链表;

public class LinkNode {
    //头结点
    private Node head = null;
    //链表长度
    private int size = 0;

    private static class Node {
        //数据域
        int data;
        //指针域
        Node next;

        public Node(int element, Node node) {
            data = element;
            next = node;
        }
    }

    /**
     * 清空链表
     * 把头结点设置为null,所有结点的引用都消失了
     */
    public void clear() {
        size = 0;
        head = null;
    }

    /**
     * 指定链表位置添加数据
     * @param index 添加的位置
     * @param element 添加的数据
     * @return 返回true则添加成功
     */
    public boolean add(int index, int element) {
        rangCheckForAdd(index);
        if (index == 0) {
            head = new Node(element, head);
            size++;
            return true;
        }
        Node previous = nodeBack(index - 1);
        previous.next = new Node(element, previous.next);
        size++;
        return true;
    }

    /**
     * 直接向链表添加数据
     * @param element 添加的数据
     * @return 返回true则添加成功
     */
    public boolean add(int element){
        if (head==null){
            head=new Node(element,null);
            size++;
            return true;
        }
        Node temp=head;
        while (temp.next!=null){
            temp=temp.next;
        }
        temp.next=new Node(element,null);
        size++;
        return true;
    }

    //设置指定索引位置的数据
    public boolean set(int index,int element){
        rangCheck(index);
        if (head==null) return false;
        //定位
        int location=0;
        Node temp=head;
        while (temp!=null){
            if (location==index){
                temp.data=element;
                return true;
            }
            temp=temp.next;
            location++;
        }
        return false;
    }

    /**
     *
     * @param index 删除指定位置的结点
     * @return 返回true则删除成功
     */
    public int remove(int index) {
        rangCheck(index);

        if (index == 0) {
            head = head.next;
            size--;
            return head.data;
        }
        Node previous = nodeBack(index - 1);
        //删除对象
        Node removeClass = previous.next;
        previous.next = removeClass.next;
        size--;
        return removeClass.data;
    }

    /**
     *
     * @param index 返回指定位置的结点
     * @return true
     */
    public Node nodeBack(int index) {
        rangCheck(index);

        Node temp = head;
        for (int i = 0; i < index; i++) {
            temp = temp.next;
        }
        return temp;
    }

    /**
     * 索引越界则抛出异常
     * @param index 异常的索引
     */
    private void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);
    }

    /**
     * 检查索引是否越界index可以等于size
     * @param index 用户输入的索引
     */
    private void rangCheck(int index) {
        if (index < 0 || index >= size) {
            outOfBounds(index);
        }
    }

    /**
     * 检查索引是否越界index不可以等于size
     * @param index 用户输入的索引
     */
    private void rangCheckForAdd(int index) {
        if (index < 0 || index > size) {
            outOfBounds(index);
        }
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("size=").append(size).append(", [");
        Node node = head;
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                builder.append(", ");
            }

            builder.append(node.data);

            node = node.next;
        }
        builder.append("]");
        return builder.toString();
    }
    
     //链表的反转
    public Node reverseLinkNode(){
        //指向head的上一个结点
        Node pre = null;
        Node next;
        while (head != null) {
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        //新的头结点
        head=pre;
        return head;
    }
}
```

