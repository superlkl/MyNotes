# 时间复杂度

简单来说就是用来描述一个程序运行的时间长短

![image-20191110152209479](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110152209479.png)

分析程序怎么运行：

蓝色框运行1次；黑色框运行n+1次(最后还要比较就多一次)；红色框运行n次；

总的运行次数=`1+1+(n+1)+2n=3n+3`次；程序的消耗时间和n呈线性关系

![image-20191110152609615](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110152609615.png)

在计算比较中 一般只关心随着问题规模n趋于无穷时函数中对函数结果影响最大的项，**也就是最高次项** 

![image-20191110152716587](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110152716587.png)

由图知： `T(n)=3n+3`,当n非常大的时候常数3和n的系数3对函数结果的影响就很小了 

比如：                             

`T(n)=n+1` 忽略常数项 `T(n)~n`          

`T(n)=n+n^2` 忽略低阶项 `T(n)~n^2`     

`T(n)=3n` 忽略最高阶的系数`T(n)~n ` 

所谓低阶项，简单地说就是当n非常大时，这个项相对于另外一个项很小，可以忽略，比如n相对于n^2,n就是低阶项 

## **函数大小关系**

![image-20191110152919552](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110152919552.png)

1. 常见的算法时间复杂度由小到大依次为：上图所示。随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低
2. 我们应该尽可能避免使用指数阶的算法 

## **时间复杂度的表示**

简化后的式子被称为这个程序算法的时间复杂度，记做`O(f(n))`,`f(n)`就是简化后的式子，比如说刚开始讨论的`T(n)=3n+3`,简化后`T(n)~f(n)=n`,那我们记为`O(n) `

> <u>更准确地说O代表了运行时间函数的一个渐进上界，即T(n)在数量级上小于等于f(n)</u>
>
> **对这句话我并不理解，数量级小于？**

## **什么叫数量级**

数量级释义：用来量度或估计某些物理量大小的一种概念。当一个物理量的数值写成以10为底的指数表达式时，指数的数目就是这个物理量的数量级。

例如地球赤道半径为6378千米，可以写成6.378×103千米或6.378×106米。就千米来说，它的数量级是3；就米来说，它的数量级是6。

需要特别注意的是：数量级应用范围必须是正数或自然数！尽管负数也可以计算数量级，没有实际的意义。比如：-10和-1000这两个数从纯数学角度说相差100倍，不过不能说这两个数相差2个数量级。

## **时间复杂度的计算** 

 一、得出运行时间的函数  

①用常数1来取代运行时间中所有加法常数 

②修改后的函数中，只保留最高阶项      

③如果最高阶项存在且不是1，则忽略这个项的系数 

 二、对函数进行简化     

比如：

![image-20191110155550666](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110155550666.png)

显然，T(n)=3,对这个函数进行简化，用常数1取代常数3，然后取代后的函数没有最高阶项，那么这个算法的时间复杂度就是O(1). **O(1)也被称为常数阶**

**每次都这么计算显然很麻烦：**

可以耍耍小聪明，一般来说，最内层执行次数最多的语句就决定了整个算法的趋势 

![image-20191110155710793](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110155710793.png)

只要看看最内层的语句执行次数的规律就行了，这个内层打印语句随着问题规模n的增加会呈线性增加，直接就可以判定复杂度为O(n) 

再比如：

![image-20191110155734398](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110155734398.png)

按照这个方法就很容易得出下面这个嵌套的两层for循环的复杂度为O（n^2了 

最内层的语句随n的增加会呈二次函数的规律执行，代表了这个算法执行时间的一个趋势 

## **对数函数计算示例**

 对数函数的趋势显然比线性函数好(对数函数随着自变量的增大因变量增长的很慢) 

![image-20191110155917352](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110155917352.png)

怎么计算下面函数的时间复杂度

![image-20191110155936941](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110155936941.png)

 这段代码的复杂度就为对数级别的，`O(logn)` ，怎么分析？

![image-20191110160017870](C:\Users\XZND\AppData\Roaming\Typora\typora-user-images\image-20191110160017870.png)

每循环一次，sum就给自身乘以2，乘了多少次就跳出循环了呢(大于等于n)？不知道，就设为x吧，那么`2^x=n`,解出`x=logn`，这说明随着n的增大，最消耗时间的内层语句是呈对数变化的 

## 常见的时间复杂度

1.  常数阶 `O(1)`
2. 对数阶 `O(log2n)`
3.  线性阶 `O(n)`
4. 线性对数阶 `O(nlog2n)`
5. 平方阶 `O(n^2)`
6. 立方阶 `O(n^3)`
7. k 次方阶 `O(n^k)`
8. 指数阶` O(2^n)`

## 空间复杂度 

 时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的 

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。 

------

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)

举例： 

 空间复杂度比较常用的有：O(1)、O(n)、O(n²) 

 **空间复杂度 O(1)** 

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

 代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1) 

 **空间复杂度 O(n)** 

```java
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n) 
