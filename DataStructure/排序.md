# 直接插入排序

所谓直接插入排序，就是把未排的元素一个个的插入到有序的集合中，把有序集合从后到前扫一遍，然后插入到合适的位置中



直接插入排序：

基本思想：

1. 在要排序的一组数中，假设前面(n-1)[n>=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。

2. 直接插入排序是由两层嵌套循环组成的。外层循环标识并决定待比较的数值。

3. 内层循环为待比较数值确定其最终位置。<u>直接插入排序是将待比较的数值与它的前一个数值进行比较，所以外层循环是从第二个数值开始的</u>。当前一数值比待“比较数值”大的情况下继续循环比较

4. 直到找到比待“比较数值”小的并将待比较数值置入其后一位置，结束该次循环。

 *  时间复杂度：`O(n2)`
 *  空间复杂度：`O(1)`

```java
public class Main {
    public static void main(String[] args) {
        int[] arr={5,8,3,9};
        insertSort(arr);
        print(arr);
    }

    //直接插入排序
    private static void insertSort(int[] arr){

        //外层循环确定待比较数值
        //必须i=1，因为开始从第二个数与第一个数进行比较
        for (int i=1;i<arr.length;i++) { 
            int temp = arr[i];             //待比较数值
            int j = i - 1;                 //与前一个数值比较
            
            //内层循环为待比较数值确定其最终位置
            for (;j>=0 && arr[j]>temp;j--) {   //待比较数值比前一位置小，应插往前插一位
                
                arr[j+1] = arr[j];             //将大于temp的值整体后移一个单位
            }
            arr[j+1] = temp;                   //待比较数值比前一位置大，最终位置无误
        }

    }

    private static void print(int[] arr){
                    for (int i:arr) {
                        System.out.print(i + "  ");
                    }
    }
}


```

![image-20191110170308203](排序.assets/image-20191110170308203.png)

**代码文字debug：**

从第二个数开始往前比较。把8存到temp里，5>8为false，不作变化，第二次循环从3开始比较，8>3为true，把8的位置向后移一位，j--，再比较5>3为true，把5的位置向后移动1位，再把3设置到第一位，最后8>9为false，不作变化

**函数的意义：**

**第一个for循环**

我们要插入排序自然要先把我们准备排序的值取出来，那这个循环就可以遍历数组取到值

**temp**

把待比较值与其他数值比较的数组单独存在temp里，在数值向后移动的时候会覆盖了待比较值，所以作用就是留下一个存档

**j--**

当待比较值比它前一个数小的时候，那个数后移一位，那待比较值就应该继续向它前面的数比较，直到比较到第一位j<0之后比较结束，j就是数组的索引

**第二个for循环**

由第一个循环取值出来，这个循环就添加数值比较的逻辑，然后实行插入排序的效果

**arr[j+1] = temp**

当跳出第二个循环时就会执行这条语句，也就是当已经比较完数组中的第一个数了或者是在比较时遇到前面的那个数更小的时候就是执行的条件

**int j=i-1**

把j这个变量单独踢出来可以减少代码的耦合度，j变量的作用范围更广

## 图解

![image-20191110185536967](排序.assets/image-20191110185536967.png)

![image-20191110185609718](排序.assets/image-20191110185609718.png)

![image-20191110185628328](排序.assets/image-20191110185628328.png)

这段代码最耗时的地方就花在最内层for循环里面的操作上（比较和移动）了，我只要大概估算出这些操作执行的次数就可以了 

对于n个元素，首先我的外层for循环要循环n-1次

![img](https://mmbiz.qpic.cn/mmbiz_png/zrIoKPEFItepfKib7z5icayxuFfDRC3icAdDQpK9upZcEhtg2UHdibclVqibhUKJsl3AapEJfLdyByIDsDQo0A2HFdA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

然后`insertSort`里的内层for循环的循环次数是根据 i 来决定的，i = 1时,循环 1 次，i = 2,循环 2 次，...，i = n-1,循环 n-1次，那总共加起来就是 

![img](https://mmbiz.qpic.cn/mmbiz_png/zrIoKPEFItepfKib7z5icayxuFfDRC3icAdX1Jkwg6bticn0oP2YPTsRfL8hjibku4kQ2XJwib7IgLUjErvRlEqNQniaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 根据复杂度计算规则，保留高阶项，并去掉系数，那么时间复杂度为O(n^2) 

## 稳定性 

 是稳定的，因为在比较的时候，过两个数相等的话，不会进行移动，前后两个数的次序不会发生改变 

![image-20191110185914501](排序.assets/image-20191110185914501.png)

## 使用场景

小规模数据或基本有序的数据使用起来十分高效，但一般的数据都是很大且无序的，如果遇到数据量中等的情况下就可以使用希尔排序

# 希尔排序

思路：

首先它把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高 

![image-20191113212920811](排序.assets/image-20191113212920811.png)

颜色相同的就是逻辑上的分组，但是数组里数据的位置还是原来的没有变化

可以看出，他是按下标相隔距离为4分的组，也就是说把下标相差4的分到一组，比如这个例子中a[0]与a[4]是一组、a[1]与a[5]是一组...，这里的差值（距离）被称为增量 

![image-20191113212945872](排序.assets/image-20191113212945872.png)

 每个分组进行插入排序后，各个分组就变成了有序的了（整体不一定有序） 

![image-20191113213014923](排序.assets/image-20191113213014923.png)

 此时，整个数组变的部分有序了（有序程度可能不是很高） 

![image-20191113213129562](排序.assets/image-20191113213129562.png)

 然后缩小增量为上个增量的一半:2，继续划分分组，此时，每个分组元素个数多了，但是，数组变的部分有序了，插入排序效率同样比高 

![image-20191113213204145](排序.assets/image-20191113213204145.png)

 同理对每个分组进行排序（插入排序），使其每个分组各自有序 

![image-20191113213230436](排序.assets/image-20191113213230436.png)

最后设置增量为上一个增量的一半：1，则整个数组被分为一组，此时，整个数组已经接近有序了，插入排序效率高 

![image-20191113213307902](排序.assets/image-20191113213307902.png)

```java
private static void shellSort(int[] arr){
        //进行分组
        int N=arr.length;
        //对各个分组进行插入排序
        for (int gap=N/2;gap>0;gap/=2){
            for (int i=gap;i<N;i++){
                //插入到正确位置
                insertI(arr,gap,i);
            }
        }
    }
    private static void insertI(int[] arr,int gap,int i){
        int inserted =arr[i];
        int j;
        for (j=i-gap;j>=0&&inserted<arr[j];j-=gap){
            arr[j+gap]=arr[j];
        }
        arr[j+gap]=inserted;
    }
```

