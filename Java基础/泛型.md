# 泛型

## 前言

泛型是指在对象创建时不指定类中属性的具体类型，而由外部在声明及实例化对象时指定类型

```java
/**
 * 设计一个坐标类，不指定属性的具体类型
 * 有x和y两个坐标
 */
public class Point {
    private Object x;
    private Object y;

    public Object getX() {
        return x;
    }

    public void setX(Object x) {
        this.x = x;
    }

    public Object getY() {
        return y;
    }

    public void setY(Object y) {
        this.y = y;
    }
}

```

**测试1：用整数表示**

```java
public class Test {
    public static void main(String[] args) {
        Point point=new Point();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX(10);
        point.setY(20);
        //向下转型
        int x= (int) point.getX();
        int y= (int) point.getY();
        System.out.println("坐标:"+x+" "+y);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127140802441.png)

**测试2：用小数表示**

```java
public class Test {
    public static void main(String[] args) {
        Point point=new Point();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX(10.0f);
        point.setY(20.0f);
        //向下转型
        Float x= (Float) point.getX();
        Float y= (Float) point.getY();
        System.out.println("坐标:"+x+" "+y);
    }
}

```

一定要注意在小数后要加一个f才能表示小数

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127141107220.png)

**测试3：用字符串表示**

```java
public class Test {
    public static void main(String[] args) {
        Point point=new Point();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX("东经20度");
        point.setY("南纬30度");
        //向下转型
        String x= (String) point.getX();
        String y= (String) point.getY();
        System.out.println("坐标:"+x+" "+y);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127141354957.png)

**测试4：用字符串和数字混合表示**

```java
public class Test {
    public static void main(String[] args) {
        Point point=new Point();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX("温度");
        point.setY(20);
        //向下转型
        String x= (String) point.getX();
        int y= (int) point.getY();
        System.out.println("坐标:"+x+" "+y);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127141613325.png)

这四个测试可以看出Object的确是超类，可以接收每种类型的数据

**测试5**

```java
public class Test {
    public static void main(String[] args) {
        Point point=new Point();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX("温度");
        point.setY(20);
        //向下转型
        String x= (String) point.getX();
        String y= (String) point.getY();
        System.out.println("坐标:"+x+" "+y);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127141836496.png)

报了类别错误，因为设置的温度和20不是一个类型，却都用一个类型接收了

## 泛型的必要性

**为什么要使用泛型？**

我们在编写程序时，经常遇到<u>两个模块的功能非常相似</u>，只是一个是处理int类型数据，另一个处理String类型数据，或者其他自定义类型数据，但是我们没有办法，只能分别写多个方法处理每种数据类型，因为方法的参数类型不同。那有一种方法，<u>在方法中传入通用的数据类型，就可以用来合并代码，这就是泛型。</u>

## 使用格式

```java
/**
 * 设计一个坐标类，不指定属性的具体类型
 * 有x和y两个坐标
 */
public class Point<T> {
    private T x;
    private T y;

    public T getX() {
        return x;
    }

    public void setX(T x) {
        this.x = x;
    }

    public T getY() {
        return y;
    }

    public void setY(T y) {
        this.y = y;
    }
}

```

```java
public class Test {
    public static void main(String[] args) {
        Point<String> point=new Point<String>();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX("温度");
        point.setY("湿度");
        //向下转型
        String x= point.getX();
        String y= point.getY();
        System.out.println("天气:"+x+" "+y);
    }
}


```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127142853460.png)

这样使用的好处有两个：

1. 不用再进行类型转换了，接收的类型与设置的类型错误还会提示，可以避免类型转换出现的错误
2. point成为了模板类，当我们需要改变这个类属性的基本类型，直接修改<>括号里的设置就可以了

` Point<String> point=new Point<String>();`这条语句后面括号里的String类型可以省略不写，但是<>一定要加上，虽然不加上也可以运行程序，但是加上比较规范。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127143515733.png)

>  **显式类型参数字符串可以替换为<>**  



设置为整型

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127143753537.png)

直接设置为int的话确实报错了，说不能使用原始类型，也就是说在规定泛型的类型时我们不能传入基本数据类型，而要使用类类型Integer

```java
public class Test {
    public static void main(String[] args) {
        Point<Integer> point=new Point<>();
        //int -> Integer ->Object自动装箱并向上转型
        point.setX(10);
        point.setY(20);
        //向下转型
        int x= point.getX();
        int y= point.getY();
        System.out.println("天气:"+x+" "+y);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/201911271441049.png)

**还可以设置多个泛型类型**

```java
/**
 * 设计一个坐标类，不指定属性的具体类型
 * 有x和y两个坐标
 */
public class Point<T,K> {
    private T x;
    private K y;

    public Point(T x, K y) {
        this.x = x;
        this.y = y;
    }
    @Override
    public String toString() {
        return "Point{" +
                "x=" + x +
                ", y=" + y +
                '}';
    }
}
```

注：泛型的构造函数和一般构造函数的设置方式是完全相同的

```java
public class Test {
    public static void main(String[] args) {
        Point<String,Integer> point=new Point<>("温度",20);
        System.out.println(point);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127144708231.png)

## 通配符‘?’

在开发中对象的引用传递最为常见，但是如果在泛型类的操作中，在进行引用传递的泛型类型必须匹配才可以传递，否则是不能传递的

```java

public class Point<T> {
    private T x;

    public Point(T x) {
        this.x = x;
    }
    @Override
    public String toString() {
        return "Point{" +
                "x=" + x +
                '}';
    }
}
```

**情况一**

```java
public class Test {
    public static void main(String[] args) {
        Point<String> point=new Point<>("温度");
        print(point);
    }

    private static void print(Point<String> point){
        System.out.println(point);
    }
}
```

`Point<String> point`直接指定了泛型的类型，下面要接收这个泛型对象时也是直接设置为这个类型

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112714591945.png)

**情况二**`Point point`

```java
public class Test {
    public static void main(String[] args) {
        Point<String> point=new Point<>("构造函数");
        print(point);
    }
    private static void print(Point point){
        System.out.println(point);
    }
}
```

`Point point`直接不加后面的泛型类型，也可以输出，但是这样不严谨，要体现泛型类型才行，但是如果我们每改一次模板的泛型类型，就要改一次打印函数里的泛型类型来接收相对麻烦，所以就有了通配符这个东西，"?"，b表示可以接收任意类型的泛型对象

情况三`Point<?> point`

```java
public class Test {
    public static void main(String[] args) {
        Point<String> point=new Point<>("构造函数");
        print(point);
    }
    private static void print(Point<?> point){
        System.out.println(point);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112715071093.png)

## 受限泛型

### 上限

假设一个方法中能接收的泛型对象只能是数字类型，此时在定义方法参数接收对象时就只能使用泛型上限。

所以数字包装类都是Number类型的子类

测试：设置方法只能接收泛型为Number类型和Number类型的子类

```java
public class Test {
    public static void main(String[] args) {
        Point<Integer> point1=new Point<>(20);
        Point<Double>point2=new Point<>(20.0);
        print(point1);
        print(point2);
    }
    private static void print(Point<? extends Number> point){
        System.out.println(point);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127151439453.png)

如果设置为字符串类型就报错

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127151617710.png)



也可以在类声明出指定泛型的上限，一样的效果

```java
public class Point<T extends Number> {
    private T x;

    public T getX() {
        return x;
    }
```

### 下限

当使用的泛型只能在<u>本类及其父类类型上</u>使用时，就必须使用泛型的范围下限进行配置

**测试1**

```java
public class Test {
    public static void main(String[] args) {
        Point<String> point=new Point<>("温度");
        Point<Object> point1=new Point<>("天气");
        print(point);
        print(point1);
    }
    //只能接收String或Obiect类型的泛型
    private static void print(Point<? super String> point){
        System.out.println(point);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127154809960.png)

**测试2**

```java
public class Test {
    public static void main(String[] args) {
        Point<Integer> point=new Point<>(20);
        Point<Object> point1=new Point<>("天气");
        print(point);
        print(point1);
    }
    private static void print(Point<? super Integer> point){
        System.out.println(point);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127155036441.png)

可以看到在指定下限为Integer后，使用Object类型传递字符串也是可以的

**测试3**

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112715533271.png)

如果直接指定泛型类型是String类型或是Double类型就会报错

## 泛型与子类继承的限制

在普通方法里，一个子类可以通过对象的多态性为其父类实例化，但是在泛型操作中，子类的泛型类型无法使用父类的泛型类型接收

**测试1**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127155729249.png)

<u>虽然String类的父类是Object类，但是在泛型操作中这个概率无效，此时只能用通配符'?'接收</u>

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127160022557.png)

但是这样做的后果就是不能指定泛型的上限和下限了

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127160202690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127160315443.png)

只能只使用通配符的一般格式

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112716040350.png)

## 为什么在泛型中不能使用向上转型

`Point<Object> point2=new Point<Integer>(20);`

这样做的话相当于把泛型指定的范围扩大了，先开始泛型只是表示整型这个范围的数据，结果转换成了指定的是全部数据，所以程序编译不能通过

## 泛型接口

定义

```java
interface Person<T> {
      T getSome();
}
```

与普通接口的区别就是多了一个表示泛型的括号

**第一种方式：在子类的定义上声明泛型类型**

继承：在子类和父类后面都声明泛型类型

```java
//Person后面的括号可以省略，Demo不能省略
public class Demo<T> implements Person<T> {
    private T name;
    Demo(T name){
        this.name=name;
    }
    @Override
    public T getSome() {
        return null;
    }
    @Override
    public String toString() {
        return "Demo{" +
                "name=" + name +
                '}';
    }
}
```

实例化：通过子类实例化父类接口对象，并且指定明确的泛型类型

```java
public class Test {
    public static void main(String[] args) {
        Person<String> person=new Demo<>("大学");
        System.out.println(person);
    }
}
//输出：Demo{name=大学}
```

**第二种方式：直接在接口中指定具体类型**

```java
public class Demo implements Person<String> {
    private int age;

    Demo(int age){
        this.age=age;
    }

    @Override
    public String toString() {
        return "Demo{" +
                "age=" + age +
                '}';
    }
    @Override
    public String getSome() {
        return null;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Person<String> person=new Demo(20);
        System.out.println(person);
    }
}
```

因为在声明子类时已经明确的指定了具体的泛型类型，这样在实例化父类对象的时候就不需要在Demo类后面指定泛型对象了，而且<u>不仅不需要，指定了还会报错</u>

`Person<String> person=new Demo(20);`

这里省略Person后面的泛型指定也可以，系统照样运行，只是为了规范化，还是加上指定的泛型类型，也便于查看

## 泛型方法

在泛型方法中可以定义泛型参数

定义

```java
public class Demo{
    public <T> T fun(T t){
        return t;
    }
}
```

测试

```java
public class Test {
    public static void main(String[] args) {
        Demo d=new Demo();
        String str=d.fun("中国");
        int age=d.fun(70);
        System.out.println(str);
        System.out.println(age);
    }
}
//输出：中国 70
```

可以看出这个泛型方法可以接受任意类型的数据



**小结：**

在类后面加<T t>可以接收任何类型的类对象，在方法后面加<T t>可以接收任何类型的数据

## 使用泛型统一传入参数类型

```java
class Person<T extends Number> {
      private T weight;

      public void setWeight(T weight) {
            this.weight = weight;
      }

      @Override
      public String toString() {
            return "Person{" +
                    "weight=" + weight +
                    '}';
      }
}
```

测试：

```java
public class Test {
    public static void main(String[] args) {
        Person<Integer> person = fun(20);
        System.out.println(person);
    }

    private static <T extends Number> Person<T> fun(T param) {
        Person<T> person = new Person<>();
        person.setWeight(param);
        return person;
    }
}
//输出：Person{weight=20}
```

解释：首先在设计Person类时就规定了泛型的上限，只能传递数字类型的数据

在测试的时候实例化Person规定泛型类型为整型，重点是fun()函数，这个函数是为了得到Person类的实例对象，而Person<T>就是返回类型，所以在规定泛型时也是设置为<T extends Number>，这是泛型类型允许的区间，接着是函数名，函数名后的参数由传入的参数类型决定

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127171101152.png)

在传入的参数不是整型的时候就会报错，说明这个函数会进行类型推断，也就是说在传入参数后就会判断20.0是不是整数，那么为什么会发生这个推断呢，函数并没有运行啊！

原因就在于` Person<Integer> person`这一行语句，<u>在传入Integer后Person类里的T就等于Integer，fun里面的类型T也都等于Integer了，然后系统就会自己进行类型推断，</u>

## 使用泛型统一传入的参数类型

如果有一个方法与要求传入的泛型对象的泛型类型是一致的，也可以通过泛型方法指定

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127172958405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MjU3Mzgz,size_16,color_FFFFFF,t_70)

## 泛型数组

```java
public class Test
{
    public static void main(String args[]){
        //返回泛型数组
        Integer i[]=fun(1,2,3,4,5,6);
        //输出数组内容
        fun2(i);
    }

    //接收可变参数，返回泛型数组
    public static <T> T[] fun(T...arg){
        return arg;
    }

    public static <T> void fun2(T param[]){
        System.out.println("接收泛型数组：");
        for (T t : param )
        {
            System.out.print(t+"、");
        }

    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127173712880.png)

## 泛型的嵌套设置

```java
class Info<T,V>
{
    private T var;
    private V value;
    public Info(T var,V value){
        this.setVar(var);
        this.setValue(value);
    }
     public T getVar(){
        return var;
     }

     public void setVar(T var){
        this.var=var;
     }

     public V getValue(){
        return value;
     }

     public void setValue(V value){
        this.value=value;
     }
}

class Demo<S>
{
    private S info;

    public Demo(S info){
        this.setInfo(info);
    }

    public S getInfo(){
        return info;
    }

    public void setInfo(S info){
        this.info=info;
    }
}


public class  GeneriseDemo31
{
    public static void main(String args[]){
        Demo<Info<String,Integer>> d=null;
        Info<String,Integer> i=null;
        i=new Info<String,Integer>("凹凸",22);
        d=new Demo<Info<String,Integer>>(i);
        System.out.println("1."+d.getInfo().getVar());
        System.out.println("2."+d.getInfo().getValue());
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127173807821.png)

## 泛型应用

 【定义标识接口–信息】 

```java
interface Info
{
    //定义一个标识接口，此接口没有定义任何方法
}
```

 【定义第一个类–联系方式】 

```java
class Contact implements Info
{
    private String address;
    private String telphone;
    public Contact(String address,String telphone){
        this.setAddress(address);
        this.setTelphone(telphone);
    }
    public String getAddress(){
        return this.address;
    }
    public void setAddress(String address){
        this.address=address;
    }

    public String getTelphone(){
        return this.telphone;
    }

    public void setTelphone(String telphone){
        this.telphone=telphone;
    }

    public String toString(){
        return "联系方式："+"\n"+
            "\t|--联系地址："+this.address+
            "\t|--联系电话："+this.telphone;
    }
}
```

 【定义第二个类–个人信息】 

```java
class Introduce implements Info
{
    private String name;
    private int age;
    public Introduce(String name,int age){
        this.setName(name);
        this.setAge(age);
    }
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name=name;
    }

    public int getAge(){
        return age;
    }

    public void setAge(int age){
        this.age=age;
    }

    public String toString(){
        return "个人信息："+"\n"+
            "\t|--姓名："+this.name+
            "\t|--年龄："+this.age;
    }
}
```

 【定义Person类，使用泛型】 

```java
class Person<T extends Info>
{
    private T info;
    public Person(T info){
        this.setInfo(info);
    }
    public T getInfo(){
        return this.info;
    }
    public void setInfo(T info){
        this.info=info;
    }

    public String toString(){
        return this.info.toString();
    }
}
```

【测试】 

```java
public class Test
{
    public static void main(String args[]){
        //声明Person对象，同时指定Contact类型
        Person<Contact> per=null;
        per=new Person<Contact>(new Contact("中国","111111"));
        System.out.println(per);

        //声明Person对象，同时指定Introduce类型
        Person<Introduce> per2=null;
        per2=new Person<Introduce>(new Introduce("凹凸",20));
        System.out.println(per2);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127174058301.png)

## 泛型参数规范化

1. T 代表一般的任何类。 
2. E 代表 Element 的意思，或者 Exception 异常的意思。 
3. K 代表 Key 的意思。 
4. V 代表 Value 的意思，通常与 K 一起配合使用。 
5. S 代表 Subtype 的意思，文章后面部分会讲解示意。

如果一个类被 `<T> `的形式定义，那么它就被称为是泛型类。

## 泛型代码和虚拟机

泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，但显然，泛型代码能够很好地和之前版本的代码很好地兼容。因为，泛型信息只存在于代码编译阶段，在进入` JVM `之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。

**类型擦除:**

- Java 中的的泛型是 **伪泛型**，为什这么说呢？因为 Java 在编译期间，所有的泛型信息都被擦除掉，称为 **类型擦除(type erasure)**。
- 无论何时定义一个泛型类型，都会自动提供一个相应的 **原始类型 (raw type)(不存在泛型 )**。<u>原始类型的名字就是删去类型参数后泛型类的类型名,擦除类型变量，并替换为 **限定类型（没有限定的变量就用 Object ）**。</u>

- 通俗地讲，泛型类和普通类在 `java` 虚拟机内是没有什么特别的地方。

```java
List<String> l1 = new ArrayList<String>();
List<Integer> l2 = new ArrayList<Integer>();
 
System.out.println(l1.getClass() == l2.getClass());
```

打印的结果为 true 是因为 `List` 和 `List` 在 `jvm` 中的 Class 都是` List.class`。泛型信息被擦除了。

类型 String 和 Integer 进行了泛型转译。

### 通过反射添加其它类型元素

```java
public class Test {

    public static void main(String[] args) throws Exception {

        ArrayList<Integer> list = new ArrayList<Integer>();

        list.add(1);  //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer

        list.getClass().getMethod("add", Object.class).invoke(list, "asd");

        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }

}
```

在程序中定义了一个`ArrayList`泛型类型实例化为`Integer`对象，如果直接调用`add()`方法，那么只能存储整数数据，不过当我们利用反射调用`add()`方法的时候，却可以存储字符串，这说明了`Integer`泛型实例在编译之后被擦除掉了，只保留了原始类型。

### 类型擦除后保留的原始类型

<u>什么是原始类型？</u>

**原始类型** 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。

#### 原始类型Object

你以为的泛型

```java
class Pair<T> {  
    private T value;  
    public T getValue() {  
        return value;  
    }  
    public void setValue(T  value) {  
        this.value = value;  
    }  
}  
```

实际的原始类型

```java
class Pair {  
    private Object value;  
    public Object getValue() {  
        return value;  
    }  
    public void setValue(Object  value) {  
        this.value = value;  
    }  
}
```

因为在`Pair`中，T 是一个无限定的类型变量，所以用`Object`替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的`Pair`，如`Pair<String>`或`Pair<Integer>`，但是擦除类型后他们的就成为原始的`Pair`类型了，原始类型都是`Object`。

从上面的例2中，我们也可以明白`ArrayList`被擦除类型后，原始类型也变为`Object`，所以通过反射我们就可以存储字符串了。



- 如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。
- 比如: Pair这样声明的话

```java
public class Pair<T extends Comparable> {}
```

那么原始类型就是`Comparable`。

要区分原始类型和泛型变量的类型。

**在调用泛型方法时，可以指定泛型，也可以不指定泛型。**

- 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object
- 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类

```java
public class Test {  
    public static void main(String[] args) {  

        /**不指定泛型的时候*/  
        int i = Test.add(1, 2); //这两个参数都是Integer，所以T为Integer类型  
        Number f = Test.add(1, 1.2); //这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  
        Object o = Test.add(1, "asd"); //这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  

        /**指定泛型的时候*/  
        int a = Test.<Integer>add(1, 2); //指定了Integer，所以只能为Integer类型或者其子类  
        int b = Test.<Integer>add(1, 2.2); //编译错误，指定了Integer，不能为Float  
        Number c = Test.<Number>add(1, 2.2); //指定为Number，所以可以为Integer和Float  
    }  

    //这是一个简单的泛型方法  
    public static <T> T add(T x,T y){  
        return y;  
    }  
}
```

其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为`Object`，就比如`ArrayList`中，如果不指定泛型，那么这个`ArrayList`可以存储任意的对象。例如Object泛型：

#### Object泛型

```java
public static void main(String[] args) {  
    ArrayList list = new ArrayList();  
    list.add(1);  
    list.add("121");  
    list.add(new Date());  
} 
```

### 类型擦除引起的问题及解决方法

因为种种原因，Java不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀问题，但是也引起来许多新问题，所以，SUN对这些问题做出了种种限制，避免我们发生各种错误。

#### 先检查，再编译以及编译的对象和引用传递问题

问：既然说类型变量会在编译的时候擦除掉，那为什么我们往 `ArrayList `创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？

答：Java编译器是通过先检查代码中泛型的类型，然后再进行类型擦除，再进行编译。

例如：

```java
public static  void main(String[] args) {  
    ArrayList<String> list = new ArrayList<String>();  
    list.add("123");  
    list.add(123);//编译错误  
}
```

在上面的程序中，使用`add`方法添加一个整型，在`IDEA`中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为`Object`，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。

那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。

以 `ArrayList`举例子，以前的写法:

```java
ArrayList list = new ArrayList();  
```

现在的写法:

```java
ArrayList<String> list = new ArrayList<String>();
```

如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：

```java
ArrayList<String> list1 = new ArrayList(); //第一种 情况
ArrayList list2 = new ArrayList<String>(); //第二种 情况
```

这样是没有错误的，不过会有个编译时警告。

不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。

因为类型检查就是编译时完成的，`new ArrayList()`只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正设计类型检查的是它的引用，因为我们是使用它引用`list1`来调用它的方法，比如说调用`add`方法，所以`list1`引用能完成泛型类型的检查。而引用`list2`没有使用泛型，所以不行。

举例子：

```java
public class Test {  

    public static void main(String[] args) {  

        ArrayList<String> list1 = new ArrayList();  
        list1.add("1"); //编译通过  
        list1.add(1); //编译错误  
        String str1 = list1.get(0); //返回类型就是String  

        ArrayList list2 = new ArrayList<String>();  
        list2.add("1"); //编译通过  
        list2.add(1); //编译通过  
        Object object = list2.get(0); //返回类型就是Object  

        new ArrayList<String>().add("11"); //编译通过  
        new ArrayList<String>().add(22); //编译错误  

        String str2 = new ArrayList<String>().get(0); //返回类型就是String  
    }  

}  
```

通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。

#### 泛型中参数话类型为什么不考虑继承关系？

在Java中，像下面形式的引用传递是不允许的:

```java
ArrayList<String> list1 = new ArrayList<Object>(); //编译错误  
ArrayList<Object> list2 = new ArrayList<String>(); //编译错误
```

我们先看第一种情况，将第一种情况拓展成下面的形式：

```java
ArrayList<Object> list1 = new ArrayList<Object>();  
list1.add(new Object());  
list1.add(new Object());  
ArrayList<String> list2 = list1; //编译错误
```

实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用`list2`引用用`get()`方法取值的时候，返回的都是`String`类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了`Object`类型的对象，这样就会有`ClassCastException`了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。

再看第二种情况，将第一种情况拓展成下面的形式：

```java
ArrayList<String> list1 = new ArrayList<String>();  
list1.add(new String());  
list1.add(new String());

ArrayList<Object> list2 = list1; //编译错误
```

没错，这样的情况比第一种情况好的多，最起码，在我们用`list2`取值的时候不会出现`ClassCastException`，因为是从`String`转换为`Object`。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以Java不允许这么干。再说，你如果又用`list2`往里面`add()`新的对象，那么到时候取得时候，我怎么知道我取出来的到底是`String`类型的，还是`Object`类型的呢？

**所以，要格外注意，泛型中的引用传递的问题。**

#### 自动类型转换

因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。

既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？

看下`ArrayList.get()`方法：

```java
public E get(int index) {  

    RangeCheck(index);  

    return (E) elementData[index];  

}
```

可以看到，在`return`之前，会根据泛型变量进行强转。假设泛型类型变量为`Date`，虽然泛型信息会被擦除掉，但是会将`(E) elementData[index]`，编译为`(Date)elementData[index]`。所以我们不用自己进行强转。当存取一个泛型域时也会自动插入强制类型转换。假设`Pair`类的`value`域是`public`的，那么表达式：

`Date date = pair.value;`也会自动地在结果字节码中插入强制类型转换。

#### 类型擦除与多态的冲突和解决方法

现在有这样一个泛型类：

```java
class Pair<T> {  

    private T value;  

    public T getValue() {  
        return value;  
    }  

    public void setValue(T value) {  
        this.value = value;  
    }  
}
```

然后我们想要一个子类继承它。

```java
class DateInter extends Pair<Date> {  

    @Override  
    public void setValue(Date value) {  
        super.setValue(value);  
    }  

    @Override  
    public Date getValue() {  
        return super.getValue();  
    }  
}
```

在这个子类中，我们设定父类的泛型类型为`Pair`，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为`Date`，那么父类里面的两个方法的参数都为`Date`类型。

```java
public Date getValue() {  
    return value;  
}  

public void setValue(Date value) {  
    this.value = value;  
}
```

所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的`@Override`标签中也可以看到，一点问题也没有，实际上是这样的吗？

分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型`Object`，所以父类编译之后会变成下面的样子：

```java
class Pair {  
    private Object value;  

    public Object getValue() {  
        return value;  
    }  

    public void setValue(Object  value) {  
        this.value = value;  
    }  
} 
```

再看子类的两个重写的方法的类型：

```java
@Override  
public void setValue(Date value) {  
    super.setValue(value);  
}  
@Override  
public Date getValue() {  
    return super.getValue();  
}
```

先来分析`setValue`方法，父类的类型是`Object`，而子类的类型是`Date`，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。



我们在一个main方法测试一下：

```java
ublic static void main(String[] args) throws ClassNotFoundException {  
        DateInter dateInter = new DateInter();  
        dateInter.setValue(new Date());                  
        dateInter.setValue(new Object()); //编译错误  
}
```

如果是重载，那么子类中两个`setValue`方法，一个是参数`Object`类型，一个是`Date`类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，确实是重写了，而不是重载了。

为什么会这样呢？

原因是这样的，我们传入父类的泛型类型是`Date，Pair`，我们的本意是将泛型类变为如下：

```java
class Pair {  
    private Date value;  
    public Date getValue() {  
        return value;  
    }  
    public void setValue(Date value) {  
        this.value = value;  
    }  
}
```

然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。

可是由于种种原因，虚拟机并不能将泛型类型变为`Date`，只能将类型擦除掉，变为原始类型`Object`。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的`Date`类型参数的方法啊。

于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。

首先，我们用`javap -c className`的方式反编译下`DateInter`子类的字节码，结果如下：

```java
class com.tao.test.DateInter extends com.tao.test.Pair<java.util.Date> {  
  com.tao.test.DateInter();  
    Code:  
       0: aload_0  
       1: invokespecial #8                  // Method com/tao/test/Pair."<init>":()V  
       4: return  

  public void setValue(java.util.Date);  //我们重写的setValue方法  
    Code:  
       0: aload_0  
       1: aload_1  
       2: invokespecial #16                 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  
       5: return  

  public java.util.Date getValue();    //我们重写的getValue方法  
    Code:  
       0: aload_0  
       1: invokespecial #23                 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  
       4: checkcast     #26                 // class java/util/Date  
       7: areturn  

  public java.lang.Object getValue();     //编译时由编译器生成的巧方法  
    Code:  
       0: aload_0  
       1: invokevirtual #28                 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  
       4: areturn  

  public void setValue(java.lang.Object);   //编译时由编译器生成的巧方法  
    Code:  
       0: aload_0  
       1: aload_1  
       2: checkcast     #26                 // class java/util/Date  
       5: invokevirtual #30                 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  
       8: return  
}
```

从编译的结果来看，我们本意重写`setValue`和`getValue`方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的`setvalue`和`getValue`方法上面的`@Oveerride`只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。

所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。

不过，要提到一点，这里面的`setValue`和`getValue`这两个桥方法的意义又有不同。

`setValue`方法是为了解决类型擦除与多态之间的冲突。

而`getValue`却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：

那么父类的`setValue`方法如下：

```java
public ObjectgetValue() {  
    return super.getValue();  
}
```

而子类重写的方法是：

```java
public Date getValue() {  
    return super.getValue();  
}
```

其实这在普通的类继承中也是普遍存在的重写，这就是协变。

关于协变：。。。。。。

并且，还有一点也许会有疑问，子类中的巧方法`Object getValue()`和`Date getValue()`是同 时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。

#### 泛型类型变量不能是基本数据类型

不能用类型参数替换基本类型。就比如，没有`ArrayList`，只有`ArrayList`。因为当类型擦除后，`ArrayList`的原始类型变为`Object`，但是`Object`类型不能存储`double`值，只能引用`Double`的值。

#### 运行时类型查询

```java
ArrayList<String> arrayList = new ArrayList<String>();
```

因为类型擦除之后，`ArrayList`只剩下原始类型，泛型信息`String`不存在了。

那么，运行时进行类型查询的时候使用下面的方法是错误的

```java
if( arrayList instanceof ArrayList<String>)
```

#### 泛型在静态方法和静态类中的问题

泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数

举例说明：

```java
public class Test2<T> {    
    public static T one;   //编译错误    
    public static  T show(T one){ //编译错误    
        return null;    
    }    
}
```

因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。

但是要注意区分下面的一种情况：

```java
public class Test2<T> {    

    public static <T >T show(T one){ //这是正确的    
        return null;    
    }    
}
```

因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。