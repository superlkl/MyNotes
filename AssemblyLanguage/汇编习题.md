# 基础概念

- 8086CPU有14个寄存器 它们的名称为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW
- 8086CPU所有的寄存器都是16位的，可以存放两个字节
- AX、BX、CX、DX 通常用来存放一般性数据被称为通用寄存器
- 8086上一代CPU中的寄存器都是8位的；
- 为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。
  - AX可以分为AH和AL；
  - BX可以分为BH和BL；
  - CX可以分为CH和CL；
  - DX可以分为DH和DL
- DEBUG

>- R命令查看、改变CPU寄存器的内容；
>- D命令查看内存中的内容；
>- E命令改写内存中的内容；
>- U命令将内存中的机器指令翻译成汇编指令；
>- T命令执行一条机器指令；
>- A命令以汇编指令的格式在内存中写入一条机器指令

# 汇编习题

## 1.1

1. 1个CPU的寻址能力为8KB，那么它的地址总线的宽度为 13位
2. 1KB的存储器有 1024 个存储单元，存储单元的编号从 0 到 1023 
3. 1KB的存储器可以存储 8192（2^13） 个bit， 1024个Byte
4. 1GB 是 1073741824 （2^30） 个 Byte、1MB 是 1048576（2^20） 个 Byte、1KB 是 1024（2^10）个Byte
5. 8080、8088、80296、80386 的地址总线宽度分别为 16根、20根、24根、32根，则 它们的寻址能力分别为: 64 （KB）、 1 （MB）、 16 （MB）、 4 （GB）
6. 8080、8088、8086、80286、80386 的数据总线宽度分别为 8根、8根、16根、16根、 32 根。则它们一次可以传送的数据为: 1 （B）、 1 （B）、 2 （B）、 2 （B）、 4 （B）
7. 从内存中读取1024字节的数据，8086至少要读 512 次，80386至少要读 256 次
8. 在存储器中，数据和程序以 二进制 形式存放

---

- **解题过程：**

1. 1KB=1024B，8KB=1024B*8=2^N，N=13
2. 存储器的容量是以字节为最小单位来计算的，1KB=1024B
3. 8Bit=1Byte，1024Byte=1KB（1KB=1024B=1024B*8Bit）。
4. 1GB=1073741824B（即2^30）1MB=1048576B（即2^20）1KB=1024B（即2^10）
5. 一个CPU有 N根地址线，则可以说这个 CPU的地址总线的宽度为 N。这样的 CPU最 多可以寻找2的N次方个内存单元。（一个内存单元=1Byte）
6. 8根数据总线一次可以传送8位二进制数据（即一个字节）
7. 8086 的数据总线宽度为 16 根（即一次传送的数据为 2B）1024B/2B=512，同理 1024B/4B=256
8. 在存储器中指令和数据没有任何区别，都是二进制信息

##  2.1

- 写出每条汇编指令执行后相关寄存器中的值，以下指令是在16位计算机中完成的(两个字节)

```assembly
mov ax,62627   AX=F4A3H   ;62627十进制 = F4A3H 十六进制
mov ah,31H     AX=31A3H   ;31H覆盖ax的高位
mov al,23H     AX=3123H   ;23H覆盖ax的地位
add ax,ax      AX=6246H 
mov bx,826CH   BX=826CH 
mov cx,ax      CX=6246H 
mov ax,bx      AX=826CH 
add ax,bx      AX=04D8H 
mov al,bh      AX=0482H 
mov ah,bl      AX=6C82H 
add ah,ah      AX=D882H   ;ax的高位字节相加
add al,6       AX=D888H 
add al,al      AX=D810H   ;ax的低位字节相加
mov ax,cx      AX=6246H
```

- 只能使用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方

```assembly
mov  ax,2         AX=2 
add  ax,ax        AX=4 
add  ax,ax        AX=8 
add  ax,ax        AX=16 
```

## 2.2

1. 给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 0010H 到 1000FH 。

- 解题过程：

>- 物理地址＝SA * 16+EA 
>- EA的变化范围为0h~ffffh 
>- 物理地址范围为(SA * 16+0h)~(SA * 16+ffffh)
>- 现在SA=0001h,那么寻址范围为 (0001h * 16+0h)~(0001h * 16+ffffh) =0010h~1000fh  

---

2.  有一数据存放在内存 20000H单元中，现给定段地址为 SA，若想用偏移地址寻到此单元。 则SA应满足的条件是：最小为 1001H ，最大为 2000H 
   - 当段地址给定为 1001H 以下和 2000H 以上，CPU 无论怎么变化偏移地址都无法寻到 20000H单元

- 解题过程：

>- 物理地址＝SA * 16+EA 
>- 20000h＝SA * 16+EA 
>- SA=(20000h-EA)/16=2000h-EA/16 
>- EA取最大值时,SA=2000h-ffffh/16=1001h,SA为最小值 
>- EA取最小值时,SA=2000h-0h/16=2000h,SA为最大值 

- 注：取最大值的除法部分是除不尽的，所以向上取值为1001H

## 2.3

- 下面的3条指令执行后，cpu几次修改IP？都是在什么时候？最后IP中的值是多少？ 

```assembly
mov ax,bx ;第一次：读取mov ax,bx之后 
sub ax,ax ;第二次：读取sub ax,ax之后 
jmp ax ;第三次：读取jmp ax之后 第四次：执行jmp ax修改IP 
```

- 答：一共修改四次
- 最后IP的值为0000H，因为最后ax中的值为0000H，所以IP中的值也为0000H 
- 在取得执行指令的地址后IP地址就会修改然后在执行对应的mov或sub或jmp指令

## 3.1

- 在DEBUG中,用 "D 0:0 lf" 查看内存,结果如下: 

>0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 60 
>0000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88 

- 下面的程序执行前,AX=0,BX=0,写出每条汇编指令执行完后相关寄存器中的值
- 关键：段地址 * 16 + 偏移地址

```assembly
mov ax,1 ;把1h放入ax寄存器中
mov ds,ax ;把ax中的数据作为段地址
mov ax,[0000]  ax=2662H ;0001h*16+0000h = 0010h ==> 2362H
mov bx,[0001]  bx=E626H ;0001h*16+0001h = 0011h ==> E626H
mov ax,bx      ax=E626H 
mov ax,[0000]  ax=2662H 
mov bx,[0002]  bx=D6E6H ;0001h*16+0002h = 0012h ==> D6E6H
add ax,bx      ax=FD48H 
add ax,[0004]  ax=2C14H ;0001h*16+0004h = 0014h ==> FD48H+2ECCH=12C14H ==> 2C14H
mov ax,0       ax=0   
mov al,[0002]  ax=00e6H 
mov bx,0       bx=0   
mov bl,[000c]  bx=0026H 
add al,bl      ax=000CH 
```

## 3.2

- 补全下面的程序，使其可以将 10000H—1000FH 中的 8 个字，逆序拷贝到 20000H—2000FH中
- **压栈**

```assembly
mov ax,1000H 
mov ds,ax ;段地址为1000H
mov ax,2000H 
mov ss,ax ;ss指向栈空间段地址 2000H    
mov sp,0 ;sp指向栈空间偏移地址 0000H   
push [0] ;将10000H地址里的字压入地址为20000H的栈空间------1
push [2] ;将10002H地址里的字压入地址为20002H的栈空间------2
push [4] ;...以此类推------X
push [6] 
push [8] 
push [A] 
push [C] 
push [E] 
```

---

- **弹栈**

```assembly
mov ax,2000H 
mov ds,ax ;段地址为2000H
mov ax,1000H
mov ss,ax ;初始栈空间段地址1000H 
mov sp,0  ;初始栈空间偏移地址0000H  
pop [e]   ;2000EH地址处的数据出栈------即第8个字出栈变成第一个
pop [c]   ;2000CH地址处的数据出栈------即第7个字出栈变成第一个
pop [a]   ;以此类推,实现逆序拷贝
pop [8] 
pop [6] 
pop [4] 
pop [2] 
pop [0] 
```

